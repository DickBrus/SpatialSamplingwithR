---
title: "Spatial sampling with R"
author: "Dick J. Brus"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site #heb ik nu in bookdown.yml gezet
documentclass: book
output: bookdown::gitbook
cover-image: "cover.png"
papersize: b5
fontsize: 10pt
bibliography: [referencesSampling.bib]
biblio-style: apalike
link-citations: yes
---

```{r, include=FALSE, echo=FALSE}
library(knitr)
knitr::knit_hooks$set(crop = knitr::hook_pdfcrop)
opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE, comment="", tidy=FALSE, crop=TRUE, out.width="80%", dpi=300, fig.width=7, fig.asp=1, fig.align="center")
```

```{r loadlibraries, echo=FALSE}
library(tidyverse)
library(data.table)
library(kableExtra)
library(gridExtra)

library(ggplot2)
library(ggforce)

library(e1071)
library(mvtnorm)

library(sp)
library(gstat)
library(geoR)
library(maptools)
library(rgdal)
library(fields)
library(raster)

library(sampling)
library(survey)
library(stratification)
library(SamplingStrata)
library(spcosa)
library(BalancedSampling)
library(forestinventory)
library(spsann)
library(clhs)
library(spsurvey)
```
\frontmatter

# Preface {-}

Since the start of the R Series of Chapman and Hall/CRC in 2011 numerous books have been published on the statistical analysis and modelling of data using **R**. Until now no book was published in this series on how these data can be best collected. From my viewpoint this was an omission, as scientific research often starts with data collection. If the data collection is part of the project, it might be a good idea to start thinking right at the start of the project instead of after the data have been collected, to make a well-founded decision on how many data are needed and on the type of sampling design. 

In the past decades numerous wall-to-wall data sets are collected by remote sensing devices such as satellites and drones. These remote sensing images are valuable sources of information of the natural environment and resources. The question may arise how useful it still is in this big data era to collect data in the field at a restricted number of sampling locations. Do we really need these data to estimate a population mean or total, for instance of the aboveground biomass or carbon stocks in the soil, or to map these study variables? In many cases the answer is that it is indeed still useful to collect sample data on the study variable, because the remote sensing images provide only proxys of the study variable. The variables derived from the remote sensing images can be related to the study variable, but we still need groundtruth data of the study variable to model this relation. By combining the wall-to-wall data of covariates and the sample data of the groundtruth we can increase the accuracy of the survey result compared to using only one of these data sources.

The handbook Sampling for Natural Resource Monitoring (SNRM) [@gru06] presents an overview of sampling strategies for the survey of natural resources at a given point in time, as well as for how these resources can be monitored through repeated surveys. This new book can be seen as a follow-up of SNRM. In SNRM spatial sampling designs for survey and space--time designs for monitoring are described and illustrated with notional and real world examples. Estimators for global and local quantities in space and in space--time, and for the variance of these estimators are presented. However, neither computer code for how a sample with a given design can be selected, nor code for how the estimates can be computed is presented in SNRM. This new book fills this gap.

This book describes and illustrates classical, basic sampling designs for spatial survey, as well as more recently developed, advanced sampling designs and estimators. Part I of the book is about random sampling designs for estimating a mean, total or proportion of a population or of several subpopulations. Part II focuses on sampling designs for mapping.

The computer code is written in the popular programming language **R** [@R2020]. There are several good reasons for choosing **R** as a language. First of all it is open source, giving users the right to view the source code and modify it to their needs. Second, as a result of this open source, numerous add-on packages have been developed, and this number is still increasing. Happily enough also quite a few add-on packages have been published for sampling design and analysis. All these add-on packages make the writing of computer code much more simple. Even very advanced statistical methods for sampling design and statistical analysis are now in the reach of many scientists: only a few lines of **R** code are needed to do the work. A risk is that the appliers of the packages do not fully understand the implemented statistical method. This understanding is not needed to obtain a result. For this reason I decided not to jump to the add-on packages right after the theory, but to follow a more gradual approach. First I show in as simple as possible **R** code how a sample can be selected with a given sampling design and how the (sub)population parameters can be estimated. After that I show how the same result can be obtained with an add-on package.

The target group of this book are practitioners of sample surveys, as well as students in environmental, ecological, agricultural science or any other science in which knowledge about a population of interest is collected through spatial sampling. I have added exercises to quite a few chapters, making this book suitable as a textbook for students. The answers to the exercises can be found in the appendix of this book. Large parts of the book are self-contained, requiring no prior knowledge of statistics. For the chapters in Part I on more advanced sampling designs, such as balanced sampling, and advanced estimators of (sub)population parameters (model-assisted estimators), knowledge of matrix algebra and regression analysis is required. For the final chapters of Part II basic knowledge of geostatistics is required. This knowledge is also needed for some chapters in Part I. For that reason I have added a chapter introducing the basics of geostatistics (Chapter \@ref{Introkriging). 

A gitbook version of this book (html files) is available at https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master. This is also the place where you can report errata and comment on text and/or **R** code. 

<!-- Mention **R** package **SPSRBook** with the data files used in this book and some **R** functions. Package **SPSRBook** is not available on CRAN. It must be installed with remotes::github(...) -->

## Acknowledgements {-}

In 2006 our handbook Sampling for Natural Resource Monitoring (SNRM) was published [@gru06]. Soon after this milestone Jaap retired from Wageningen University and Research (WUR). Now I arrived in the aftermath of my career at WUR. Since a couple of years I was thinking of a revision of our handbook, to repair errors and to include new developments in sampling design. Then I realized that to increase the impact of our book, it might be a better idea to write a new book, showing with computer code how the sampling designs can be implemented, and how the sample data can be used in statistical inference.

A nice side effect of the publication of SNRM was that I was asked to give sampling courses at many places in the world: China, Ethiopia, Uzbekistan, Australia and various countries in the European Union. I have very good memories of these courses, they made my life as a scientist very joyful. For these courses I wrote numerous scripts with computer code, using the popular programming language **R** [@R2020]. My naive idea was that all I had to do is to bundle these **R** scripts into an Rmarkdown document [@Xie2020], and add some text explaining the theory and the **R** code. As usual, it appeared to be much more work than expected, but I am very happy that I was able to finish the job just before my retirement. My experience as a statistical consultant is that many researchers pay little attention to the method for data collection. Too many researchers start thinking when the data are there. Often I had to conclude that the way the data were collected was suboptimal, or even unsuitable for their aim. I hope that this new book may help researchers, practitioners and students to implement proper sampling designs, tailored at their problems at hand, so that valuable data are collected that can be used to answer the research questions.

I could not have written  this book without the help of many fellow researchers. First, I am very grateful for the support I received from the authors of various packages used in this book: Thomas Lumley for his support with package **survey**, Yves Till&eacute; and Alina Gabriela Matei with package **sampling**, Anton Grafstr&ouml;m with package **Balancedsampling**, Giulio Barcaroli and Marco Ballin with package **SamplingStrata**, Andreas Hill and Alex Massey with package **Forestinventory**, and Martins Liberts with package **surveyplanning**. No need to say that I am responsible for all shortcomings of the **R** code. 

Second, I would like to thank the following researchers for their valuable comments on (parts) of the book: Gerard Heuvelink (Wageningen University and ISRIC World Soil Information, Netherlands), David Rossiter (Cornell University, USA and ISRIC World Soil Information, Netherlands), Yuha Heikkinen (Luke, Natural Resources Institute, Finland), Steve Stehman (SUNY College of Environmental Science and Forestry, USA), Anton Grafstr&ouml;m (Swedish University of Agricultural Sciences), Dennis Walvoort (Wageningen University and Research, Netherlands) and Ben Marchant (British Geological Survey, United Kingdom). Dennis Walvoort also was very supportive with the writing of various **R** scripts.
<!--and the **R** package of this book **SPSRBook**. -->

Finally, I  would like to thank Alexandre Wadoux (University of Sydney) for preparing the data set of aboveground biomass and numerous environmental and climatological covariates of Eastern Amazonia (Brazil); Coen Bussink (UN Organization on Drugs and Crime) for giving permission to use data on the occurrence of opium poppy fields in Kandahar (Afghanistan), Akmal Akramkhanov for providing the data set with measurements of the salinity of soil at a farm which is part of a regional Cotton Research
Station in Khorezm (Uzbekistan). These data were collected in the ZEF/UNESCO Landscape Restructuring project in Khorezm province, with financial support by the German Ministry for Education and Research (BMBF; project number 0339970A); Lin Yang (Nanjing University) for giving permission to use the data on soil organic matter concentration in Xuancheng (China) collected in a project supported by the National Natural Science Foundation of China (Project No 41471178, 41431177); Hailu Shiferaw (Ethiopian Agricultural Transformation Agency)  to allow me to use the soil organic matter data in three woredas in Ethiopia; Siegfried Hofman (Flemish Institute for Technological Research) for giving permission to use the nitrate-N data of several agricultural fields in Flanders (Belgium); and Budiman Minasny (University of Sydney) for giving permission to use the raster maps with terrain attributes in Hunter Valley (Australia).




\mainmatter

<!--chapter:end:index.Rmd-->

# Introduction {#GeneralIntro}

This book is about sampling for spatial *surveys*. A survey\index{Survey} is an inventory of an object of study about which statements will be made, referred to as the population of interest or target population, by collecting data on the population. Examples are a survey of the organic carbon stored in the soil of a country, the water quality of a lake, the wood volume in a forest, the total annual yield of rice in a country, etc. So this book is about *observational research*, not about experiments. In experiments observations are done under controlled circumstances, think of an experiment on crop yields as a function of application rates of fertilizer. Several levels of fertilizer application rate are chosen and randomly assigned to experimental plots. In observational research factors that influence the study variable are not controlled. This implies that in observational research no conclusions can be drawn on causal relations.

If the whole population is observed this is referred to as a *census*\index{Census}. In general we cannot afford such a census. Only some parts of the population are selected and properties of the study variable are observed (measured) on these selected parts only. Such a survey is referred to as a *sample survey*\index{Sample survey}. The observations are subsequently used to derive characteristics of the whole population. For instance, to estimate the wood volume in a forest, we cannot afford to measure the wood volume of every tree in the forest. Instead, some trees are selected, the wood volume of these trees is measured, and based on these measurements the total wood volume in the forest is estimated.

## Basic sampling concepts {#BasicConcepts}

In this book the populations of interest have a spatial dimension. In selecting parts of such populations for observation we may account for the spatial coordinates of the parts, but this is not strictly needed. Examples of spatial sampling designs are designs selecting sampling units that are spread out throughout the study area, often leading to more precise estimates of the population mean or total.

Two types of populations can be distinguished: discrete and continuous populations. *Discrete populations* consist of discrete, natural objects, think of trees, agricultural fields, lakes etc. These objects are referred to as *population units*\index{Population unit}. The total number of population units in a discrete population\index{Population!discrete population} is finite. A finite spatial population of discrete units can be denoted by $\mathcal{U}=\{u(\mathbf{s}_1),u(\mathbf{s}_2), \dots , u(\mathbf{s}_N)\}$, with $u(\mathbf{s}_k)$ the unit located at $\mathbf{s}_k$, where $\mathbf{s}$ is a vector with spatial coordinates. The population units naturally serve as the *elementary sampling units*\index{Elementary sampling unit}. In this book the spatial populations are two-dimensional, so a vector $\mathbf{s}$ has two coordinates, Easting and Northing. 

Other populations may, for the purpose of sampling, be considered as a physical continuum, e.g. the soil in a region, the water in a lake, the crop on a field if interest lies in crop properties per areal unit of the field^[If interest lies in properties per plant, the population is discrete.]. Such continuous, spatial populations can be denoted by $\mathcal{U}=\{u(\mathbf{s}), \mathbf{s} \in \mathcal{A} \}$, with $\mathcal{A}$ the study area. Discrete objects that can serve as elementary sampling unit do not exist in such *continuous populations*\index{Population!continuous population}. We must define these elementary sampling units. The elementary sampling units can be areal units, e.g. 10 m by 10 m squares or circular plots with a radius of 5 m, or "points", i.e. units that have an area that is so small compared to the area of the population that the area can be ignored. 

In this book a population unit and an elementary sampling unit can be an individual object of a discrete population, as well as a point or areal sampling unit\index{Areal sampling unit} of a continuous population.

The size and geometry of the elementary units used in sampling a continuous population is referred to as the sample support\index{Sample support}. The total number of elementary sampling units in a continuous population can be finite, e.g. all 25 m by 25 m (disjoint) raster cells in an area (raster cells in Figure \@ref(fig:support)), or infinite, e.g. all points in an area, or all squares or circular plots with a given radius that are allowed to overlap in an area (circles in Figure \@ref(fig:support)). 

```{r support, echo=FALSE, out.width='100%', fig.cap="Three sample supports: points, squares and circles. With disjoint squares the population is finite. With points, and squares or circles that are allowed to overlap as sample support the population is infinite."}
#Point support
set.seed(314)
s1 <- runif(10,min=-4,max=104)
s2 <- runif(10,min=-4,max=104)
mysisample <- data.frame(x=s1,y=s2)

plt1 <- ggplot() +
  geom_tile(aes(x=50,y=50), width=100, height=100, fill="grey") +
  geom_point(data=mysisample,aes(x=x, y=y), size=1) +
  scale_x_continuous(name="", limits=c(0,100)) +
  scale_y_continuous(name="", limits=c(0,100)) +
  coord_fixed()

#Square support
x <- y <- seq(from=5, to=95, by=10)
grid <- expand.grid(x,y)
names(grid) <- c("x","y")
units <- sample.int(nrow(grid), size=10, replace=FALSE)
mysisample <- grid[units,]

plt2 <- ggplot(data=grid) +
  geom_tile(mapping=aes(x=x, y=y),width=10,height=10,fill="grey") +
  geom_tile(data=mysisample,mapping=aes(x=x, y=y), colour="red", size=0.8, width=10, height=10, fill=NA)+
  scale_x_continuous(name="") +
  scale_y_continuous(name="") +
  coord_fixed()

#Circle support
set.seed(315)
s1 <- runif(10,min=0,max=100)
s2 <- runif(10,min=0,max=100)
circles <- data.frame(s1,s2)

plt3 <- ggplot() +
  geom_tile(aes(x=50,y=50), width=100, height=100, fill="grey") +
  geom_point(data=circles,aes(x=s1, y=s2), size=1) +
  geom_circle(data=circles, aes(x0=s1, y0=s2, r=4)) +
  scale_x_continuous(name="") +
  scale_y_continuous(name="") +
  coord_fixed()

grid.arrange(plt1, plt2, plt3, nrow=1)
```

With areal elementary sampling units, ideally the selected elementary units are exhaustively observed, so that a measurement of the total or mean of the study variable within an areal unit is obtained, think for instance of the total aboveground biomass. In some cases this is not feasible, think for instance of measuring the mean of some soil property in squares of 25 m x 25 m. In this case from each selected square a sample of points is selected, and the measurement is done on the selected points. These measurements at points are used to estimate the mean of the squares. @Stehman2018 introduced the concept of a response design\index{Response design} as "the protocol used to determine the reference condition of an element of the population". So in this case the response design is the sampling design and estimator for the mean of the areal units.  

Ideally the sample support is constant, but in some situations a varying sample support cannot be avoided. Think, for instance, of square sampling units in an irregularly shaped study area. Near the border of the study area there are squares that cross the border. The part of a square that falls outside the study area is not observed. So the support of the observation on these sampling units near the border is smaller than for the squares in the interior of the study area. See also Section \@ref(SIcircularplots).

To sample a finite spatial population, the population units are listed in a data frame. This data frame contains the spatial coordinates of the population units, and other information needed for selecting sampling units according to a specific design. Think, for instance, of the labels of more or less homogeneous subpopulations (used as strata in stratified random sampling, see Chapter \@ref(STSI)), and the labels of clusters of population units, for instance, all units in a polygon of a map (used in cluster random sampling, see Chapter \@ref(Cl)). Besides, if we have information about covariates possibly related to the study variable, which we would like to use in selecting the population units, these covariates are added to the list. The list used for selecting sampling units is referred to as the *sampling frame*\index{Sampling frame}. 

In this book also continuous populations are sampled using a list as a sampling frame. The infinite population is discretised by the nodes of a fine square grid. The grid nodes are listed in the sampling frame. So the infinite population is represented by a finite list of points that are the centers of square grid cells. The advantage of this is that existing **R** packages for sampling of finite populations can also be used for sampling infinite populations.

If the disjoint square grid cells are the elementary sampling units (sample support is a square) the population is finite, and the grid cells can be selected through selection of their centers that are listed in the sampling frame. The grid cells can be selected without or with replacement.

If the elementary sampling units are points (sample support is a point), the population is infinite. In this case sampling of points can be implemented by a two-step approach. In the first step grid cells are selected without or with replacement, and in the second step one or more points are selected within the selected grid cells. Figure \@ref(fig:SamplingFromInfinitePopulation) is an illustration of this two-step approach for simple random sampling of points from a discretised infinite population. Ten grid cells are selected by simple random sampling with replacement. Every time a grid cell is selected one point is randomly selected from that grid cell. Note that a grid cell can be selected more than once, so that more than one point will be selected from that grid cell. Note also that we may select a point that falls outside the boundary of the study area. This is actually the case with one grid cell in Figure \@ref(fig:SamplingFromInfinitePopulation). These points outside the study area are discarded and replaced by a randomly selected new point inside the study area. Finally, note that near the boundary there are small areas that are not covered by a grid cell, so that no points can be selected in these areas. It is important that the discretisation grid is fine enough to keep the discretisation error\index{Discretisation error} so small that it can be ignored. The alternative is to extend the discretisation grid beyond the boundaries of the study area so that the full study area is covered by grid cells.

```{r SamplingFromInfinitePopulation, echo=FALSE, fig.cap="Sampling of points from discretised infinite population. The grid cells are randomly selected with replacement. Each time a grid cell is selected a random point is selected random from that grid cell."}
library(rgdal)
library(ggplot2)

Field <- readOGR(dsn="data", layer="Melle17", verbose=FALSE)
# remove projection attributes
proj4string(Field) <- NA_character_
Field@data$id <- rownames(Field@data)

#select centred square grid from Field
mygrid <- spsample(Field, type="regular", cellsize=c(2,2), offset=c(0.5,0.5))
xygrid <- data.frame(coordinates(mygrid))

set.seed(314)
units <- sample.int(nrow(xygrid), size=10)
mysample <- xygrid[units,]

mysample.pnts <- mysample
cellsize <- 2
mysample.pnts$x1 <- jitter(mysample.pnts$x1, amount=cellsize/2)
mysample.pnts$x2 <- jitter(mysample.pnts$x2, amount=cellsize/2)

FieldPoints <- fortify(Field, region="id")

# merge the "fortified" data with the data from our spatial object
FieldDF <- merge(FieldPoints, Field@data, by="id")

ggField <- ggplot() +
  geom_path(data=FieldDF, aes(x=long/1000, y=lat/1000), color="black") +
  geom_tile(data=xygrid,mapping=aes(x=x1/1000, y=x2/1000), width=2/1000,height=2/1000, size=0.6, colour="black", fill=NA) +
  geom_tile(data=mysample,mapping=aes(x=x1/1000, y=x2/1000), width=2/1000, height=2/1000, size=0.8, colour="red", fill=NA) +
  geom_point(data=mysample.pnts,mapping=aes(x=x1/1000, y=x2/1000), size=1, colour="red")+
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed() +
  theme(legend.position="none")
print(ggField)
```

### Population parameters {#PopulationParameters}

The sample data are used to estimate characteristics of the whole population\index{Population parameter}, e.g. the population mean\index{Population mean} or total\index{Population total}, some quantile e.g. the median or 90th percentile, or even the entire cumulative frequency distribution.

A finite population total is defined as

\begin{equation}
t(z) = \sum_{k \in \mathcal{U}} z_k = \sum_{k=1}^N z_k \;,
(\#eq:FinitePopTotal)
\end{equation}

with $N$ the number of population units, and $z_k$ the study variable for population unit $i$. A finite population mean is defined as a finite population total divided by $N$. An infinite population total is defined as an integral of the study variable over the study area:

\begin{equation}
t(z) = \int_{\mathbf{s} \in \mathcal{U}} z(\mathbf{s}) \;\mathrm{d}\mathbf{s} \;.
(\#eq:InfinitePopTotal)
\end{equation}

An infinite population mean is defined a finite population total divided by the area, $A$, covered by the population. 

A finite population proportion\index{Population proportion} is defined as the population mean of an 0/1 indicator $y$ with value 1 if the condition is satisfied, and 0 otherwise:

\begin{equation}
p=\frac{\sum_{k \in \mathcal{U}}y_k}{N} \;.
(\#eq:PopulationProportion)
\end{equation}

A cumulative distribution function\index{Cumulative distribution function} (CDF) is defined as

\begin{equation}
F(z)=\sum_{x\leq z} f(x) \;,
(\#eq:CDF)
\end{equation}

with $f(x)$ the proportion of population units whose value for the study variable $z$ equals $x$. A population quantile\index{Population quantile}, for instance the population median or the population 90th percentile is defined as

\begin{equation}
q_p= F^{-1}(p) \;,
(\#eq:PopQuantile)
\end{equation}

where $p$ is a number between 0 and 1 (e.g 0.5 for the median, 0.9 for the 90th percentile), and $F^{-1}(p)$ is the smallest value of the study variable $z$ satisfying $F(z)\geq p$.

In surveys of spatial populations the aim can also be to make a map of the population.

### Descriptive statistics versus inference about a population

As we have observed only a (small) part of the population, we are uncertain about the population parameter estimates and map. By using statistical methods we can quantify how uncertain we are about these results. In decision making it can be important to take this uncertainty into account. An example is a survey of water quality. In Europe the concentration levels of nutrients are regulated in the European Water Framework Directive. To test whether the mean concentration of a nutrient complies with its standard, it is important to account for the uncertainty in the estimated mean. When the estimated mean is just below the standard, there is still a large probability that the population mean exceeds the standard. This example shows that it is important to distinguish computing descriptive statistics from characterizing the population using the sample data. For instance, we can compute the sample mean (average of the sample data) without error, but if we use this sample mean as an *estimate* of the population mean, there is certainly an error in this estimate.

### Random sampling versus probability sampling

Many sampling methods are available. At the highest level one may distinguish random from non-random sampling methods. In random sampling a subset of population units is randomly selected from the population, using a random number generator. In non-random sampling no such (pseudo) random number generator is used. Examples of non-random sampling are convenience sampling e.g. along roads, arbitrary sampling i.e. sampling without a specific purpose in mind, and targeted sampling e.g. at sites suspected of soil pollution.

In the literature the term random sampling is often used for arbitrary sampling\index{Arbitrary sampling}, i.e. sampling without a specific purpose in mind. To avoid confusion the term *probability sampling*\index{Probability sampling} is used for random sampling using a (pseudo) random number generator, so that for any unit in the population the probability of selecting that unit is known. More precisely, a probability sample is a sample from a population such that every unit of the population has a positive probability of being included in the sample. Besides, these *inclusion probabilities* must be known, at least for the selected units, as they are needed in estimation. This is explained in following chapters.

## Design-based versus model-based approach {#DBvsMB}

The choice between probability or non-probability sampling\index{Non-probability sampling} is closely connected with the choice between a design-based\index{Design-based approach} or model-based approach\index{Model-based approach} for sampling and statistical inference (estimation, hypothesis testing). The difference between these two approaches is a rather technical subject, and therefore not to discourage you already in this very first chapter, I keep it short. In Chapter \@ref(Approaches) I elaborate on the fundamental difference of these two approaches and a third approach, the model-assisted approach, which can be seen as a compromise of the design-based and model-based approach.

```{r approach, echo=FALSE}
approach <- data.frame(Approach=c("Design-based","","Model-based"), Sampling=c("Probability sampling","","Probability sampling not required"), Inference=c("Based on sampling distribution", "(no model-used)","Based on statistical model"))

knitr::kable(
  approach, caption = 'Statistical approaches for sampling and inference.',
  booktabs = TRUE
) %>%
  kable_classic()
```

In the design-based approach units are selected by probability sampling (Table \@ref(tab:approach)). Estimates are based on the inclusion probabilities of the sampling units as determined by the sampling design (design-based inference). No model is used in estimation. On the contrary, in a model-based approach a statistical model is used in prediction, i.e. a model with a random error term, for instance a regression model. As the model already contains a random error term, probability sampling is not required in this approach.

Which statistical approach is best largely depends on the aim of the survey, see @bru97 and @gru06. Broadly speaking the following aims can be distinguished:

1. To *estimate parameters* (mean, total, proportion, percentile) for the population.  
2. To *estimate parameters* (mean, total, proportion, percentile) for several subpopulations.  
3. To *map the study variable*^[A map of the study variable is obtained by predicting the study variable at the points of a very fine grid discretising the study area.]. 

When the aim is to map the study variable, a model-based approach is the most natural option. This implies that for this aim probability sampling is not required. For estimating (sub)population parameters\index{Population parameter} in principle both approaches are suitable. The more subpopulations\index{Subpopulation} are distinguished, the more attractive a model-based approach becomes. If the units are selected by probability sampling, then estimates of the population parameters can be obtained by design-based or model-based inference. This flexibility can be attractive, for instance when the sample size is rather small for model building. When the sampling units are not selected by probability sampling, model-free, design-based estimation is impossible, and model-based estimation is the only option.

## Populations used in sampling experiments {#Datasets}

In this book various data sets are used to illustrate the sampling designs. Three data sets, Voorst, Kandahar and Eastern Amazonia, are exhaustive, i.e. for all population units data of the study variable and ancillary data are available.  Two exhaustive data sets\index{Exhaustive data set}, Voorst in the Netherlands and Kandahar in Afghanistan, are obtained through  simulation\index{Simulation}, i.e. by drawing numbers from a probability distribution. Sample data from these two study areas are used to calibrate a statistical model. This model is subsequently used to simulate values of the study variable for all population units. Voorst actually is an infinite population of points. However, this study area is discretised by a fine grid, and the study variable, the soil organic matter concentration, is simulated for all nodes of this discretisation grid. Kandahar is a finite population consisting of 965 squares of size 5 km $\times$ 5 km. The study variable is the area cultivated with poppy. Eastern Amazonia is a map in raster format, with a resolution of 1 km $\times$ 1 km. The study variable is the aboveground biomass as derived from remotes sensing images. The aboveground biomass value of a raster cell is treated as the average biomass of that raster cell. 

The exhaustive data sets are used in the first part of this book on probability sampling for estimating population means and totals. By taking the population as the reality, we know the population mean and total. Also, for any randomly selected sample from this population, the study variable values for the selected sampling units are known, so that we can *estimate*  the population mean or total from this sample. The estimated mean (total) can then be compared with the population mean (total). The difference between these two is the *sampling error*\index{Sampling error} in the estimated mean (total). This opens up the possibility of repeating the selection of random samples with a given sampling design a large number of times, estimating the population mean (total) for every sample, so that a frequency distribution of the estimated population mean is obtained. Ideally, the mean of this frequency distribution, referred at as the *sampling distribution*\index{Sampling distribution}, is equal to the population mean (mean sampling error equals zero), and the variance of the estimated means is small. Another advantage is that sampling designs can be compared on the basis of the sampling distribution, for instance the sampling distributions of stratified random sampling and simple random sampling, to evaluate whether the stratification leads to more accurate estimates of the population mean.

Besides, various data sets are used with data for a sample of population units only. These data sets are described at places where they are first used.

### Soil organic matter in Voorst (Netherlands) {#Voorst}

The study area of Voorst is located in the eastern part of the Netherlands. The size of the study area is 6 km by 1 km. At 132 points samples of the topsoil were collected by graduate students of Wageningen University, which were analyzed in the laboratory on soil organic matter (SOM) concentrations (in g per kg). The map is created by conditional geostatistical simulation of natural logarithms of SOM on a 25 m by 25 m grid, followed by backtransformation, using a linear mixed model with spatially correlated residuals and combinations of soil type and land use as a qualitative predictor (factor). Figure \@ref(fig:mapVoorst) shows the simulated map of SOM. 

```{r mapVoorst, echo=FALSE,  out.width='100%', fig.cap="Simulated soil organic matter concentration (g/kg) in Voorst."}
load("data/Voorst.RData")
ggplot(data=grdVoorst) +
        geom_raster(mapping=aes(x=s1/1000, y=s2/1000, fill=z)) +
        scale_x_continuous(name="Easting  (km)") +
        scale_y_continuous(name="Northing  (km)") +
        scale_fill_viridis_c(name="SOM") +
        coord_fixed()
```

The histogram of the simulated values at all 7528 grid cells shows that SOM is skewed to the right (Figure \@ref(fig:histogramVoorst)).

```{r histogramVoorst, echo=FALSE, fig.asp=0.7, fig.cap="Histogram of simulated soil organic matter concentration (g/kg) in Voorst."}
ggplot(grdVoorst) +
  geom_histogram(aes(x=z), breaks=seq(from=0, to=50, by=2), fill="black", alpha=0.5, colour="black") +
  scale_y_continuous(name="Frequency") +
  scale_x_continuous(name="SOM (g/kg)")
```

Summary statistics are:

```{r, echo=FALSE}
summary(grdVoorst$z)
```

The ancillary information consist of a map of soil classes and a land use map, which are combined to five soil-land use combinations (Figure \@ref(fig:SoilLanduseCombinationsVoorst)). The first letter in the labels for the combinations stands for the soil type: B for beekeerdgrond (sandy wetland soil with gleyic properties), E for enkeerdgrond (sandy soil with thick anthropogenic humic topsoil), P for podzols (sandy soil with eluviated horizon below the topsoil), R for river clay soil,  and X for sandy soils. The second letter is for land use: A for agriculture (grassland, arable land), and F for forest.

```{r SoilLanduseCombinationsVoorst, echo=FALSE, out.width='100%', fig.cap="Soil-land use combinations in study area Voorst (Netherlands)."}
ggplot() +
  geom_raster(data=grdVoorst, mapping=aes(x=s1/1000, y=s2/1000, fill=stratum)) +
    scale_fill_manual(
      name="",
      values=c(BA="darkgreen", EA="brown", PA="orange", RA="green", XF="grey")
    ) +  
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

### Poppy fields in Kandahar (Afghanistan) {#Poppy}

Cultivation of poppy for opium production is a serious problem in Afghanistan. The United Nations Organization on Drugs and Crime (UNODC) monitors the area cultivated with poppy through detailed analysis of areal photographs and satellite images. This is laborious, and for that reason this analysis is restricted to a probability sample of 5 km by 5 km squares. These sample data are then used to estimate the total poppy area [@UNODC2014].

In 2014 the poppy area of 83 squares in the province of Kandahar (Afghanistan) was determined, as well as the agricultural area of all 965 squares in this province. These data were used to simulate a map of poppy area per 5 km by 5 km square. The map is simulated with an ordinary kriging model for the logit transform of the proportion of the agricultural area within a 5 km by 5 km square cultivated with poppy. For privacy reasons the field was simulated *unconditionally* on these sample data. Figure \@ref(fig:mapsKandahar) shows the map with the agricultural area in hectares per 5 km $\times$ 5 km square, and the simulated poppy area in hectares, per square. The histogram of the simulated poppy area per square shows very strong positive skew (Figure \@ref(fig:histogramPoppyarea)). For 375 squares the simulated poppy area was smaller than 1 ha. 

```{r mapsKandahar, echo=FALSE, fig.cap="Agricultural area and simulated area cultivated with opium poppy, in hectares per 5 km by 5 km squares in Kandahar (Afghanistan)."}
load("data/Kandahar.RData")

df <- grdKandahar %>%
  pivot_longer(cols=c("agri", "poppy"))
df$name <- factor(df$name, levels=c("poppy","agri"), ordered=TRUE)
ggplot(data=df) +
  geom_raster(mapping=aes(x=x, y=y, fill=value)) +
  scale_fill_viridis_c(name="Area (ha)") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed() +
  facet_wrap(~ name, ncol=1, nrow=2)
```

```{r histogramPoppyarea, echo=FALSE, fig.asp=0.7, fig.cap="Histogram of simulated poppy area (ha) per 5 km by 5 km square in Kandahar."}
ggplot(grdKandahar) +
  geom_histogram(aes(x=poppy), breaks=seq(from=0, to=2200, by=100), fill="black", alpha=0.5, colour="black") +
  scale_y_continuous(name="Frequency") +
  scale_x_continuous(name="Poppy area (ha)")
```

### Aboveground biomass in Eastern Amazonia

This data set consists of data on the aboveground live woody biomass (AGB) in megatons per ha [@Baccini2012]. A rectangular area of 1642 km by 928 km in Eastern Amazonia (Brazil) was selected from this data set, and aggregated to a map with a resolution of 1 km $\times$ 1 km. Besides, a stack of five ecologically relevant covariates of the same spatial extent was prepared, being MODIS long term mean of short-wave infrared radiation (SWIR2), Primary Production in kg C per m$^2$ (Terra_PP), average precipitation in driest month in mm (Prec_dm), Elevation in m, and Clay content in g per kg soil.  All covariates were either resampled using bilinear interpolation, or aggregated to conform with the grid of the above-ground biomass map. Figure \@ref(fig:mapsAmazonia) shows a map of AGB and SWIR2.

```{r mapsAmazonia, echo=FALSE, out.width='100%', fig.cap="Aboveground biomas in megatons per ha (AGB), and short-wave infrared radiation (SWIR2) of Eastern Amazonia (Brazil)."}
load("data/Amazonia_1km.RData")

plt1 <- ggplot(gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=AGB)) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  scale_fill_viridis_c(name="AGB") +
  coord_fixed()

plt2 <- ggplot(gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=SWIR2)) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  scale_fill_viridis_c(name="SWIR2") +
  coord_fixed()

grid.arrange(plt1, plt2, nrow=2)
```

Figure \@ref(fig:matrixscatter) shows a matrix of two-dimensional density plots of aboveground biomass and the five covariates, made with function `ggpairs` of **R** package **GGally** [@GGally]. The covariate with the strongest correlation with AGB is SWIR2. The Pearson correlation coefficient with AGB is -0.80. The relation does not look linear. The correlation of AGB with the covariates Terra_PP and Prec_dm is weakly positive. All correlations are significant, but this is not meaningful because of the very large number of data used in computing the correlation coefficients.

```{r matrixscatter, echo=FALSE, fig.asp= .66, out.width='100%', fig.cap="Matrix of two-dimensional density plots of aboveground biomass (AGB) and five covariates of Eastern Amazonia (Brazil)."}
library(GGally)
density2d <- function(data, mapping, ...) {
    ggplot(data=data, mapping=mapping) +
        geom_density2d_filled(...)
}
gridAmazonia %>% 
  dplyr::select(AGB, SWIR2, Terra_PP, Prec_dm, Elevation, Clay) %>%
  slice_sample(n=50000) %>%
  ggpairs(
    upper=list(continuous="cor"),
    lower=list(continuous=density2d)
  ) 
```


```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:01-GeneralIntroduction.Rmd-->

# (PART) Probability sampling for estimating (sub)population parameters {-}


# Introduction to probability sampling {#IntroProbabilitySampling}


To estimate population parameters like the mean or the total, *probability sampling* is most appropriate. Probability sampling is random sampling using a random number generator such that all population units have a probability larger than zero of being selected, and that these probabilities are known for at least the selected units.

The probability that a unit is included in the sample, in short the inclusion probability\index{Inclusion probability of a unit} of that unit, can be calculated as the sum of the selection probabilities over all samples that can be selected with a given sampling design and that contain this unit. In formula:

\begin{equation}
\pi_k = \sum_{\mathcal{S} \ni k} p(\mathcal{S}) \;,
(\#eq:InclusionProbability)
\end{equation}

where $\mathcal{S} \ni k$ indicates that the sum is over all samples that contain unit $k$, and $p(\mathcal{S})$ is the selection probability\index{Selection probability of a sample} of sample $\mathcal{S}$. $p(\cdot)$ is called the *sampling design*\index{Sampling design}. It is a function that assigns a probability to every possible sample (subset of population units) that can be selected with a given  sample selection scheme\index{Sample selection scheme} (sampling algorithm\index{Sampling algorithm}). For instance, consider the following sample selection scheme from a finite population of $N$ units:  

1. Select with equal probability $1/N$ a first unit.  
2. Select with equal probability $1/(N-1)$ a second unit from the remaining $N-1$ units.  
3. Repeat this until an $n$th unit is selected  with equal probability from the $N-(n-1)$ units.  

This is a selection scheme for simple random sampling without replacement. With this scheme the selection probability of any sample of $n$ units is $1/\binom{N}{n}$, and zero for all other samples. There are $\binom{N-1}{n-1}$ samples of size $n$. The inclusion probability of each unit $k$ therefore is $\binom{N-1}{n-1}/\binom{N}{n}=\frac{n}{N}$. The sampling design plays a key role in the design-based approach as it determines the sampling distribution of random quantities computed from a sample such as the estimator of the population mean, see Section \@ref(HTestimator). The number of selected population units is referred to as the *sample size*\index{Sample size}^[In sampling with replacement the number of unique populations units in the sample can be smaller than the sample size.].

A common misunderstanding is that with probability sampling the inclusion probabilities must be equal. Sampling with unequal inclusion probabilities can be more efficient than with equal probabilities. Unequal probability  sampling is no problem as long as these inclusion probabilities are known and proper formulas are used for estimation, see Section \@ref(HTestimator).

There are many schemes for selecting a probability sample. The following sampling designs are described and illustrated in this book:   
1. Simple random sampling.  
2. Stratified random sampling.  
3. Systematic random sampling.   
4. Cluster random sampling.  
5. Two-stage cluster random sampling.  
6. Sampling with probabilities proportional to size.  
7. Balanced and well-spread sampling.  
8. Two-phase random sampling.  

The first five sampling designs are basic sampling designs. Implementation of these designs is rather straightforward^[Although a proper implementation of cluster random sampling can be quite difficult, see Chapter \@ref(Cl).], as well as the associated estimation of the population mean, total or proportion, and their sampling variance. The final three sampling designs are more advanced, and require more knowledge of sampling theory and statistics, such as linear regression.

#### Exercises {-}
1. Suppose a researcher selects a sample of points from a study area by throwing darts on a map depicting the study area. Is the resulting sample a probability sample? If not, why not?  
2. Suppose we have a population of $N$ units, numbered $1 \dots N$. Can you think of a simple but proper way of selecting a probability sample of $n$ units? What is the inclusion probability of any given unit?  

## Horvitz-Thompson estimator {#HTestimator}
For any probability sampling design the population total can be estimated as a weighted sum of the observations (measurements) of the study variable on the selected population units:

\begin{equation}
\hat{t}_{\pi}(z)=\sum_{k \in \mathcal{S} } w_k z_k \;,
(\#eq:HTTotal)
\end{equation}

with $\mathcal{S}$ the sample, $z_k$ the observed study variable for unit $k$, and $w_k$ the design weight\index{Design weight} attached to unit $k$:

\begin{equation}
w_k = \frac{1}{\pi_k}\;,
(\#eq:designweight)
\end{equation}

with $\pi_k$ the inclusion probability of unit $k$. The estimator\index{Estimator}^[An *estimator* is not the same as an *estimate*. An estimate is a single value calculated from the data of a selected sample, whereas an estimator is a *random variable* that is a function of the sample data, and has a probability distribution.] of Equation \@ref(eq:HTTotal) is referred to as the Horvitz-Thompson estimator\index{Horvitz-Thompson estimator|see $\pi$ estimator} or $\pi$ estimator\index{$\pi$ estimator}. The $z_k/\pi_k$ values are referred to as the  $\pi$-expanded values\index{$\pi$-expanded value}. The $z$ value of unit $k$ in the sample is multiplied by the reciprocal of the inclusion probability of that unit, and the sample sum of these $\pi$-expanded values is used as an estimator of the population total\index{Population total}. The inclusion probabilities are determined by the type of sampling design and the sample size.

For infinite populations\index{Population!infinite population}, think of points in a continuous population, the same estimator for the population total can be used, but special attention must then be paid to the inclusion probabilities. Suppose the infinite population is discretised by a fine grid of $N$ nodes, and a simple random sample of $n$ nodes is selected. The inclusion probabilities of the grid nodes is then $n/N$. However, constraining the sampling points to the nodes of the discretisation grid is not needed, and even undesirable. To account for the infinite number of points in the population we may adopt a two-step approach, see Figure \@ref(fig:SamplingFromInfinitePopulation). In the first step $n$ grid nodes are selected by simple random sampling *with replacement*. In the second step one point is selected fully randomly from the grid cells with the grid nodes selected in the first step at their centers. If a grid cell is selected more than once, more points are selected in that grid cell. With this selection procedure the inclusion probability density\index{Inclusion probability density} is $n/A$, with $A$ the area of the study area. This inclusion probability density equals the expected number of sampling points per unit area, e.g. the expected number of points per ha or per m$^2$. The inclusion probability density can be interpreted as the sampling intensity\index{Sampling intensity}^[The integral of the inclusion probability density over the study area equals the (expected) sample size $n$, not one, and for that reason, to avoid confusion with a probability density, I prefer the term sampling intensity.].


The $\pi$ estimator for the *mean* of a finite population\index{Population!finite population}\index{Population mean}, $\bar{z}$, is simply the $\pi$ estimator for the total, divided by the total number of units in the population, $N$:

\begin{equation}
\hat{\bar{z}}_{\pi}=\frac{1}{N} \sum_{k \in \mathcal{S}} \frac{1}{\pi_k}z_k \;.
(\#eq:HTMean)
\end{equation}

For infinite populations discretised by a finite set of points the same estimator can be used.

For infinite populations the population total can be estimated by multiplying the estimated population mean by the area of the population $A$:

\begin{equation}
\hat{t}_{\pi}(z)=A \hat{\bar{z}}_{\pi} \;.
(\#eq:HTTotalinfinite)
\end{equation}

The $\pi$ estimator can be worked out for the different types of sampling design listed above, by inserting the inclusion probabilities as determined by the sampling design. For simple random sampling this leads to the unweighted sample mean (see Chapter \@ref(SI)), and for stratified simple random sampling the $\pi$ estimator is equal to the weighted sum of the sample means per stratum, with weights equal to the relative size of the strata (see Chapter \@ref(STSI)).

## Hansen-Hurwitz estimator

In sampling finite populations, units can be selected with or without replacement. In sampling with replacement after each draw the selected unit is replaced. As a consequence a unit can be selected more than once. Sampling with replacement is less efficient than sampling without replacement\index{Sampling without replacement}. If a population unit is selected in a given draw, there is no additional information in this unit if it is selected again. One reason that sampling with replacement\index{Sampling with replacement} is still used is that it is more easy to implement.

The most common estimator used for sampling with replacement is the Hansen-Hurwitz estimator\index{Hansen-Hurwitz estimator|see pwr estimator}, referred to as the pwr estimator\index{pwr estimator} by @sar92. With direct unit sampling, i.e. sampling of individual population units, the pwr estimator is

\begin{equation}
\hat{t}_{\text{pwr}}(z)=\frac{1}{n}\sum_{k \in \mathcal{S} } \frac{z_k}{p_k} \;,
(\#eq:pwrTotal)
\end{equation}

with $p_k$ the *draw-by-draw selection probability*\index{Draw-by-draw selection probability!of a population unit} of population unit $k$. The acronym pwr stands for $p$-expanded with replacement. In the pwr estimator the observations on the selected units are expanded by the draw-by-draw selection probability. For instance, in simple random sampling with replacement the draw-by-draw selection probability $p$ of each unit is $1/N$. If we select only one unit $k$, the population total can be estimated by the observation on that unit divided by $p$, $\hat{t}(z) = z_k/p_k = N z_k$. If we repeat this $n$ times, this results in $n$ estimated population totals. The pwr estimator is the average of these $n$ elementary estimates. If a unit occurs multiple times in the sample $\mathcal{S}$, this unit provides multiple elementary estimates of the population total.

A sample obtained by sampling with replacement is referred to as an *ordered sample*\index{Ordered sample} [@sar92]. Selecting the distinct units from this ordered sample results in the *set-sample*\index{Set-sample}. Instead of using the ordered sample in the pwr estimator, we may use the set-sample in the $\pi$ estimator. This requires computation of the inclusion probabilities for with replacement sampling. For instance, for simple random sampling with replacement the inclusion probability of each unit equals $1-\left(1-\frac{1}{N}\right)^n$, with $n$ the number of draws. This probability is smaller than $n/N$, the inclusion probability for simple random sampling without replacement. There is no general rule which estimator is most accurate [@sar92]. In this book I only use the pwr estimator for sampling with replacement.

Sampling with replacement can also be applied at the level of clusters of population units as in cluster random sampling and two-stage cluster random sampling. If the clusters are selected with probabilities proportional to their size and with replacement, estimation of the population mean, proportion or total is rather simple. This is a second reason why sampling with replacement can be attractive. With cluster sampling the pwr estimator is

\begin{equation}
\hat{t}_{\text{pwr}}(z)=\frac{1}{n}\sum_{j \in \mathcal{S} } \frac{t_j(z)}{p_j} \;,
(\#eq:pwrTotalcluster)
\end{equation}

with $t_j(z)$ the total of the cluster selected in the $j$th draw. If not all population units of a selected cluster are observed, but a sample of population units from a cluster only as in two-stage cluster random sampling, the cluster totals $t_j(z)$ are replaced by the estimated cluster totals $\hat{t}_j(z)$. 

## Using models in design-based approach

Design-based estimates of population parameters such as the population  mean, population total or population proportion (areal fraction) are model-free: no use is made of a model for the spatial variation of the study variable. However, such a model can be used to optimise the probability sampling design.  In Chapter \@ref(MBpredictionofDesignVariance) I describe how a model can be used to compare alternative sampling designs at equal costs or equal precision to evaluate which sampling design performs best, to optimise the sample size(s) given a requirement on the precision of the estimated population parameter, or to optimize the spatial strata for stratified random sampling.

A model of the spatial variation can also be used at a later stage, after the data are collected, in estimating the population parameter of interest. If one or more ancillary variables that are related to the study variable are available, these variables can be used in estimation to increase the accuracy. This leads to alternative estimators, such as the simple and multiple regression estimator, ratio estimator and poststratified estimator (Chapter \@ref(Modelassisted)). These estimators together are referred to as model-assisted estimators\index{Model-assisted approach}. In model-assisted estimation  the inclusion probabilities as determined by the random sampling design, play a key role, but besides, modelling assumptions about how the population might have been generated are used to work out an efficient estimator. The role of the model in the model-assisted approach is fundamentally different from its role in the model-based approach. This is explained in Chapter \@ref(Approaches).

For novices in geostatistics Chapters \@ref(Modelassisted) and \@ref(MBpredictionofDesignVariance) can be quite challenging, and I recommend to skip these Chapters first, to return to them after reading the introductory Chapter on geostatistics (Chapter \@ref(Introkriging)).

```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:02-IntroProbabilitySampling.Rmd-->

# Simple random sampling {#SI}

Simple random sampling\index{Simple random sampling} is the most basic form of probability sampling. There are two subtypes: 

1. Simple random sampling with replacement (SIR).  
2. Simple random sampling without replacement (SI).

This distinction is irrelevant for infinite populations. In with replacement sampling a population unit may be selected more than once. 

In **R** a simple random sample can be selected with or without replacement by the function `sample.int` from the `base` package. For instance, a simple random sample without replacement of 10 units from a population of 100 units labeled as 1,2, ... ,100, can be selected by

```{r}
sample.int(100, size=10, replace=FALSE)
```

The number of units in the sample is referred to as the sample size ($n=10$ in the code chunk above). Use argument `replace = TRUE` to select a simple random sample with replacement.

When the spatial population is continuous and  infinite, as in sampling points from an area, the infinite population is discretised by a very fine grid. Discretisation is not strictly needed (we could also sample points directly), but it is used in this book for reasons explained in Chapter \@ref(GeneralIntro). The nodes of this grid are then listed in a data frame, which serves as the sampling frame (Chapter \@ref(GeneralIntro)). In the next code chunk a simple random sample without replacement of size 40 is selected from Voorst. The infinite population is represented by the nodes of a square grid with a spacing of 25 m. These nodes are listed in the ` data.frame` `grdVoorst`.

```{r}
load("data/Voorst.RData")
n <- 40
N <- nrow(grdVoorst)
set.seed(314)
units <- sample.int(N, size=n, replace=FALSE)
mysample <- grdVoorst[units,]
head(mysample)
```

The result of the function `sample.int` is a vector with the selected nodes of the discretisation grid. The order of the elements of the vector is the order in which these are selected. Restricting the sampling points to the nodes of a discretisation grid can be avoided as follows. The columns `s1` and `s2` in the `data.frame grdVoorst` are the spatial coordinates of the centers of grid cells of 25 m by 25 m. Now a simple random sample is selected in two stages. First *n* times a grid cell is selected by simple random sampling *with replacement*. Second, every time a grid cell is selected, one point is selected fully randomly within this grid cell. This selection procedure accounts for the infinite number of points in the population. In the code chunk below the second step of this selection procedure is implemented with function `jitter`. It adds random noise to the spatial coordinates of the centers of the selected grid cells, by drawing from a continuous uniform distribution $unif(-c,c)$, with $c$ half the side length of the square grid cells. With this selection procedure we respect that the population actually is infinite.  

```{r}
set.seed(314)
units <- sample.int(N, size=n, replace=TRUE)
mysample <- grdVoorst[units,]
cellsize <- 25
mysample$s1 <- jitter(mysample$s1, amount=cellsize/2)
mysample$s2 <- jitter(mysample$s2, amount=cellsize/2)
head(mysample)
```

The variable `stratum` is not used in this chapter. The result is shown in Figure \@ref(fig:SampleSI). Note that before using the function `sample.int` I set a seed for the random number generator. This is to be able to reproduce the result: every time the same seed is used, the same sample of units is selected. Without setting a seed, we do not control the seed (R will choose one), and different samples will be selected.

```{r SampleSI, echo=FALSE, out.width='100%', fig.cap="Simple random sample of size 40 from Voorst."}
library(ggplot2)
ggplot() +
  geom_raster(data=grdVoorst, mapping=aes(x=s1/1000, y=s2/1000), fill="grey")+
  geom_point(data=mysample, mapping=aes(x=s1/1000,y=s2/1000), size=2) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()+
  theme(legend.position="none")
```

#### Drop outs {-}

What to do with selected units that do not belong to the target population, or cannot be observed for whatever reason (e.g. no permission)\index{Drop outs}? In practice it may happen that inspection in the field shows that a selected sampling unit does not belong to the target population. For instance, in a soil survey the sampling unit may happen to fall on a road or in a built-up area. Shifting this unit to a nearby unit may lead to a biased estimator of the population mean, i.e. a systematic error\index{Systematic error} in the estimated population mean. Besides, knowledge of the inclusion probabilities is lost. This can be avoided by discarding these units and to replace them by sampling units from a back-up list\index{Back-up list of sampling units}, selected in the same way, i.e. by the same type of sampling design. The order of sampling units in this list must be the order in which they are selected. In summary, do not replace a deleted sampling unit by the nearest sampling unit from the back-up list, but by the first unit, not yet selected, from the back-up list.

#### Arbitrary (haphazard) sampling versus probability sampling {-}

In publications it is commonly stated that the sampling units were selected (more or less) at random (within strata), without further specification of how the sampling units were precisely selected. In statistical inference, the sampling units are subsequently treated as if they were selected by (stratified) simple random sampling. With probability sampling all units in the population have a positive probability of being selected, and the inclusion probabilities are known for all units. It is highly questionable whether this also holds for arbitrary\index{Arbitrary sampling} and haphazard sampling\index{Haphazard sampling}. In arbitrary and haphazard sampling the sampling units are not selected by a probability mechanism. So the selection probabilities of the sampling units and of combinations of sampling units are unknown. This makes design-based estimation impossible, as this is based on the inclusion probabilities as determined by the sampling design. The only option for statistical analysis using arbitrarily or haphazardly selected samples is model-based inference, i.e. a model of the spatial variation must be assumed.

## Estimation of population parameters {#HTestimatorSI}

In simple random sampling without replacement of a finite population every possible sample of $n$ units has an equal probability of being selected. There are $\binom{N}{n}$ samples of size $n$, and $\binom{N-1}{n-1}$ samples that contain unit $k$. From this it follows that the probability that unit $k$ is included in the sample is $\binom{N-1}{n-1}/\binom{N}{n}=\frac{n}{N}$ [@loh99]. Substituting this in the general $\pi$-estimator for the total (Equation \@ref(eq:HTTotal)) gives for simple random sampling without replacement (from finite populations)

\begin{equation}
\hat{t}(z)=\frac{N}{n}\sum_{k \in \mathcal{S}} z_k = N \bar{z}_{\mathcal{S}} \;,
(\#eq:HTTotalSI)
\end{equation}

with $\bar{z}_{\mathcal{S}}$ the (unweighted) *sample mean*\index{Sample mean}. So for simple random sampling without replacement the $\pi$ estimator of the population mean is the *unweighted* sample mean:

\begin{equation}
\hat{\bar{z}} = \bar{z}_{\mathcal{S}} = \frac{1}{n}\sum_{k \in \mathcal{S}} z_k \;.
(\#eq:HTMeanSI)
\end{equation}

In simple random sampling with replacement of finite populations a unit may occur multiple times in the sample $\mathcal{S}$. In this case the population total can be estimated by the pwr estimator [@sar92]

\begin{equation}
\hat{t}(z)= \frac{1}{n} \sum_{k \in \mathcal{S}} \frac{z_{k}}{p_{k}} \;,
(\#eq:HHTotal)
\end{equation}

where $n$ is the number of draws, and $p_{k}$ is the draw-by-draw selection probability of unit $k$. With simple random sampling $p_{k}=1/N, k=1, \dots , N$. Inserting this in the pwr estimator yields

\begin{equation}
\hat{t}(z)= \frac{N}{d} \sum_{k \in \mathcal{S}} z_{k} \;.
(\#eq:HHTotalSIR)
\end{equation}

Alternatively, the population total can be estimated by the $\pi$ estimator. With simple random sampling with replacement the inclusion probability of each unit $k$ equals $1-\left(1-\frac{1}{N}\right)^n$, which is smaller than  the inclusion probability with simple random sampling without replacement of size $n$ [@sar92]. Inserting these inclusion probabilities in the general $\pi$ estimator of the population total (Equation \@ref(eq:HTTotal)) where the sample $\mathcal{S}$ is reduced to the unique units in the sample, yields the $\pi$ estimator of the total for simple random sampling with replacement. 

With simple random sampling of *infinite* populations the $\pi$ estimator of the population mean equals the sample mean. Multiplying this estimator with the area of the region of interest $A$ yields the $\pi$ estimator of the population total:

\begin{equation}
\hat{t}(z)= \frac{A}{n}\sum_{k \in \mathcal{S}}z_{k} \;.
(\#eq:HTTotalSIInfinite)
\end{equation}

The simple random sample of size 40 selected above is used to estimate the population total of SOM. First the population mean is estimated.

```{r}
mz <- mean(mysample$z)
```

The estimated population mean is `r round(mz,2)`. Simply multiplying the estimated population mean by the area $A$ to obtain an estimate of the population total is not very useful, as the dimension of the total then is g kg$^{-1}$ m$^2$. To estimate the total of SOM in the soil layer 0-30 cm, first the soil volume in m$^3$ is computed by the total number of grid cells, $N$, multiplied by the size of the grid cells and by the thickness of the soil layer. The total is then estimated by the product of this volume, the bulk density of soil in g cm$^{-3}$ and the estimated population mean. This is divided by $10^6$ to obtain the total SOM in megatons ($10^{9}$ kg).

```{r}
Vol <- N*25^2*0.3
bd <- 1.5
tz <- Vol*bd*mz*10^-6
```

The estimated total is `r round(tz,1)` megaton. Note that that a constant bulk density is used. Ideally, this bulk density is also measured at the sampling points, by collecting soil aliquots of a constant volume. The measured SOM concentration and bulk density can then be used to compute the volumetric SOM content in kg m$^{-3}$ at the sampling points. The estimated population mean of this volumetric SOM content can then be multiplied by the total volume of soil in the study area, to get an estimate of the total mass of SOM in the study area.   

The simulated population is now sampled 10,000 times to see how sampling affects the estimates. For each sample the population mean is estimated by the sample mean. Figure \@ref(fig:SamplingDistributionSI) shows a histogram of the 10,000 estimated population means (sample means).

```{r SamplingDistributionSI, echo=FALSE, fig.asp=0.8, fig.cap="Sampling distribution of the estimator of the population mean of SOM (g/kg) in Voorst with simple random sampling of size 40."}
n <- 40
number_of_samples <- 10000

mz <- v_mz <- numeric(length=number_of_samples)
N <- nrow(grdVoorst)

set.seed(314)

for (i in 1:number_of_samples) {
  units <- sample.int(N, size=n, replace=TRUE)
  mz[i] <- mean(grdVoorst$z[units])
  v_mz[i] <- var(grdVoorst$z[units])/n
}

ggplot() +
  geom_histogram(aes(x=mz), binwidth=0.2, fill="black", alpha=0.5, colour="black") +
  scale_y_continuous(name="Frequency") +
  scale_x_continuous(name="Estimated mean SOM")
```

If we would repeat the sampling an infinite number of times and make the width of the bins in the histogram infinitely small, then we obtain, after scaling so that the sum of the area under the curve equals 1, the *sampling distribution*\index{Sampling distribution} of the estimator of the population mean. Important summary statistics of this sampling distribution are:  

1. Expectation (mean).  
2. Variance, referred to as the *sampling* variance.

When the expectation\index{Expectation of estimator} equals the population mean, there is no systematic error. The estimator is then said to be *design-unbiased*\index{Design-unbiased} or *p-unbiased*\index{p-unbiased}. In Chapter \@ref(Introkriging) another type of unbiasedness is introduced, model-unbiasedness. The difference between design-unbiasedness and model-unbiasedness is explained in Chapter \@ref(Approaches). In following chapters of Part I unbiased means design-unbiased. Actually, it is not the estimator which is unbiased, but the combination of a sampling design and an estimator. For instance, with unequal probability sampling designs, the sample mean is not an unbiased estimator of the population mean, whereas it is in combination with an equal probability sampling design.

The sampling variance\index{Sampling variance} is a measure of the random error\index{Random error}. Ideally this variance is as small as possible, so that there is a large probability that for an individual estimate the estimation error is small. The variance is a measure of the *precision*\index{Precision} of an estimator. An estimator with a small variance but a strong bias is not a good estimator. To assess the quality of estimator we should look at both. The variance and the bias are often combined in the *mean squared error*\index{Mean squared error} (MSE), which is the sum of the variance and the *squared* bias. An estimator with a small MSE is an *accurate* estimator. So contrary to precision, accuracy\index{Accuracy} also accounts for the bias\index{Bias}.

Do not confuse the *population* variance and the *sampling* variance. The population variance\index{Population variance} (spatial variance) is a *population characteristic*, whereas the sampling variance is a *characteristic of a sampling strategy*, index{Sampling strategy} i.e. a combination of a sampling design and an estimator. The sampling variance quantifies our *uncertainty* about the population mean. The sampling variance can be manipulated by changing the sample size $n$, the type of sampling design, and the estimator. This has no effect on the population variance. The average of the 10,000 estimated population means equals `r round(mean(mz),2)`, so the difference with the true population means equals `r round(mean(mz)-mean(grdVoorst$z),3)`. The variance of the 10,000 estimated population means equals `r round(var(mz),2)`. The square root of this variance, referred to as the *standard error*\index{Standard error},  equals `r round(sqrt(var(mz)),2)`. Note that the standard error has the same dimension as the study variable, g/kg, whereas the dimension of the variance is the squared dimension of the study variable. 

### Population proportion {#PopProportion}

In some cases one is interested in the proportion of the population (study area) satisfying a given condition. Think for instance of the proportion of trees in a forest infected by some disease, the proportion of an area (areal fraction) in which a soil pollutant exceeds some critical threshold, or the proportion of an area where habitat conditions are suitable for some endangered species. Recall that a population proportion\index{Population proportion} is defined as the population mean of an 0/1 indicator $y$ with value 1 if the condition is satisfied, and 0 otherwise (Section \ref(PopulationParameters)). For simple random sampling this population proportion can be estimated by the same formula as for the mean (Equation \@ref(eq:HTMeanSI)):

\begin{equation}
\hat{p} =  \frac{1}{n}\sum_{k \in \mathcal{S}} y_k \;.
(\#eq:HTProportionSI)
\end{equation}

### Cumulative distribution function and quantiles {#CDF}

The population CDF is defined in Equation \@ref(eq:CDF). A population CDF can be estimated by repeated application of the indicator technique described in the previous section on estimating a population proportion. A series of threshold values is chosen. Each threshold results in $n$ indicator values having value 1 if the observed study variable $z$ of unit $k$ is smaller than or equal to the threshold, and 0 otherwise. These indicator values are then used to estimate the proportion of the population with a $z$ value smaller than or equal to that threshold. For simple random sampling these proportions can be estimated with Equation \@ref(eq:HTProportionSI). Commonly the unique $z$ values in the sample are used as threshold values, leading to as many estimated population proportions as there are unique values in the sample.

Figure \@ref(fig:CDFSIVoorst) shows the estimated CDF, estimated from the simple random sample of 40 units from Voorst. The steps are at the unique values of SOM in the sample.

```{r CDFSIVoorst, fig.asp=0.7, fig.cap="Cumulative distribution function, estimated from the simple random sample of 40 units from Voorst."}
ggplot(mysample, mapping=aes(z)) +
  stat_ecdf(geom="step")
```

The estimated population proportions can be used to estimate a population quantile\index{Population quantile} for any population proportion  (cumulative frequency, probability), for instance the median, first quartile\index{Quartile} and third quartile, corresponding with a population proportion of 0.5, 0.25 and 0.75, respectively. A simple estimator is the smallest $k$th order statistic\index{\emph{k}th order statistic} with an estimated proportion larger than or equal to the desired cumulative frequency [@Hyndman1996].

The estimated CDF shows jumps of size $1/n$, so that the estimated population proportion  can be larger than the desired proportion. The estimated population proportions therefore are often interpolated, for instance by linear interpolation. Function `quantile` of the **stats** package can be used to estimate a quantile. With argument `type=4` linear interpolation is used to estimate the quantiles. Note that this function `quantile` actually computed *sample quantiles*\index{Sample quantile}, i.e. it assumes that the population units are selected with equal inclusion probabilities (as in simple random sampling), so that the estimators of the population proportions obtained with Equation \@ref(eq:HTProportionSI) are unbiased. With unequal inclusion probabilities these probabilities must be accounted for in estimating the population proportions, see following chapters. 

```{r}
quantile(mysample$z, probs=c(0.25,0.5,0.75), type=4) %>% 
  round(.,3)
```

Package **QuantileNPCI** [@QuantileNPCI] can be used to compute a non-parametric confidence interval estimate of a quantile, using fractional order statistics [@Hutson1999]. Parameter `q` specifies the proportion.

```{r}
library(QuantileNPCI)
res <- quantCI(mysample$z, q=0.5, alpha=0.05, method="exact")
```

The estimated median equals `r round(res$qx,3)`, the lower bound of the 95% confidence interval equals `r round(res$lower.ci,3)`, and the upper bound `r round(res$upper.ci,3)`.

#### Exercises {-}

1. Compare the histogram of the estimated population means with the histogram of the `r nrow(grdVoorst)` simulated values in the population (Figure \@ref(fig:histogramVoorst)). Explain the differences.  
2. What happens with the spread in the histogram (variance of estimated population means) when the sample size $n$ is increased?  
3. Suppose we would repeat the sampling $10^{12}$ number of times, what would happen with the difference between the average of the estimated population means and the population mean?

## Sampling variance of estimator of population mean, total and proportion {#VarMeanSI}

For simple random sampling of an infinite population and simple random sampling with replacement of a finite population the sampling variance of the estimator of the population mean equals

\begin{equation}
V\!\left(\hat{\bar{z}}\right)=\frac{S^{2}(z)}{n} \;,
(\#eq:VarMean)
\end{equation}

with $S^{2}(z)$ the *population* variance\index{Population variance}, also referred to as the spatial variance\index{Spatial variance}. For finite populations this population variance is defined as [@loh99]

\begin{equation}
S^{2}(z)=\frac{1}{N-1}\sum\limits_{k=1}^N\left(z_{k}-\bar{z}\right)^{2} \;,
(\#eq:PopulationVariance)
\end{equation}

and for infinite populations as

\begin{equation}
S^{2}(z) = \frac{1}{A} \int \limits_{\mathbf{s} \in \mathcal{U}} \left(z(\mathbf{s})-\bar{z}\right)^2\text{d}\mathbf{s} \;,
(\#eq:PopulationVarianceInfinite)
\end{equation}

with $z(\mathbf{s})$ the value of the study variable $z$ at a point with two-dimensional coordinates $\mathbf{s}=(s_1,s_2)$, $A$ the area of the study area, and $\mathcal{U}$ the universe of interest (study area). In practice we select only one sample, i.e. we do not repeat the sampling many times. Still it is possible to *estimate* the variance of the estimator of the population means if we would repeat the sampling. In other words, we can estimate the sampling variance of the estimator of the population mean from a single sample. We do so by estimating the population variance from the sample, and this estimate can then be used to estimate the *sampling* variance of the estimator of the population mean. For simple random sampling *with replacement* from finite populations the sampling variance of the estimator of the population mean can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}\right)=\frac{\widehat{S^2}(z)}{n}= \frac{1}{n\,(n-1)}\sum\limits_{k \in \mathcal{S}}\left(z_{k}-\bar{z}_{\mathcal{S}}\right)^{2} \;,
(\#eq:EstVarMeanSIR)
\end{equation}

with $\widehat{S^2}(z)$ the *estimated* population variance. With simple random sampling the *sample* variance\index{Sample variance}, i.e. the variance of the sample data, is an unbiased estimator of the population variance. This estimator can also be used for *infinite* populations. For simple random sampling *without replacement* from finite populations the sampling variance of the estimator of the population mean can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}\right)=\left(1-\frac{n}{N}\right)\frac{\widehat{S^2}(z)}{n} \;.
(\#eq:EstVarMeanSI)
\end{equation}

The term $1-\frac{n}{N}$ is referred to as the finite population correction\index{Finite population correction} (fpc).

In the sampling experiment\index{Sampling experiment} described above, the average of the 10,000 *estimated* sampling variances equals `r round(mean(v_mz),3)`. The true sampling variance equals `r round( (1-n/N) * var(grdVoorst$z)/n,3)`. So the difference is very small, indicating that the estimator of the sampling variance, Equation \@ref(eq:EstVarMeanSI), is design-unbiased.

The sampling variance of an estimated total of a finite population can be estimated by multiplying the estimated variance of the estimator of the population mean by $N^2$. For simple random sampling without replacement this estimator thus equals

\begin{equation}
\widehat{V}\!\left(\hat{t}(z)\right)=N^2 \left(1-\frac{n}{N}\right)\frac{\widehat{S^{2}}(z)}{n} \;.
(\#eq:EstVarTotalSI)
\end{equation}

For simple random sampling of infinite populations the sampling variance of the estimator of the total can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{t}(z)\right)=A^2\frac{\widehat{S^{2}}(z)}{n} \;.
(\#eq:EstVarTotalSIR)
\end{equation}

The sampling variance of an estimated proportion $\hat{p}$ for simple random sampling without replacement of a finite population can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{p}\right)=\left( 1-\frac{n}{N}\right) \frac{\hat{p}(1-\hat{p})}{n-1} \;.
(\#eq:EstVarProportionSI)
\end{equation}

The numerator in this estimator is an estimate of the population variance of the indicator. Note that this estimated population variance is divided by $n-1$, and not by $n$ as in the estimator of the mean [@loh99].

Estimation of the standard error of the estimated population mean in **R** is very straightforward. To estimate the standard error of the estimated total in megatons the standard error of the estimated population mean must be multiplied by a constant. 

```{r}
se_mz <- sqrt(var(mysample$z)/n)
se_tz <- se_mz*Vol*bd*10^-6
```

The estimated standard error of the estimated total equals `r round(se_tz,3)`. This standard error does not account for spatial variation of bulk density.

Although there is no advantage in using package **survey** [@Lumley2020] to compute the $\pi$ estimator and its standard error for this simple sampling design, I illustrate how this works. For more complex designs and alternative estimators, estimation of the population mean and its standard error with functions defined in this package is very convenient, as will be shown in the following chapters.

First the sampling design that is used to select the sampling units is specified with function `svydesign`. The first argument specifies the sampling units. In this case the nodes of discretisation grid are used as sampling units, which is indicated by the formula `id=~1`. In Chapter \@ref(Cl) clusters of population units are used as sampling units, and in Chapter \@ref(Twostage) both clusters and individual units are used as sampling units. The argument `probs` specifies the inclusion probabilities of the sampling units. Alternatively, we may specify the weights with argument `weights`, which are in this case equal to the inverse of the inclusion probabilities. The variable `pi` is a column in the data frame `mysample`, which is indicated with the tilde in `probs=~pi`.

The population mean is then estimated with function `svymean`. The first argument is a formula specifying the study variable. The argument `design` specifies the sampling design. 

```{r}
library(survey)
mysample$pi <- n/N
design_si <- svydesign(id=~1, probs=~pi, data=mysample)
svymean(~z, design=design_si)
```

For simple random sampling of finite populations without replacement, argument `fpc` is used to correct the standard error.

```{r}
mysample$N <- N
design_si <- svydesign(id=~1, probs=~pi, fpc=~N, data=mysample)
svymean(~z, design_si)
```

The estimated standard error is smaller now due to the finite population correction, see Equation \@ref(eq:EstVarMeanSI).

Population totals can be estimated with function `svytotal`, quantiles with function `svyquantile`, and ratios of population totals with `svyratio`, to mention a few functions that will be used in following chapters.

```{r}
svyquantile(~z, design_si, quantile=c(0.5,0.9))
```

#### Exercises {-}

4. Is the sampling variance for simple random sampling without replacement larger or smaller than for simple random sampling with replacement, given the sample size $n$? Explain your answer.  
5. What is the effect of the population size $N$ on this difference?  
6. In Section \@ref(VarMeanSI) I computed the true sampling variance, i.e. the variance of the estimator of the population means if we would repeat the sampling an infinite number of times. How can this true sampling variance be computed?  
7. In reality we cannot compute the true sampling variance. Why not?  

## Simple random sampling of circular plots {#SIcircularplots}

In forest inventory, vegetation surveys and agricultural surveys circular sampling plots\index{Circular sampling plot} are quite common. Using circular plots as sampling units is not entirely straightforward because the study area cannot be partitioned into a finite number of circles that fully cover the study area. The use of circular plots as sampling units can be implemented in two ways [@DeVries1986]:  

1. Sampling from a finite set of fixed circles.  
2. Sampling from an infinite set of floating circles.  

### Sampling from a finite set of fixed circles

Sampling from a finite set of fixed circles is most simple, but as we will see requires an assumption about the distribution of the study variable in the population.  In this implementation the sampling units consist of a finite set of slightly overlapping or non-overlapping fixed circular plots (Figure \@ref(fig:circularplotswithinsquares)). The circles can be constructed as follows. A grid with squares is superimposed on the study area, so that it fully covers the study area. These squares are then substituted by circles with an area equal to the area of the squares, or by non-overlapping tangent circles inscribed in the squares. The radius of the partly overlapping circles equals $\sqrt{a/\pi}$, with $a$ the area of the squares,  the radius of the non-overlapping circles equals $\sqrt{a}/2$. In both implementations the infinite population is replaced by a finite population of circles that does not fully tessellate the study area. When using the partly overlapping circles as sampling units we may avoid overlap by selecting a systematic sample (Chapter \@ref(SY)) of circular plots. The population total can then be estimated by Equation \@ref(eq:EstVarTotalSI), substituting $A/a$ for $N$, and where $z_k$  is the total of the $k$th circle (sum of observations of all population units in $k$th circle). However, no unbiased estimator of the sampling variance of the estimator of the population total or mean is available for this sampling design, see Chapter \@ref(SY). 

With simple random sampling of  non-overlapping circular plots the finite population total can be estimated by Equation \@ref(eq:HTTotalSI), and its sampling variance by Equation \@ref(eq:EstVarTotalSI). However, the circular plots do not cover the full study area, and as a consequence the total of the infinite population is underestimated. A corrected estimate can be obtained by estimating the mean of the finite population and multiplying this estimated population mean by $A/a$ [@DeVries1986]:

\begin{equation}
\hat{t}(z)= \frac{A}{a} \hat{\bar{z}}\;,
(\#eq:correctedestimate)
\end{equation}

with $\hat{\bar{z}}$ the estimated mean of the finite population. The variance can be estimated by the variance of the mean of the finite population multiplied by the square of $A/a$. However, we still need to assume that the mean of the finite population is equal to the mean of the infinite population. This assumption can be avoided by sampling from an infinite set of floating circles.

```{r circularplotswithinsquares, echo=FALSE, out.width='100%', fig.cap="A simple random sample of ten circular plots from a square area discretised by a finite set of partly overlapping or non-overlapping circular plots."}
s1 <- s2 <- seq(from=5, to=95, by=10)
circles <- expand.grid(s1, s2)
names(circles) <- c("s1","s2")
set.seed(314)
units <- sample.int(nrow(circles), size=10, replace=FALSE)
mysample <- circles[units,]
units <- sample.int(nrow(circles), size=10, replace=FALSE)
mysample <- circles[units,]
#overlapping circles
r <- sqrt(100/pi)
plt1 <- ggplot() +
  geom_tile(mapping=aes(x=50,y=50), width=100, height=100, fill="lightgrey") +
  geom_circle(data=circles, mapping=aes(x0=s1, y0=s2, r=r)) +
  geom_circle(data=mysample, mapping=aes(x0=s1, y0=s2, r=5), fill="red") +
  coord_fixed()
#non-overlapping circles
plt2 <- ggplot() +
  geom_tile(mapping=aes(x=50,y=50), width=100, height=100, fill="lightgrey") +
  geom_circle(data=circles, aes(x0=s1, y0=s2, r=5)) +
  geom_circle(data=mysample, aes(x0=s1, y0=s2, r=5), fill="red") +
  coord_fixed()
grid.arrange(plt1, plt2, nrow=1)
```

### Sampling from an infinite set of floating circles

Simple random sampling of floating circular plots\index{Floating circular plot} can be done by selecting the centers of the plots by simple random sampling, and then determining the border of the circular plots. The circular plots overlap if two selected points are separated by a distance smaller than the diameter of the circular plots. Besides, when a plot is selected near the border of the study area, a part of the plot is outside the study area. This part is ignored in estimating the population mean or total. To select the centers the study area must be extended by a zone with a width equal to the radius of the circular plots. This is illustrated in Figure \@ref(fig:circularplots), showing a square study area of 100 m x 100 m. To select ten circular plots with a radius of 5 m from this square, ten points are selected by simple random sampling, using function `runif`, with -5 as lower limit and 105 as upper limit of the uniform distribution.

```{r SIcircles}
set.seed(129)
s1 <- runif(10, min=-5, max=105)
s2 <- runif(10, min=-5, max=105)
```

Two points are selected outside the study area, in the extended zone. For both points a small part of the circular plot is inside the square. To determine the study variable for these two sampling units, only the part of the plot inside the square is observed. In other words, these two observations have a smaller support than the observations on the other eight plots, see Chapter \@ref(GeneralIntro).

In the upper left corner two sampling units are selected that largely overlap. The intersection of the two circular plots is used twice, to determine the study variable of both sampling units.

```{r circularplots, echo=FALSE, out.width='70%', fig.cap="A simple random sample of ten floating circular plots from a square area."}
library(ggforce)
circles <- data.frame(s1,s2)
ggplot() +
  geom_tile(aes(x=50, y=50), width=108, height=110, fill="grey") +
  geom_tile(aes(x=50,y=50), width=100, height=100, fill="lightgrey") +
  geom_point(data=circles, mapping=aes(x=s1, y=s2), size=1) +
  geom_circle(data=circles, mapping=aes(x0=s1, y0=s2, r=4)) +
  coord_fixed()
```

Given the observations for the selected circular plots, the population total can be estimated by [@DeVries1986]

\begin{equation}
\hat{t}(z)= \frac{A}{a}\frac{1}{n}\sum_{k \in \mathcal{S}} z_k\;,
(\#eq:EstimatorPopulationTotalCircles)
\end{equation}

with $a$ the area of the circle and $z_k$ the observed total of sampling unit $k$ (circle). The same estimate of the total is obtained if we divide the observations by $a$ to obtain a mean per sampling unit:

\begin{equation}
\hat{t}(z)= A\frac{1}{n}\sum_{k \in \mathcal{S}}\frac{z_k}{a}\;.
(\#eq:EstimatorPopulationTotalCircles2)
\end{equation}

The sampling variance of the estimator of the total can be estimated by

\begin{equation}
\widehat{V}(\hat{t}(z)) = \left(\frac{A}{a}\right)^2 \frac{\widehat{S^2}(z_)}{n}\;,
(\#eq:VarEstimatorPopulationTotalCircles)
\end{equation}

with $\widehat{S^2}(z_)$ the estimated population variance of the totals per population unit (circle).

## Confidence interval estimates {#ConfidenceInterval}

A second way of expressing our uncertainty about the estimated total, mean or proportion is to present not merely a single number, but an interval. The wider the interval, the more uncertain we are, and vice versa, the narrower the interval, the more confident we are about the estimate. To learn how to compute a confidence interval\index{Confidence interval}, I return to the sampling distribution of the estimator of the mean soil organic matter concentration. Suppose we would like to compute the bounds of an interval $[a,b]$ such that 5\% of the estimated population means is smaller than $a$, and 5\% is larger than $b$. To compute the lower bound $a$ and upper bound $b$ of this 90\%-interval, we must specify the distribution function. When the distribution of the study variable $z$ is normal and we know the variance of $z$ in the population, then the sampling distribution of the estimator of the population mean is also normal, regardless of the sample size. The larger the sample size, the smaller the effect of the distribution of $z$ on the sampling distribution of the estimator of the population mean. For instance, even when the distribution of $z$ is far from symmetric, then still the sampling distribution of the estimator of the population mean is approximately normal if the sample size is large, say $n > 100$. This is the essence of the central limit theorem\index{Central limit theorem}. Above we already noticed that the sampling distribution is much less asymmetric than the histogram of the simulated values, and looks much more like a normal distribution. Assuming a normal distribution, the bounds of the 90\%-interval are given by

\begin{equation}
\hat{\bar{z}} \pm u_{(0.10/2)}\cdot \sqrt{V\!\left(\hat{\bar{z}}\right)} \;,
(\#eq:CIBounds)
\end{equation}

where $u_{(0.10/2)}$ is the $0.95$ quantile of the standard normal distribution\index{Standard normal distribution}, i.e. the value of $u$ having a tail area of 0.05 to its right. Note that in this equation the sampling variance of the estimator of the population mean $V\!\left(\hat{\bar{z}}\right)$ is used. In practice this variance is unknown, because the population variance is unknown, and must be estimated from the sample (Equations \@ref(eq:EstVarMeanSIR) and \@ref(eq:EstVarMeanSI)). To account for the unknown sampling variance, the standard normal distribution is replaced by the Student's $t$ distribution\index{Student's $t$ distribution}, which has thicker tails than the standard normal distribution. This leads to the following bounds of the $100(1-\alpha)\%$ confidence interval estimate of the mean:

\begin{equation}
\hat{\bar{z}} \pm t^{(n-1)}_{1-\alpha /2}\cdot
\sqrt{\widehat{V}\!\left(\hat{\bar{z}}\right)} \;,
(\#eq:CIBoundsStudent)
\end{equation}

where $t^{(n-1)}_{1-\alpha /2}$ is the $(1-\alpha /2)$ quantile of the Student's $t$ distribution with $(n-1)$ degrees of freedom. The quantity $(1-\alpha)$ is referred to as the confidence level\index{Confidence level}. The larger the number of degrees of freedom\index{Degrees of freedom} $(n-1)$, the closer the Student's $t$ distribution is to the standard normal distribution. The quantity $t^{(n-1)}_{1-\alpha /2}\cdot \sqrt{\widehat{V}\!\left(\hat{\bar{z}}\right)}$ is referred to as the margin of error\index{Margin of error}.

The function `qt` computes a quantile of a Student's $t$ distribution, given the degrees of freedom and the cumulative probability. The bounds of the confidence interval can then be computed as follows. 
```{r}
alpha <- 0.05
margin <- qt(1-alpha/2, n-1, lower.tail=TRUE)*se_mz
lower <- mz - margin
upper <- mz + margin
```

More easily we can use method `confint` of package **survey** to compute the confidence interval.

```{r}
confint(svymean(~z, design_si), df=degf(design_si), level=0.95)
```
The interpretation of a confidence interval is not straightforward. A common misinterpretation is that if the 90\% confidence interval estimate of the mean equals $[a,b]$, then the probability that the population mean is in this interval equals 90\%. In classical sampling theory\index{Classical sampling theory} this cannot be a correct interpretation, because the population mean is not a random variable, and consequently the probability that the population mean is in an interval does not exist. However, the estimated bounds of the confidence interval are random variables, because the estimated population mean and also the estimated sampling variance varies between samples drawn with the sampling design, so it does make sense to attach a probability to this interval. Figure \@ref(fig:coverageconfinterval) shows the 90\% confidence interval estimates of the mean for the first 100 simple random samples drawn above. Note that both the location and the length of the intervals differ between samples. For each sample I determined whether this interval covers the population mean.

```{r coverageconfinterval, echo=FALSE, fig.cap="Estimated confidence intervals of the population mean of SOM (g per kg) in Voorst, estimated from 100 simple random samples of size 40. The vertical red line is at the true population mean."}
lower <- mz-qt(0.05, n-1, lower.tail=FALSE)*sqrt(v_mz)
upper <- mz+qt(0.05, n-1, lower.tail=FALSE)*sqrt(v_mz)
mz_pop <- mean(grdVoorst$z)
ind <- (mz_pop >lower & mz_pop < upper)
coverage <- mean(ind)
x <- c(lower[1:100], upper[1:100])
y <- rep(seq_along(lower[1:100]), times=2)
id <- y
df <- data.frame(id, x, y)
ggplot(data=df) +
        geom_path(mapping=aes(x=x, y=y, group=id))+
        scale_x_continuous(name="90% interval estimate of mean")+
        scale_y_continuous(name="Sample\n", limits=c(0, 100)) +
        geom_vline(xintercept=mz_pop, colour="red")
```

Out of the 10,000 samples, `r number_of_samples - number_of_samples*coverage` samples do not cover the population mean, i.e. close to the specified 10\%. So, a 90\% confidence interval is a random interval that contains in the long rum the population mean 90\% of the time.

### Confidence interval for proportion {#ConfidenceIntervalProportion}

Ideally a confidence interval for a population proportion is based on the binomial distribution\index{Binomial distribution} of the number of sampling units satisfying a condition (the number of successes). The binomial distribution is a discrete distribution. There are various methods for computing coverage probabilities of confidence intervals for a binomial proportion\index{Binomial proportion}, see @Brown2001 for a discussion. A common method for computing the confidence interval of a proportion is the Clopper-Pearson method\index{Clopper-Pearson method}. Function `BinomCI` of package **DescTools** can be used to compute confidence intervals for proportions [@DescTools].

```{r}
library(DescTools)
n <- 50
k <- 5
print(p.est <- BinomCI(k, n, conf.level=0.95,
                       method="clopper-pearson"))
```

The confidence interval is not symmetric around the estimated proportion of 0.1. As can be seen below the upper bound is the proportion at which the probability of 5 or less successes is 0.025,

```{r}
pbinom(q=k, size=n, prob=p.est[3])
```
and the lower bound of the confidence interval is the proportion at which the probability of 5 or more successes is also equal to 0.025. Note that to compute the upper tail probability\index{Upper tail probability} we must assign $k-1 = 4$ to argument `q`, because with argument `lower.tail=FALSE` function `pbinom` computes the probability of $X>x$, not of $X \geq x$.

```{r}
pbinom(q=k-1, size=n, prob=p.est[2], lower.tail=FALSE)
```

For large sample sizes and for proportions close to 0.5 the confidence interval can be computed with a normal distribution as an approximation to the binomial distribution, using Equation \@ref(eq:EstVarProportionSI) for the variance estimator of a proportion:

\begin{equation}
\hat{p} \pm u_{\alpha/2}\sqrt{\frac{\hat{p}(1-\hat{p})}{n-1}} \;.
(\#eq:Waldinterval)
\end{equation}

This interval is referred to as the Wald interval\index{Wald interval}. It is a fact that unless $n$ is very large, the actual coverage probability of the Wald interval is poor for $p$ near 0 or 1. A rule of thumb is that the Wald interval should be used only when $n \cdot min\{p,(1−p)\}$ is at least 5 or 10. For small $n$ @Brown2001 recommend the Wilson interval, and the Agresti-Coull interval for larger $n$. These intervals can be computed with function `BinomCI` of package **DescTools**.

#### Exercises {-}

8. Write an **R** script to select a simple random sample of size 100 from Voorst (data are in `data/Voorst.RData`).  
    + Use the selected sample to estimate the population mean of SOM and its standard error (SOM is in the column $z$ of the data frame).  
    + Compute the lower- and upper bound of the 90\% confidence interval using the Student's $t$ distribution, and check whether the population mean SOM is covered by the interval.  
    + Compare the length of the 90\% confidence interval with the length of the 95\% interval. Explain the difference in width.  
    + Use the selected sample to estimate the total mass of soil organic matter in the topsoil (0 - 20 cm) of Voorst. Use as a bulk density 1.4 g/kg. The size of the pixels is 25 m by 25 m.  
    + Estimate the standard error of the estimated total.  
    + Do you think this standard error is a realistic estimate of the uncertainty about the estimated total?
    
```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:03-SI.Rmd-->

# Stratified simple random sampling {#STSI}

In stratified random sampling\index{Stratified random sampling} the population is divided into subpopulations, for instance soil mapping units, areas with the same land use or land cover, administrative units, etc. The subareas are mutually exclusive, i.e. they do not overlap, and are jointly exhaustive, i.e. their union equals the entire population (study area). Within each subpopulation, referred to as a stratum\index{Stratum}, a probability sample is selected by some sampling design. If these probability samples are selected by simple random sampling, as described in the previous chapter, the design is stratified *simple* random sampling (STSI). If sampling units were selected by cluster random sampling, then the design is stratified *cluster* random sampling. This chapter is about stratified simple random sampling\index{Stratified random sampling!stratified simple random sampling}. 

Stratified simple random sampling is illustrated with Voorst (Figure \@ref(fig:SampleSTSI)). In the data frame with simulated data there is a column `stratum`. These are combinations of soil classes and land use, obtained by overlaying a soil map and a land use map. To select a stratified simple random sample, we set the total sample size $n$ and the sampling units must be apportioned to the strata. I chose to apportion the units proportionally to the size (area, number of pixels) of the strata (see for details Section \@ref(STSIallocation) hereafter). The larger a stratum, the more units are selected from this stratum. The stratum sizes (total number of pixels) are computed with function `tapply`.

```{r stsi}
library(sampling)
load("data/Voorst.RData")
N_h <- tapply(grdVoorst$stratum, INDEX=grdVoorst$stratum,
             FUN=length)
w_h <- N_h/sum(N_h)
n <- 40
print(n_h <- round(n * w_h))
```

The sum of the stratum sample sizes is 41, we want 40, so we reduce the largest stratum sample size by 1. 

```{r}
n_h[1] <- n_h[1] - 1
```

The stratified simple random sample is selected with the function `strata` of package **sampling** [@Tille2016]. The name of the package is added to the function (`sampling::strata`), as `strata` is also a function in another package. Not adding the name of the package may result in an error message. The argument `size` specifies the stratum sample sizes. These stratum sample sizes must be in the order in which the strata are encountered in the data frame `grdVoorst`, which is determined first with function `unique`. Within the strata the grid cells are selected by simple random sampling *with replacement* (`method="srswr"`), so that in principle more than one point can be selected within a grid cell, see Chapter \@ref(SI) for a motivation of this. The function `getdata` extracts the observations for the selected units from the sampling frame, as well as the spatial coordinates and the stratum of these units. The coordinates of the centers of the selected grid cells are jittered by an amount equal to half the side of the grid cells.

```{r}
ord <- unique(grdVoorst$stratum)
set.seed(314)
units <- sampling::strata(
  grdVoorst, stratanames="stratum", size=n_h[ord], method="srswr")
mysample <- getdata(grdVoorst, units)
cellsize <- 25
mysample$s1 <- jitter(mysample$s1, amount=cellsize/2)
mysample$s2 <- jitter(mysample$s2, amount=cellsize/2)
```

Figure \@ref(fig:SampleSTSI) shows the selected sample.

```{r SampleSTSI, echo=FALSE, out.width='100%', fig.cap="Stratified simple random sample of size 40 from Voorst. Strata are combinations of soil class and land use."}
ggplot() +
  geom_raster(data=grdVoorst, mapping=aes(x=s1/1000, y=s2/1000, fill=stratum)) +
  geom_point(data=mysample, mapping=aes(x=s1/1000, y=s2/1000), size=2) +
    scale_fill_manual(
      name="",
      values=c(BA="darkgreen", EA="brown", PA="orange", RA="green", XF="grey")
    ) +  
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

## Estimation of population parameters {#EstimatorsSTSI}

With simple random sampling within strata, the estimator of the mean for simple random sampling (Equation \@ref(eq:HTMeanSI)) is applied at the level of the strata. The estimated stratum means are then averaged, using the relative sizes (relative areas) of the strata as weights:

\begin{equation}
\hat{\bar{z}}= \sum\limits_{h=1}^{H} w_{h}\,\hat{\bar{z}}_{h} \;,
(\#eq:HTMeanSTSI)
\end{equation}

where $H$ is the number of strata, $w_{h}$ are the relative sizes (areas) of the strata (stratum weights)\index{Stratum weight}: $w_h = N_h/N$, and $\hat{\bar{z}}_{h}$ is the estimated mean of stratum $h$ estimated by the sample mean for stratum $h$:

\begin{equation}
\hat{\bar{z}}_{h}=\frac{1}{n_h}\sum_{k \in \mathcal{S}_h} z_k\;,
(\#eq:HTStratumMeanSI)
\end{equation}

with $\mathcal{S}_h$ the sample selected from stratum $h$.

The same estimator is found when the $\pi$ estimator is worked out for stratified simple random sampling. With stratified simple random sampling without replacement and different sampling fractions for the strata^[The sampling fractions are usually slightly different, even with proportional allocation (Section \@ref(STSIallocation)) because $n_h/N_h$ cannot be made exactly equal for all strata.] the inclusion probabilities differ among the strata and equal $\pi_{hk} = n_h/N_h$ for all $k$ in stratum $h$, with $n_h$ the sample size of stratum $h$ and $N_h$ the size of stratum $h$. Inserting this in the $\pi$ estimator of the population mean (Equation \@ref(eq:HTMean)) gives

\begin{equation}
\hat{\bar{z}}= \frac{1}{N}\sum\limits_{h=1}^{H}\sum\limits_{k \in \mathcal{S}_h} \frac{z_{hk}}{\pi_{hk}} = \frac{1}{N}\sum\limits_{h=1}^{H} \frac{N_h}{n_h}\sum\limits_{k \in \mathcal{S}_h} z_{hk} = \sum\limits_{h=1}^{H} w_{h}\,\hat{\bar{z}}_{h} \;.
(\#eq:HTMeanSTSI2)
\end{equation}

The sampling variance of the estimator of the population mean is estimated by first estimating the sampling variances of the estimated stratum means, and then pooling. Note that for the sampling variance we must square the stratum weights:

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}\right)=\sum\limits_{h=1}^{H}w_{h}^{2}\,\widehat{V}\!\left(\hat{\bar{z}}_{h}\right)\;,
(\#eq:EstVarMeanSTSI)
\end{equation}

where $\widehat{V}\!\left(\hat{\bar{z}}_{h}\right)$ is the estimated sampling variance of $\hat{\bar{z}}_{h}$:

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{h}\right)= (1-\frac{n_h}{N_h}) \frac{\widehat{S^2}_h(z)}{n_h}\;,
(\#eq:EstVarstratummean)
\end{equation}

with $\widehat{S^2}_h(z)$ the estimated variance of $z$ within stratum $h$:

\begin{equation}
\widehat{S^2}_h(z)=\frac{1}{n_h-1}\sum\limits_{k \in \mathcal{S}_h}\left(z_{hk}-\hat{\bar{z}}_{h}\right)^{2}\;.
(\#eq:EstStratumVar)
\end{equation}

For stratified simple random sampling with replacement of finite populations and stratified simple random sampling of infinite populations  the $1-(n_h/N_h)$ can be dropped.

```{r}
mz_h <- tapply(mysample$z, INDEX=mysample$stratum, FUN=mean)
mz <- sum(w_h*mz_h)
S2z_h <- tapply(mysample$z, INDEX=mysample$stratum, FUN=var)
v_mz_h <- S2z_h/n_h
se_mz <- sqrt(sum(w_h^2*v_mz_h))
```

```{r stratummeans, echo=FALSE}
N_h <- as.numeric(N_h)
df <- data.frame(Nh=N_h, nh=n_h, Mean=round(mz_h,2), Var=round(S2z_h,2), VarMean=round(v_mz_h,3))

knitr::kable(
  df, caption = 'Stratum size (Nh), stratum sample size (nh), estimated stratum mean (Mean), estimated variance (Variance) and estimated variance of estimated stratum mean (Variance of mean).',
  col.names = c("Nh","nh","Mean","Variance","Variance of mean"),
  booktabs = TRUE
) %>%
  kable_classic()
```

Table \@ref(tab:stratummeans) shows per stratum the estimated means, estimated variances and estimated sampling variances of the estimated means. We can see large differences in the within-stratum variances\index{Within-stratum variance}. For the stratified sample of Figure \@ref(fig:SampleSTSI) the estimated population mean equals `r round(mz,3)` and the estimated standard error of this estimator equals `r round(se_mz,3)`.

The population mean can also be estimated directly using the basic $\pi$ estimator (Equation \@ref(eq:HTMeanSI)). The inclusion probabilities are included in the data frame \texttt{mysample}, in the column `Prob`.

```{r}
head(mysample)
```

The population total is estimated first, and by dividing this estimated total by the total number of population units $N$ an estimate of the population mean is obtained.

```{r}
tz <- sum(mysample$z/mysample$Prob)
print(mz <- tz/sum(N_h))
```

The two estimates of the  population mean are not exactly equal. This is due to rounding errors in the inclusion probabilities. This can be shown by computing the sum of the inclusion probabilities over all population units. This sum should be equal to the sample size $n=40$, but as we can see below, this sum is slightly smaller.

```{r}
pi_h <- tapply(mysample$Prob, INDEX=mysample$stratum, FUN=unique)
print(sum(pi_h*N_h))
```

Now suppose that we ignore that the sample data come from a stratified sampling design, and we use the (unweighted) sample mean as an estimate of the population mean.

```{r}
print(mean(mysample$z))
```

The sample mean slightly differs from the proper estimate of the population mean. The sample mean is a *biased* estimator, but the bias is only small. The reason for the small bias is that the stratum sample sizes are about proportional to the sizes of the strata, so that the inclusion probabilities (sampling intensities) are about equal for all strata: `r pi_h`. The probabilities are not exactly equal because the stratum sample sizes are necessarily rounded to integers and because we reduced the largest sample size by one unit. The bias would have been substantially larger if an equal number of units would have been selected from each stratum, leading to much larger differences in the inclusion probabilities among the strata. Sampling intensity in stratum BA, for instance, then would be much smaller compared to the other strata, and so are the inclusion probabilities of the units in this stratum as compared to the other strata. Stratum is underrepresented in the sample. This is not a problem as long as we account for the difference in inclusion probabilities of the units in estimation of the population mean. If we do not account for these  differences in inclusion probabilities, the estimator of the mean will be seriously biased.

The next code chunk shows how the population mean and its standard error can be estimated with package **survey** [@Lumley2020]. Note that the stratum weights $N_h/n_h$ must be given to function `svydesign` in argument `weight`. These are first attached to the data frame `mysample` by creating a look-up table `lut`, which is then merged with function `merge` to the data frame `mysample`.

```{r}
library(survey)
labels <- sort(unique(mysample$stratum))
lut <- data.frame(stratum=labels, weight=N_h/n_h)
mysample <- merge(x=mysample, y=lut)
design_stsi <- svydesign(
  id=~1, strata=~stratum, weight=~weight, data=mysample)
svymean(~z, design_stsi)
```

### Estimation of population proportion, cumulative distribution function and quantiles

The proportion of a population satisfying some condition can be estimated by Equations \@ref(eq:HTMeanSTSI) and \@ref(eq:HTStratumMeanSI), substituting for the study variable $z_k$ an indicator $y_k$ with value 1 if for unit $k$ the condition is satisfied, and 0 otherwise (Section \@ref(PopProportion)). In general with stratified simple random sampling the inclusion probabilities are not exactly equal, so that the estimated population proportion is not equal to the sample proportion.

These unequal inclusion probabilities must also be accounted for when estimating the cumulative distribution function (CDF) and quantiles (Section \@ref(CDF)), as shown in the next code chunk for the CDF.

```{r}
thresholds <- sort(unique(mysample$z))
cumfreq <- numeric(length=length(thresholds))
for (i in 1:length(thresholds)) {
  ind <- mysample$z <= thresholds[i]
  mh_ind <- tapply(ind, INDEX=mysample$stratum, FUN=mean)
  cumfreq[i] <- sum(w_h*mh_ind)
}
df <- data.frame(x=thresholds, y=cumfreq)
```

Figure \@ref(fig:EstimatedCDFVoorstSTSI) shows the estimated CDF, estimated from the stratified simple random sample of 40 units from Voorst (Figure \@ref(fig:SampleSTSI)).

```{r EstimatedCDFVoorstSTSI, echo=FALSE, fig.asp=0.7, fig.cap="Cumulative distribution function estimated from the stratified simple random sample of 40 units from Voorst."}
dx <- mean(diff(df$x))
dat <- data.frame(
    x=c(df$x[1] - dx, df$x),
    xend=c(df$x, df$x[nrow(df)]+ dx),
    yend= c(df$y, 1)
)

ggplot(dat)+
  geom_segment(mapping=aes(x=x, y=yend, xend=xend, yend=yend))+
  scale_x_continuous(name="SOM") +
  scale_y_continuous(name="Cumulative frequency")
```

The estimated proportions (cumulative frequencies) are used to estimate a quantile. These estimates are easily obtained with function `svyquantile` of package **survey**.

```{r}
svyquantile(~z, design_stsi, quantile=c(0.5,0.9))
```

### Why should we stratify? {#WhyStratify}

There can be two reasons for stratifying the population:  

1. We are interested in the means (totals) per stratum.  
2. We want to increase the precision of the estimated mean (total) for the entire population.  

Figure \@ref(fig:SamplingDistributionSTSI) shows the sampling distributions of the estimator of the population mean for stratified simple random sampling and simple random sampling, both of size 40, obtained by repeating the random sampling with each design and estimation 10,000 times.

```{r, eval=FALSE, echo=FALSE}
number_of_samples <- 10000

mz_STSI <- mz_SI <- numeric(length=number_of_samples)

for (i in 1:number_of_samples) {
  units <- sampling::strata(grdVoorst, stratanames="stratum", size=n_h[unique(grdVoorst$stratum)], method="srswr")
  mysample <- getdata(grdVoorst, units)
  mz_h <- tapply(mysample$z, INDEX=mysample$stratum, FUN=mean)
  mz_STSI[i] <- sum(w_h*mz_h)
  units <- sample.int(nrow(grdVoorst), size=n, replace=TRUE)
  mz_SI[i] <- mean(grdVoorst$z[units])
}
save(mz_STSI, mz_SI,file="results/STSI_Voorst.RData")
```

```{r SamplingDistributionSTSI, echo=FALSE, fig.asp=.8, fig.cap="Sampling distribution of the estimator of the mean of SOM (g/kg) in Voorst for stratified simple random sampling and simple random sampling of size 40."}
load(file="results/STSI_Voorst.RData")
estimates <- data.frame(mz_STSI, mz_SI)
names(estimates) <- c("STSI","SI")
df <- estimates %>% pivot_longer(., cols=c("STSI","SI"))
df$name <- factor(df$name, levels=c("STSI","SI"), ordered=TRUE )
ggplot(data=df) +
    geom_boxplot(mapping=aes(y=value, x=name)) +
    geom_hline(yintercept=mean(grdVoorst$z), colour="red")+
    scale_x_discrete(name="Sampling design") +
    scale_y_continuous(name="Estimated mean SOM")
```

```{r, echo=FALSE}
S2z_h_pop <- tapply(grdVoorst$z, INDEX=grdVoorst$stratum, FUN=var)
v_mz_h <- S2z_h_pop/n_h
v_mz_STSI <- sum(w_h^2*v_mz_h)
v_mz_SI <- var(grdVoorst$z)/n
mz_h_pop <- tapply(grdVoorst$z, INDEX=grdVoorst$stratum, FUN=mean)
```

The sampling distributions of the estimators of the population mean with the two designs are not very different. With stratified random sampling the spread of the estimated means is somewhat smaller. The horizontal red line is the population mean. The gain in precision due to the stratification, referred to as the stratification effect\index{Stratification effect}, can be quantified by ratio of the variance with simple random sampling and the variance with stratified simple random sampling. So when this variance ratio is larger than 1, stratified simple random sampling is more precise than simple random sampling. For Voorst the stratification effect with proportional allocation (Section \@ref(STSIallocation)) equals `r round(v_mz_SI/v_mz_STSI,3)`. This means that with simple random sampling we need `r round(v_mz_SI/v_mz_STSI,3)` more sampling units than stratified simple random sampling to obtain an estimate of the same precision. 

The stratification effect is computed from the population variance $S^2(z)$ (Equation \@ref(eq:VarMean)) and the variances within the strata $S^2_h(z)$. In the sampling experiment these variances are known without error because we know the $z$-values for all units in the population. In practice we only know the $z$-values for the sampled units. However, a design-unbiased estimator of the population variance is [@gru06]

\begin{equation}
\widehat{S^{2}}(z)= \widehat{\overline{z^{2}}}-\left(\hat{\bar{z}}\right)^{2}+
\widehat{V}\!\left(\hat{\bar{z}}\right) \;,
(\#eq:EstimatorPopulationVariancefromSTSI)
\end{equation}

where $\widehat{\overline{z^{2}}}$ denotes the estimated population mean of the study variable squared ($z^2$), obtained in the same way as $\hat{\bar{z}}$ (Equation \@ref(eq:HTMeanSTSI), but using squared values, and $\widehat{V}\!\left(\hat{\bar{z}}\right)$ the estimated variance of the estimator of the population mean (Equation \@ref(eq:EstVarMeanSTSI)). 

The estimated population variance is then divided by the sum of the stratum sample sizes to get an estimate of the sampling variance of the estimator of the mean with simple random sampling of an equal number of units:

\begin{equation}
\widehat{V}(\hat{\bar{z}}_{\text{SI}}) = \frac{\widehat{S^2}(z)}{\sum_{h=1}^{H}n_h}\;.
(\#eq:stratificationeffect)
\end{equation}

```{r, echo=FALSE}
#restore sample 
ord <- unique(grdVoorst$stratum)
set.seed(314)
units <- sampling::strata(grdVoorst, stratanames="stratum", size=n_h[ord], method="srswr")
mysample <- getdata(grdVoorst, units)
labels <- sort(unique(mysample$stratum))
lut <- data.frame(stratum=labels, weight=N_h/n_h)
mysample <- merge(x=mysample, y=lut)
```

The population variance can be estimated with function `s2` of package **surveyplanning** [@surveyplanning]. However, this function is an implementation of an alternative, consistent estimator\index{Consistent estimator}^[An estimator is consistent if the estimate becomes exactly equal to the population value when $n=N$ [@coc77].] of the population variance (@sar92):

\begin{equation}
\widehat{S^2}(z) = \frac{N-1}{N} \frac{n}{n-1} \frac{1}{N-1} \sum_{k \in \mathcal{S}} \frac{(z_k - \hat{\bar{z}}_{\pi})^2}{\pi_k} \;.
(\#eq:EstimatorPopulationVariance4AnyDesign)
\end{equation}

```{r}
library(surveyplanning)
S2z <- s2(mysample$z,w=mysample$weight)
```

The design effect\index{Design effect} is defined as the ratio of the variance of the sampling design under study and the variance of the estimator of the mean with simple random sampling of an equal number of units (Chapter \@ref(DesignEffect)). So the design effect of stratified random sampling is the reciprocal of the stratification effect. For the stratified simple random sample of Figure \@ref(fig:SampleSTSI) the design effect can then be estimated as follows. The function `SE` extracts the standard error of the estimated mean from the output of function `svymean`. The extracted standard error is then squared to obtain an estimate of the sampling variance of the estimator of the population with stratified simple random sampling. Finally, this variance is divided by the variance with simple random sampling of an equal number of units.

```{r}
v_mz_SI <- S2z/n
res <- svymean(~z, design_stsi)
SE(res)^2/v_mz_SI
```

The same value is obtained with argument `deff` of function `svymean`. 

```{r designeffectSTSI}
design_stsi <- svydesign(
  id=~1, strata=~stratum, weight=~weight, data=mysample)
svymean(~z, design_stsi, deff="replace")
```

So, when using package **survey** estimation of the population variance is not needed to estimate the design effect. I only added this to make clear how the design effect is computed with functions in package **survey**. In following chapters I will skip the estimation of the population variance.  

The estimated design effect as estimated from the stratified sample is a bit smaller than 1, showing that stratified simple random sampling is slightly more efficient than simple random sampling. The reciprocal of the estimated design effect is considerably smaller than the stratification effect as computed in the sampling experiment, but this is an estimate of the design effect from one stratified sample only. The estimated population variance varies among stratified samples, and so does the estimated design effect.

Stratified simple random sampling with proportional allocation (Section \@ref(STSIallocation)) is more precise than simple random sampling when the sum of squares of the stratum means is larger than the sum of squares within strata [@loh99]:

\begin{equation}
SSB > \sum_{h=1}^H (1-\frac{N_h}{N})S^2_h \;,
(\#eq:STSImoreprecisewhen)
\end{equation}

with SSB the weighted sum-of-squares between the stratum means:

\begin{equation}
SSB= \sum_{h=1}^H N_h (\bar{z}_h-\bar{z})^2 \;.
(\#eq:SSB)
\end{equation}

In other words, the smaller the differences in the stratum means and the larger the variances within the strata, the smaller the stratification effect will be. Figure \@ref(fig:boxplotsSOMstrata) shows boxplots of SOM per stratum (soil-land use combination). The stratum means are equal to `r round(mz_h_pop,2)`. The stratum variances are `r round(S2z_h_pop,1)`. The rather small differences in stratum means, in combination with the large stratum variances explain the modest gain in precision realised by stratified simple random sampling compared to simple random sampling in this case.

```{r boxplotsSOMstrata, out.width='100%', fig.asp=0.5, echo=FALSE, fig.cap="Boxplots of SOM per landuse-soil combination."}
ggplot(data=grdVoorst) +
  geom_boxplot(aes(y=z, x=stratum)) +
  scale_y_continuous(name="SOM") +
  scale_x_discrete(name="Soil - land use combinations")
```

## Confidence interval estimate  {#CISTSI}

The $100(1-\alpha )$\% confidence interval for $\bar{z}$ is given by

\begin{equation}
\hat{\bar{z}} \pm t_{\alpha /2, df}\cdot
\sqrt{\widehat{V}\!\left(\hat{\bar{z}}\right)} \;,
(\#eq:CISTSI)
\end{equation}

where $t_{\alpha /2,df}$ is the value of $t$ of a Student's $t$ distribution with $df$ degrees of freedom having a tail area of $\alpha/2$ to its right. In other words this is the $(1-(\alpha /2))$ quantile of the Student's $t$ distribution with $df$ degrees of freedom. The degrees of freedom $df$ can be approximated by $n-H$, as proposed by @loh99. This is the number of the degrees of freedom if the variances within the strata are equal. With unequal variances within strata $df$ can be approximated by Sattherwaites method\index{Sattherwaites method} [@nan04]:

\begin{equation}
df \approx \frac {\left(\sum_{h=1}^H w_h^2
\frac{\widehat{S^2}_h(z)}{n_h}\right)^2} {\sum_{h=1}^H w_h^4
\left(\frac{\widehat{S^2}_h(z)}{n_h}\right)^2 \frac {1}{n_h-1}} \;.
(\#eq:dfSattherwaite)
\end{equation}

A confidence interval estimate of the population mean can be extracted with method `confint` of package **survey**. It uses $n-H$ degrees of freedom.

```{r}
res <- svymean(~z, design_stsi)
df_stsi <- degf(design_stsi)
confint(res, df=df_stsi, level=0.95)
```


## Allocation of sample size to strata {#STSIallocation}

After we have decided on the total sample size $n$, we must decide how to apportion the units to the strata. It is reasonable to allocate more sampling units to large strata, and fewer to small strata. The simplest way to achieve this is proportional allocation\index{Allocation!proportional allocation}:

\begin{equation}
n_{h}=n \cdot \frac{N_{h}}{\sum N_{h}}\;,
(\#eq:propallocation)
\end{equation}

with $N_h$ the total number of population units (size) of stratum $h$. With infinite populations $N_h$ is replaced by the area $A_h$. The sample sizes computed with this equation are rounded to the nearest integers.

If we have prior information on the variance of the study variable within the strata, then it makes sense to account for differences in variance. Heterogeneous strata should receive more sampling units than homogeneous strata, leading to Neyman allocation\index{Allocation!Neyman allocation}:

\begin{equation}
n_{h}= n \cdot \frac{N_{h}\,S_{h}(z)}{\sum\limits_{h=1}^{H} N_{h}\,S_{h}(z)} \;.
(\#eq:Neymanallocation)
\end{equation}

with $S_h(z)$ the standard deviation (square root of variance) of the study variable $z$ in stratum $h$.

Finally, costs of sampling may differ between strata. It can be relatively expensive to sample nearly inaccessible strata, and we do not want to sample many units there. This leads to optimal allocation\index{Allocation!optimal allocation}:

\begin{equation}
n_{h}= n \cdot \frac{\frac{N_{h}\,S_{h}(z)}{\sqrt{c_{h}}}}{\sum\limits_{h=1}^{H} \frac{N_{h}\,S_{h}(z)}{\sqrt{c_{h}}}} \;,
(\#eq:optallocation)
\end{equation}

with $c_h$ the costs per sampling unit in stratum $h$. Optimal means that given the total costs this allocation type leads to minimum sampling variance, assuming a linear costs model\index{Linear costs model}:

\begin{equation}
C = c_0 + \sum_{h=1}^H n_h c_h \;.
(\#eq:linearcostmodel)
\end{equation}

with $c_0$ overhead costs. So the more variable a stratum and the lower the costs, the more units will be selected from this stratum.

```{r allocation}
S2z_h <- tapply(X=grdVoorst$z, INDEX=grdVoorst$stratum, FUN=var)
n_h_Neyman <- round(n*N_h*sqrt(S2z_h)/sum(N_h*sqrt(S2z_h)))
```

These optimal sample sizes can be computed with function `optsize` of package **surveyplanning**.

```{r}
labels <- sort(unique(mysample$stratum))
res <- optsize(labels,n,N_h,S2z_h)
round(res$nh,0)
```

Table \@ref(tab:tableallocation) shows the proportional and optimal sample sizes for the five strata of the study area Voorst, for a total sample size of 40. Stratum XF is the one-but-smallest stratum and therefore receives only seven sampling units. However, the standard deviation in this stratum is the largest, and as a consequence with optimal allocation the sample size in this stratum is increased by four points, at the cost of stratum EA which is relatively homogeneous.


```{r tableallocation, echo=FALSE}
strata <- sort(unique(grdVoorst$stratum))
taballoc <- data.frame(Stratum=strata, Nh=as.numeric(N_h), Sh=as.numeric(round(sqrt(S2z_h),2)), nhprop=as.numeric(n_h), nhNeyman=as.numeric(n_h_Neyman))

knitr::kable(
  taballoc, caption = 'Proportional and Neyman sample sizes in stratified simple random sampling of Voorst with a total sample size of 40. Nh: stratum size; Sh: stratum standard deviation',
  booktabs = TRUE
) %>%
  kable_classic()
```

```{r sdmean_allocation, echo=FALSE}
n <- 20:50
S2z_h <- tapply(X=grdVoorst$z, INDEX=grdVoorst$stratum, FUN=var)
se_mz_pro <- se_mz_opt <- numeric(length=length(n))
for (i in 1:length(n)) {
  n_h_pro <- n[i]*w_h
  n_h_Neyman <- n[i] * N_h*sqrt(S2z_h)/sum(N_h*sqrt(S2z_h))
  se_mz_pro[i] <- sqrt(sum(w_h^2*S2z_h/n_h_pro))
  se_mz_opt[i] <- sqrt(sum(w_h^2*S2z_h/n_h_Neyman))
}
sdmean_SI <- sqrt(var(grdVoorst$z)/n)
df <- data.table(n=n, SI=sdmean_SI, STSIpro=se_mz_pro, STSIopt=se_mz_opt)
```

Figure \@ref(fig:plotsdmeanallocation) shows the standard error of the estimated population mean as a function of the total sample size for simple random sampling, and stratified simple random sampling with proportional and Neyman allocation for study area Voorst. A small extra gain in precision can be achieved using Neyman allocation instead of proportional allocation. However, in practice often Neyman allocation is not achievable because we do not know the standard deviations of the study variable within the strata. If a quantitative covariate $x$ is used for stratification (see Sections \@ref(cumrootf) and \@ref(Ospats), hereafter), the standard deviations $S_h(z)$ are approximated by $S_h(x)$, resulting in approximately optimal stratum sample sizes. The gain in precision compared to proportional allocation is then partly or entirely lost.  

```{r plotsdmeanallocation, echo=FALSE, out.width="100%", fig.asp=0.7, fig.cap="Standard error of estimated population mean as a function of the total sample size, for simple random sampling and stratified simple random sampling with proportional and Neyman allocation."}
df_lf <- df %>% pivot_longer(.,cols=c("SI","STSIpro","STSIopt"))
ggplot(df_lf)+
  geom_point(mapping=aes(x=n, y=value, shape=name), size=3)+
  scale_shape_manual(values=c(1,0,2), name="Design", labels=c("SI","STSI(prop)","STSI(Neyman)")) +
  scale_x_continuous(name="Sample size")+
  scale_y_continuous(name="Standard error")
```

Optimal allocation and Neyman allocation assume univariate stratification\index{Univariate stratification}, i.e. the stratified simple random sample is used to estimate the mean of a single study variable. If we have multiple study variables, optimal allocation becomes more complicated. In Bethel allocation\index{Allocation!Bethel allocation} the total sampling costs, assuming a linear costs model (Equation \@ref(eq:linearcostmodel)), are minimised given a constraint on the precision of the estimated mean for each study variable [@Bethel1989], see Section \@ref(MultivariateStratification). Bethel allocation can be computed with function `bethel` of package **SamplingStrata** [@Barcaroli2020].

#### Exercises {-}

1. Looking at Figure \@ref(fig:boxplotsSOMstrata), which strata do you expect can be merged without losing much precision of the estimated population mean?  
2. Load the data of Voorst, and use function `fct_collapse` of package **forcats** [@forcats] to merge the strata EA and PA.  
    + Compute the true sampling variance of the estimator of the mean for this new stratification, a total sample size of 40 and proportional allocation. Check that the sum of stratum sample sizes is 40. (Hint: compute the population variances of SOM per stratum, and divide these by the stratum sample sizes).  
    + Compare this true sampling variance with the true sampling variance using the original five strata (same sample size, proportional allocation). What is your conclusion about the new stratification?   
3. Proof that the sum of the inclusion probabilities over all populations units with stratified simple random sampling equals the sample size $n$.

## *Cum-root-f* stratification {#cumrootf}
When we have a quantitative covariate $x$ related to the study variable $z$ and that is known for all units in the population, strata can be constructed with the *cum-root-f* method using this covariate as a stratification variable, see @Dalenius1959 and @coc77. Population units with similar values for the covariate (stratification variable) are grouped into a stratum. Strata are computed as follows:  

1. Compute a histogram of the stratification variable using a large number of bins.  
2. Compute the square root of the histogram frequencies.  
3. Cumulate the square root of the frequencies, i.e. compute $\sqrt{f_1}$, $\sqrt{f_1} + \sqrt{f_2}$, $\sqrt{f_1} + \sqrt{f_2} + \sqrt{f_3}$, etc.   
4. Divide the cumulative sum of the last bin by the number of strata, multiply this value by 1, 2, $\dots$, *H*-1, with *H* the number of strata, and select the boundaries of the histogram bins closest to these values.

In *cum-root-f* stratification\index{\emph{Cum-root-f} stratification} it is assumed that (after linear transformation) the covariate values are nearly perfect predictions of the study variable, so that the prediction errors do not affect the stratification. Under this assumption the stratification is optimal.

*Cum-root-f* stratification is illustrated with the data of Xuancheng (Anhui province, China). We wish to estimate the mean organic matter concentration in the topsoil (SOM, g/kg) of this area. Various covariates are available that are correlated with SOM, such as elevation, yearly average temperature, slope and various other terrain attributes. Elevation (the name of this variable in the data frame is dem) is used as as a single stratification variable, see Figure \@ref(fig:DEMXuancheng). The correlation coefficient of SOM and elevation in a sample of 183 observations is 0.59. The positive correlation can be explained as follows. Temperature is decreasing with elevation, leading to smaller a decomposition rate of organic matter in the soil.

```{r DEMXuancheng, echo=FALSE, fig.cap="Elevation used as a stratification variable in cum-root-f stratification."}
load("data/Xuancheng.RData")
ggplot(data=grd) +
  geom_raster(mapping=aes(x=x1, y=x2, fill=dem)) +
  scale_fill_viridis_c(name="Elevation") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

The strata can be constructed with the package **stratification** [@Baillargeon2011]. Care should be taken that the data are sorted in ascending order by the columns used for stratification, see help of function `strata.cumrootf`. The argument `n` of this function is the total sample size, but this value has no effect on the stratification. The argument `Ls` is the number of strata. I arbitrarily chose to construct five strata.  The argument `nclass` is the number of bins of the histogram. The output object of the function `strata.cumrootf` is a list containing amongst others a numeric vector with the stratum breaks (`bh`) and a factor with the stratum levels of the grid cells (`stratumID`). Finally, note that the values of the stratification variable must be positive. The minimum elevation is -5 m, so we added the absolute value of this minimum to elevation.

```{r}
library(stratification)
grd <- grd[order(grd$dem),]
dem_new <- grd$dem+abs(min(grd$dem))
crfstrata <- strata.cumrootf(x=dem_new, n=100, Ls=5, nclass=500)
bh <- crfstrata$bh
grd$crfstrata <- crfstrata$stratumID
```

Stratum breaks are threshold values of the stratification variable elevation; these stratum breaks\index{Stratum breaks} are equal to `r round(bh,1)`. Note that the number of stratum breaks is one less than the number of strata. The resulting stratification is shown in Figure \@ref(fig:optstrata). Note that most strata are not single polygons, but are made up of many smaller ones. This may be even more so if the stratification variable shows a noisy spatial pattern. This is not a problem at all, a stratum is just a collection of population units (raster cells), and need not be spatially contiguous.

```{r optstrata, echo=FALSE, fig.cap="Strata obtained with cum-root-f method, using elevation as stratification variable."}
labels <- as.character(round(bh,0))
first <- paste("<", labels[1])
second <- paste(labels[1],"-", labels[2])
third <- paste(labels[2],"-", labels[3])
fourth <- paste(labels[3],"-", labels[4])
fifth <- paste(">", labels[4])
labs <- c(first, second, third, fourth, fifth)

ggplot(data=grd) +
  geom_raster(mapping=aes(x=x1, y=x2, fill=factor(crfstrata))) +
  scale_fill_viridis_d(name="Elevation", labels=labs) +
  scale_y_continuous(name="Northing (km)") +
  scale_x_continuous(name="Easting (km)") +
  coord_fixed()
```

#### Exercises {-}

4. Write an **R** script to compute five *cum-root-f* strata for Eastern Amazonia to estimate the population mean of aboveground biomass (AGB), using log-transformed short-wave infrared (SWIR2)  as stratification variable. To speed up the computations use the 5 km $\times$ 5 km subgrid subsampled from the original 1 km $\times$ 1 km grid. This subgrid is in file  `data/Amazonia_5km.RData`.  
    +  Compute ten *cum-root-f* strata, using function `strata` of package **sampling**. Sort the units first in ascending order on lnSWIR2. Use the stratum sample sizes as computed by the function `strata.cumrootf`.  What allocation is used for computing the stratum sample sizes?  
    + Select a stratified simple random sample of 100 units. First compute the stratum sample sizes for proportional allocation.  
    + Estimate the population mean of AGB and its sampling variance.  
    + Compute the true sampling variance of the estimator of the mean for this sampling design (see Exercise 2 for a hint).  
    + Compute the stratification effect (gain in precision) (Hint: compute the sampling variance for simple random sampling by computing the population variance of AGB, and divide this by the total sample size).  

## Stratification with multiple covariates {#kmeansstratification}

If we have multiple variables that are possibly related to the study variable, we may want to use them all or a subset of them as stratification variables. Using the quantitative variables one-by-one in *cum-root-f* stratification, followed by overlaying the maps with univariate strata, may lead to numerous cross-classification strata.

A simple solution is to construct homogeneous groups, referred to as clusters, of population units (raster cells). The units within a cluster are more similar to each other than to the units in other clusters. Various clustering techniques are available. Here I use hard $k$-means.

This is illustrated again with the Xuancheng case study. Five quantitative covariates are used for constructing the strata. Besides elevation which was used as a single stratification variable in the previous section, now also temperature, slope, topographic wetness index (twi) and profile curvature are used to construct clusters that are used as strata in stratified simple random sampling. To speed up the computations a subgrid with a spacing of 400 m is selected, using function `spsample` of package **sp**, see Chapter \@ref(SY) [@Bivand2013].

```{r}
library(sp)
gridded(grd) <- c("x1","x2")
subgrd <- spsample(
  grd, type="regular", cellsize=0.4, offset=c(0.5,0.5))
subgrd <- data.frame(coordinates(subgrd), over(subgrd,grd))
```

```{r, echo=FALSE}
grd <- as.data.frame(grd)
```

Five clusters are computed with $k$-means using as clustering variables elevation (dem), temperature, slope, profile curvature and topographic wetness index (twi). The scale of the five covariates is largely different, and for that reason they must be scaled before being used in clustering. The $k$-means algorithm is a deterministic algorithm, i.e. the same initial clustering will end in the same final, optimised clustering. This final clustering can be suboptimal, and therefore it is recommended to repeat the clustering as many times as feasible, with different initial clusterings. Argument `nstart` is the number of initial clusterings. The best clustering, i.e. the one with the smallest within-cluster sum-of-squares, is kept.

```{r}
x <- c("dem","temperature","slope","profile.curvature","twi")
set.seed(314)
myClusters <- kmeans(
  scale(subgrd[,x]), centers=5, iter.max=1000, nstart=100)
subgrd$cluster <- myClusters$cluster
```

Figure \@ref(fig:kmeansstrataXuancheng) shows the five strata obtained by the $k$-means clustering\index{\emph{k}-means clustering} of the raster cells.

```{r kmeansstrataXuancheng, echo=FALSE, fig.cap="Five $k$-means clusters using five scaled covariates in clustering, to be used as strata in random sampling from study area Xuancheng."}
ggplot(subgrd) +
  geom_raster(mapping=aes(x=x1, y=x2, fill=as.character(cluster))) +
  scale_fill_viridis_d(name="Stratum") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

The size of the clusters (strata) is largely different among the strata (Table \@ref(tab:tablekmeansstrata)). This table also shows means of the unscaled covariates used in clustering.

```{r tablekmeansstrata, echo=FALSE}
N_h <- tapply(subgrd$dem, INDEX=list(subgrd$cluster), FUN=length)
mean.dem <- tapply(subgrd$dem, INDEX=list(subgrd$cluster), FUN=mean)
mean.temp <- tapply(subgrd$temperature, INDEX=list(subgrd$cluster), FUN=mean)
mean.slope <- tapply(subgrd$slope, INDEX=list(subgrd$cluster), FUN=mean)
mean.pc <- tapply(subgrd$profile.curvature, INDEX=list(subgrd$cluster), FUN=mean)
mean.twi <- tapply(subgrd$twi, INDEX=list(subgrd$cluster), FUN=mean)

df <- data.frame(Stratum=seq(1:5), Nh=N_h, Elevation=round(mean.dem,0), Temperature=round(mean.temp,2), Slope=round(mean.slope,2), Profilecurv=round(mean.pc,5), Twi=round(mean.twi,2))
knitr::kable(
  df, caption = 'Total number of raster cells (Nh) and means of clustering variables of the five strata in Xuancheng obtained with k-means clustering of raster cells.',
  booktabs = TRUE
) %>%
  kable_classic()
```

In the situation that we already have some data of the study variable, an alternative solution is to calibrate a model for the study variable, for instance a multiple linear regression model, using the covariates as predictors, and to use the predictions of the study variable as a single stratification variable in *cum-root-f* stratification or in optimal spatial stratification, see Section \@ref(Ospats).

## Geographical stratification {#geostrata}

When no covariate is available, we may still decide to apply a  *geographical stratification*\index{Geographical stratification}. For instance, a square study area can be divided into $4 \times 4$ equally sized subsquares that are used as strata. When we select one or two points per subsquare, we avoid strong spatial clustering of the sampling points. Geographical stratification improves the *spatial coverage*\index{Spatial coverage}. When the study variable is spatially structured, think for instance of a spatial trend, then geographical stratification will lead to more precisely estimated means (smaller sampling variances).

A simple method for constructing geographical strata is $k$-means clustering [@bru99]. See Chapter \@ref(SpatialCoverage) for a simple illustrative example of how geographical strata are computed with $k$-means clustering. In this approach the study area is discretised by a large number of pixels (raster cells). These pixels are the objects that are clustered. The clustering variables are simply the s1-coordinate (Easting) and s2-coordinate (Northing) of the centers of the pixels. This method leads to compact geographical strata\index{Compact geographical strata}, shortly referred to as geostrata\index{Geostrata}. Geostrata can be computed, as in Section \@ref(kmeansstratification), with function `kmeans`. The two clustering variables have the same scale, so they should not be scaled because this would lead to an arbitrary distortion of geographical distances.  The geostrata generally will not have the same area (number of pixels). Geostrata of equal area can be attractive, as then the sample becomes selfweighting, i.e. the sample mean is an unbiased estimator of the population mean. 

Geostrata of the same area can be computed with function `stratify` of the package **spcosa** [@walvoort2010], with argument `equalArea=TRUE`^[If the total number of pixels divided by the number of strata is an integer, the stratum sizes are exactly equal, otherwise the difference is 1 pixel.]. 
@walvoort2010 describe the $k$-means algorithms implemented in this package in detail. The argument `object` of function `stratify` specifies a spatial object of the population units. In the **R** code below the data frame `grdVoorst` is changed into a `SpatialPixelsDataFrame` with function `gridded` of the package **sp**. The spatial object can also be of class `SpatialPolygons`. In that case either argument `nGridCells` or argument `cellSize` must be set, so that the vector map in `object` can be discretised by a finite number of grid cells. Argument `nTry` specifies the number of initial stratifications in $k$-means clustering, and so is comparable with argument `nstart` of function `kmeans`. For more details on spatial stratification using $k$-means clustering, see Chapter \@ref(SpatialCoverage). The $k$-means algorithm used with `equalArea=TRUE` takes much more computing time than the one used with `equalArea=FALSE`. 

```{r spcosa, eval=FALSE}
library(spcosa)
library(sp)
set.seed(314)
gridded(subgrd) <- ~x1+x2
mygeostrata <- stratify(
  object=subgrd, nStrata=50, nTry=1, equalArea=TRUE)
```

```{r, eval=FALSE, echo=FALSE}
save(mygeostrata, file="results/geostrata_Xuancheng.RData")
```

```{r, echo=FALSE}
subgrd <- as(subgrd, "data.frame")
load(file="results/geostrata_Xuancheng.RData")
```

Function `spsample`  of package **spcosa** is used to select from each geostratum a simple random sample of two points.

```{r}
set.seed(314)
mysample <- spcosa::spsample(mygeostrata, n=2)
mysample <- as(mysample, "data.frame")
mygeostrata <- as(mygeostrata,  "data.frame")
```

The operator `%>%` of package **magrittr** [@magrittr] can be used to merge the two lines in the code chunk above. In this way we can save memory, as we do not need an object of the class `SamplingPatternRandomSamplingUnits` obtained with function `spsample`.

```{r, eval=FALSE}
library(magrittr)
mysample <- spcosa::spsample(mygeostrata, n=2) %>% as(.,"data.frame")
```

Figure \@ref(fig:GeoStrata) shows 20 compact geostrata of equal area of Voorst with the selected sampling points.  Note that the sampling points are reasonably well spread throughout the study area.

```{r GeoStrata, echo=FALSE, fig.cap="Compact geostrata of equal size in Xuancheng, and stratified simple random sample of two points per stratum."}
ggplot(mygeostrata) +
    geom_raster(mapping=aes(x=x1, y=x2, fill=factor(stratumId))) +
    scale_fill_viridis_d(name="geostratum") +
    geom_point(data=mysample, mapping=aes(x=x1, y=x2), size=2) +
    coord_fixed() +
    scale_x_continuous(name="Easting")+
    scale_y_continuous(name="Northing")+
    theme(legend.position="none")
```

Once the observations are done, the population mean can be estimated with function `estimate`. For Xuancheng I simulated data from a normal distribution, to illustrate estimation with function ` estimate`. Various statistics can be estimated, among which the population mean (spatial mean), the standard error, and the cumulative distribution function (CDF). The CDF is estimated by transforming the data to indicators (Section \@ref(CDF)).

```{r}
library(spcosa)
load(file="results/geostrata_Xuancheng.RData")
mysample <- spcosa::spsample(mygeostrata, n=2)
mydata <- data.frame(z=rnorm(100, mean=10, sd=2))
mean <- estimate(
  "spatial mean", mygeostrata, mysample, data=mydata)
se <- estimate(
  "standard error", mygeostrata, mysample, data=mydata)
cdf <- estimate(
  "scdf", mygeostrata, mysample, data=mydata)
```

The estimated population mean equals `r round(mean, 2)`, with an estimated standard error of `r round(se, 3)`.

#### Exercises {-}  

5. Why is it attractive to select at least two points per geostratum?  
6. The alternative to 20 geostrata and two points per geostratum is 40 geostrata and one point per geostratum. Which sampling strategy will be more precise?  
7. The geostrata in the figure above have equal area, which can be enforced by argument `equalArea=TRUE`. Why are equal areas attractive? Work out the estimator of the population mean for strata of equal size.  
8. Write an **R** script to construct 20 compact geographical strata of equal area for agricultural field Leest. Read the shapefile `Leest5` using function `readOGR` of the package **rgdal**. Remove the projection attributes with `proj4string(shpField) <- NA_character_`. Select two points per geostratum, using function `spsample` of package **spcosa**. Repeat this with 40 strata of equal area, and randomly select one point per stratum.  
    + If only one point per stratum is selected, the sampling variance can be approximated by the collapsed strata\index{Collapsed strata} estimator. In this method pairs of strata are formed, and the two strata of a pair are joined. In each new stratum we now have two points. With an odd number of strata there will be one group of three strata and three points. The sample is then analyzed as if it were a random sample from the new collapsed strata. Suppose we group the strata on the basis of the measurements of the study variable. Do you think this is a proper way of grouping?  
    + In case you think this is not a proper way of grouping the strata, how would you group the strata?  
    + Will the estimated sampling variance estimator be unbiased? If not, will it be overestimated or underestimated?  
9. Laboratory costs for measuring the study variable can be saved by bulking the soil aliquots\index{Soil aliquot} (composite sampling\index{Composite sampling}). There are two options: bulking all soil aliquots from the same stratum (bulking within strata) or bulking by selecting one aliquot from each stratum (bulking across strata). In **spcosa** bulking across strata is implemented. Write an **R** script to construct 20 compact geographical strata for study area Voorst. Use the argument `equalArea = TRUE`. Select four points per stratum using argument `type="composite"`, and change class of resulting object in `SpatialPoints`. Extract the z-values in grdVoorst at the selected sampling points using  function `over`. Add a column to the resulting data frame indicating the composite (points 1 to 4 are from the first stratum, points 5 to 8 from the second stratum, etc.), and estimate the means for the four composites using function `tapply`. Estimate the population mean and its standard error.  
    + Can the sampling variance of the estimator of the mean be estimated for bulking within the strata?  
    + The alternative to analyzing the concentration of four composite samples obtained by bulking across strata  is to analyze all $20 \times 4$ aliquots separately. The strata have equal area, so the inclusion probabilities are equal. As a consequence the sample mean is an unbiased estimator of the population mean. Is the precision of this estimated population mean equal to the estimated population mean with composite sampling? If not, is it smaller or larger, and why?   
    + If you use argument `equalArea = FALSE` in combination with argument `type="composite"`, you get an error message. Why does this not work? 


## Multi-way stratification

In Section \@ref(kmeansstratification) multiple continuous covariates are used to construct clusters of raster cells using k-means. These clusters are then used as strata. This section considers the case where we have multiple categorical and/or continuous variables that we would like to use as stratification variables. The continuous stratification variables are first used to compute strata based on that stratification variable, e.g. using the *cumroot-f* method. What could be done then is to compute the cross-classification of each unit, and use these cross-classifications as strata in random sampling. However, this may lead to numerous strata, maybe even more than the intended sample size. To reduce the total number of strata, we may aggregate cross-classification strata\index{Cross-classification strata} with similar means of the study variable, based on our prior knowledge.

An alternative to aggregation of cross-classification strata is to use the separate strata, i.e. the strata based on an individual stratification variable, as *marginal* strata in random sampling, instead of using the cross-classifications as strata. How this works is explained in Section \@ref(Multiwaystratification).

## Multivariate stratification {#MultivariateStratification}

Another situation is where we have multiple study variables, and we would like to optimise the stratification and allocation for estimating the population means of all study variables. Optimal stratification for multiple study variables is only relevant if we would like to use different stratification variables for the study variables\index{Multivariate stratification}. In many cases we do not have reliable prior information about the different study variables justifying the use of multiple stratification variables. We are already happy to have one stratification variable that may serve to increase the precision of the estimated means of all study variables.

However in case we do have multiple stratification variables, tailored at different study variables, the aim is to partition the population in strata, so that for a given allocation, the total sampling costs, assuming a linear costs model (Equation \@ref(eq:linearcostmodel)), is minimised given a constraint on the precision of the estimated mean for each study variable. 

Package **SamplingStrata** [@Barcaroli2020] can be used to optimise multivariate strata. @Barcaroli2014 gives details about the objective function and the algorithm used for optimising the strata. Sampling units are allocated to the strata by Bethel allocation\index{Allocation: Bethel allocation} [@Bethel1989]. The required precision is specified in terms of a coefficient of variation\index{Coefficient of variation}, one per per study variable. 

Multivariate stratification is illustrated with the Meuse data set of package **gstat** [@peb04]. The prior data of heavy metal concentrations of Cd and Zn, are used in spatial prediction, to create maps of these two study variables. These predictions of the study variables are used as stratification variables in designing a new sample for design-based estimation of the population means of Cd and Zn.

The maps of natural logarithms of the two metal concentrations are created by kriging with an external drift, using the square root of the distance to the Meuse river as a predictor for the mean, see Section \@ref(IntroKED) for how this spatial prediction method works.

```{r, echo=FALSE}
library(sp)
library(gstat)
data("meuse")
coordinates(meuse) <- ~x+y
lcdr_vgm <- variogram(log(cadmium)~sqrt(dist), meuse)
lcdr_fit <- fit.variogram(lcdr_vgm, model=vgm(1, "Exp", 300, 1))
```

```{r, echo=FALSE}
lznr_vgm <- variogram(log(zinc)~sqrt(dist), meuse)
lznr_fit <- fit.variogram(lznr_vgm, model=vgm(1, "Exp", 300, 1))
```

Figure \@ref(fig:PredictedCd) shows the map with the predicted log Cd and log Zn concentration.

```{r, echo=FALSE, results= 'hide'}
library(magrittr)
data(meuse.grid)
gridded(meuse.grid) <- ~x+y
#kriging of Cd
lcd_kriged <- krige(
  formula=log(cadmium)~sqrt(dist), 
  locations=meuse, 
  newdata=meuse.grid, 
  model=lcdr_fit,
  debug.level=0)  %>% as(.,"data.frame")
#kriging of Zn
lzn_kriged <- krige(
  log(zinc)~sqrt(dist),
  meuse, meuse.grid,
  model=lznr_fit,
  debug.level=0) %>% as(.,"data.frame")
```


```{r PredictedCd, echo=FALSE, out.width='100%', fig.cap="Kriging predictions of natural logarithms of Cd and Zn concentration in study area Meuse (Netherlands), used as stratification variable in bivariate stratification."}
df <- data.frame(x=lcd_kriged$x, y=lcd_kriged$y, lnCd=lcd_kriged$var1.pred, lnZn=lzn_kriged$var1.pred)

plt1 <- ggplot(data=df) +
  geom_raster(mapping=aes(x=x/1000, y=y/1000, fill=lnCd)) +
  scale_fill_viridis_c(name="lnCd") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()

plt2 <- ggplot(data=df) +
  geom_raster(mapping=aes(x=x/1000, y=y/1000, fill=lnZn)) +
  scale_fill_viridis_c(name="lnZn") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()

grid.arrange(plt1, plt2, nrow=1)
```

The predicted log concentrations of the two heavy metal concentrations are used as stratification variables. For the log of Cd there are negative predicted concentrations (Figure \@ref(fig:PredictedCd)). This leads to an error when running function ` optimStrata`. The minimum predicted log Cd concentration is -1.7, so I added 2 to the predictions. A variable indicating the domains of interest is added to the data frame. The value of this variable is 1 for all grid cells, so that a sample is designed for estimating the mean of the entire population. As a first step function  ` buildFrameDF` is used to create a data frame that can be handled by function `optimStrata`. Argument `X` specifies the stratification variables, and argument `Y` the study variables. In our case the stratification variables and the study variables are the same. This is typical for the situation where the stratification variables are obtained by mapping the study variables.

```{r}
library(SamplingStrata)
df <- data.frame(cd=lcd_kriged$var1.pred,
                 zn=lzn_kriged$var1.pred)
df$cd <- df$cd+2
df$dom <- rep(1,nrow(df))
df$id <- c(1:nrow(df))
frame <- buildFrameDF(
  df=df, id="id",
  X=c("cd","zn"), Y=c("cd","zn"),
  domainvalue="dom")
```

Next, a data frame with the precision requirements for the estimated means is created. The precision requirement is given as a coefficient of variation, i.e. the standard error of the estimated population mean, divided by the estimated mean. The study variables as specified in `Y` are used to compute estimated means and the standard errors for a given stratification and allocation.
 
```{r}
cv <- as.data.frame(
  list(DOM="DOM1", CV1=0.02, CV2=0.02, domainvalue=1))
```

Finally, the multivariate stratification is optimised, by optimising the stratum bounds, using a genetic algorithm [@ger99].

```{r, eval=FALSE}
set.seed(314)
res <- optimStrata(
  method="continuous",  errors=cv, framesamp=frame, nStrata=5, 
  iter=50, pops=20, showPlot=FALSE)
```

```{r, echo=FALSE, eval=FALSE}
save(res, file="results/multivariatestrata_Meuse.RData")
```

```{r, echo=FALSE}
load(file="results/multivariatestrata_Meuse.RData")
```

A summary of the strata can be obtained with function `summaryStrata`.

```{r}
smrstrata <- summaryStrata(
  res$framenew, res$aggr_strata, progress=FALSE)
```

```{r, echo=FALSE}
smrstrata <- smrstrata[,c(2,3,4,6,7,8,9)]
smrstrata[,c(4,5,6,7)] <- round(smrstrata[,c(4,5,6,7)],3)
print(smrstrata)
```

The column `Population` is the size of the strata (number of pixels). The total sample size equals `r sum(smrstrata$Allocation)`. The sample sizes per stratum are computed with Bethel allocation, see Section \@ref(STSIallocation). The last four columns contain the lower and upper bounds of the orthogonal intervals.

Figure \@ref(fig:2dplotbivariatestrata) shows a 2D-plot of the bivariate strata. The strata can be plotted as a series of nested rectangles. All population units in the smallest rectangle belong to stratum 1; all units in the one-but-smallest rectangle that are not in the smallest rectangle belong to stratum 2, etc. If we have more than two stratification variables the strata form a series of nested hyperrectangles or boxes. The strata are obtained as the Cartesian product of orthogonal intervals.  

```{r 2dplotbivariatestrata, fig.cap="Optimised bivariate strata for study area Meuse."}
plt <- plotStrata2d(
  res$framenew, res$aggr_strata, domain=1, 
  vars=c("X1","X2"), labels=c("Cd","Zn"))
```

It may happen that during the optimisation of the stratum bounds in some resulting strata no units are contained. If the solution with a smaller number of strata requires fewer sampling units, then this is retained as the optimal stratification (personal communication Giulio Barcaroli).

Figure \@ref(fig:OptimisedstrataMeuse) shows a map of the optimised strata.

```{r OptimisedstrataMeuse, echo=FALSE, out.width="70%", fig.cap="Optimised bivariate strata for study area Meuse."}
dfnew <- data.frame(coordinates(meuse.grid),res$framenew)
ggplot(dfnew) +
    geom_raster(mapping=aes(x=x/1000, y=y/1000, fill=factor(STRATO))) +
    scale_fill_viridis_d(name="Strata") +
    scale_x_continuous(name="Easting (km)") +
    scale_y_continuous(name="Northing (km)") +
    coord_fixed()
```

The expected coefficient of variation can be extracted with function `expected_CV`.

```{r}
expected_CV(res$aggr_strata)
```

The coefficient of variation of Cd is indeed equal to the desired level of 0.02, for Zn it is smaller. So in this case Cd is the study variable that determines the total sample size of 26 units. 

Note that these coefficients of variation are computed from the stratification variables, which are predictions of the study variable. Errors in these predictions are not accounted for. It is well-known that kriging is a smoother, so that the variance of the predicted values within a stratum is smaller than the variance of the true values. As a consequence the coefficient of variation underestimates the coefficient of variation of the study variable. See Section \@ref(Ospats) for how prediction errors and spatial correlation of prediction errors can be accounted for in optimal stratification. An additional problem is that I added a value of 2 to the log Cd concentrations. This does not affect the standard error of the estimated mean, but does effect the estimated mean, so that also for this reason the coefficient of variation is underestimated.

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:04-STSI.Rmd-->

# Systematic random sampling {#SY}

A simple way of drawing probability samples whose units are spread uniformly over the study area, is systematic random sampling\index{Systematic random sampling} (SY). Systematic random sampling from a two-dimensional spatial population entails sampling on a regular grid\index{Regular grid}. A systematic sample can be selected with function `spsample` of package **sp** with argument `type = "regular"` [@Bivand2013]. The argument `offset` is not used, so that the grid is randomly placed on the study area. This is illustrated, as in the previous chapters, with Voorst. 

```{r}
load("data/Voorst.RData")
set.seed(314)
#change class of grdVoorst to SpatialPixelsDataFrame
gridded(grdVoorst) <- ~s1+s2
n <- 40
mySYsample <- spsample(x=grdVoorst, n=n, type="regular") %>%
  as(.,"data.frame")
```

Figure \@ref(fig:sampleSY) shows the randomly selected systematic sample. The shape of the grid square\index{Square grid}, and the orientation is E-W, N-S. There is no strict need for random selection of the orientation of the grid. Random placement of the grid on the study area suffices for design-based estimation.

```{r sampleSY, echo=FALSE, out.width='100%', fig.cap="Systematic random sample (randomly placed square grid) from Voorst."}
ggplot()+
  geom_raster(data=as(grdVoorst,"data.frame"), mapping = aes(x = s1/1000, y = s2/1000), fill="grey")+
  geom_point(data=mySYsample, mapping = aes(x = x1/1000,y = x2/1000), size = 2) +
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  coord_fixed()
```

The argument `n` in function `spsample` is used to set the sample size. Note that this is the *expected* sample size\index{Expected sample size}, i.e. on average, over repeated sampling the sample size is 40. In Figure \@ref(fig:sampleSY) the number of selected sampling points equals `r nrow(mySYsample)`, but this is a lucky shot only. Given the expected sample size, the spacing\index{Grid spacing} of the square grid can be computed with $\sqrt{A/n}$, with $A$ the area of the study area. This area $A$ can be computed by the total number of pixels multiplied by the pixel area. Function `getGridTopology` is used to retrieve the cell size of the pixels of the `SpatialPixelsDataFrame`. Note that this area is smaller than the number of pixels in the horizontal direction, multiplied by the number of pixels in the vertical direction, multiplied by the pixel area, as we have non-availables (built-up areas, roads, etc.).   

```{r}
gridtop <- as(getGridTopology(grdVoorst), "data.frame")
A <- nrow(grdVoorst)*gridtop$cellsize[1]*gridtop$cellsize[2]
(spacing <- sqrt(A/n))
```

Instead of argument `n` we may use argument `cellsize` to select a grid with a specified spacing. The expected sample size of a square grid can then be computed with $A/spacing^2$. 

The spatial coverage\index{Spatial coverage} with random grid sampling is better than with a stratified random sample using compact geographical strata (Section \@ref(geostrata)), even with one sampling unit per geostratum. Consequently, in general systematic random sampling results in more precise estimates of the mean or total.

However, there are also two disadvantages of systematic random sampling compared to geographically stratified random sampling. First, for systematic random sampling no design-unbiased estimator of the sampling variance exists. Second, the number of sampling units with random grid sampling is not fixed, but varies among randomly drawn samples. We may choose the grid spacing such that *on average* the number of sampling units equals the required (allowed) number of sampling units, but for the actually drawn sample, this number can be smaller or larger. In Voorst the variation of the sample size is quite large. The histogram shows a bimodal distribution (Figure \@ref(fig:samplesizeSY)). The smaller sample sizes are of square grids with only two East-West oriented rows of points instead of three rows.

```{r, echo=FALSE}
.kmeans_equal_size <- function(s1, s2, k) {
  n <- length(s1)
  cluster_id <- rep(1:k, times=ceiling(n/k))
  cluster_id <- cluster_id[1:n]
  cluster_id <- cluster_id[sample.int(n, size=n)]
  s1_c <- tapply(s1, INDEX=cluster_id, FUN=mean)
  s2_c <- tapply(s2, INDEX=cluster_id, FUN=mean)
  repeat {
    n_swop <- 0
    for (i in 1:(n-1)) {
      ci <- cluster_id[i]
      for (j in (i+1):n) {
        cj <- cluster_id[j]
        if(ci==cj) {next}
        d1 <- (s1[i] - s1_c[ci])^2 + (s2[i] - s2_c[ci])^2 +
          (s1[j] - s1_c[cj])^2 + (s2[j] - s2_c[cj])^2
        d2 <- (s1[i] - s1_c[cj])^2 + (s2[i] - s2_c[cj])^2 +
          (s1[j] - s1_c[ci])^2 + (s2[j] - s2_c[ci])^2
        if (d1 > d2) {
          cluster_id[i] <- cj; cluster_id[j] <- ci
          s1_c <- tapply(s1, cluster_id, mean)
          s2_c <- tapply(s2, cluster_id, mean)
          n_swop <- n_swop + 1
          break
        }
      }
    }
    if(n_swop==0) {break}
  }
  D <- fields::rdist(x1=cbind(s1_c,s2_c), x2=cbind(s1,s2))
  dmin <- apply(D, MARGIN=2, FUN=min)
  MSSD <- mean(dmin^2)
  list(clusters=cluster_id, MSSD=MSSD)
}

kmeans_equal_size <- function(s1, s2, k, ntry) {
  res_opt <- NULL
  MSSD_min <- Inf
  for (i in 1:ntry) {
      res <- .kmeans_equal_size(s1, s2, k)
      if (res$MSSD < MSSD_min) {
        MSSD_min <- res$MSSD
        res_opt <- res
      }
  }
  res_opt
}
```



```{r, echo=FALSE}
matern <- function(s){
  g_11 <- within(s, {gr <- i; gs <- j; z11 <- z})[,c('gr','gs','z11')]
  g_12 <- within(s, {gr <- i; gs <- j-1; z12 <- z})[,c('gr','gs','z12')]
  g_21 <- within(s, {gr <- i-1; gs <- j; z21 <- z})[,c('gr','gs','z21')]
  g_22 <- within(s, {gr <- i-1; gs <- j-1; z22 <- z})[,c('gr','gs','z22')]
  g <- Reduce(function(x,y) merge(x = x, y = y, by = c('gr','gs'), all=TRUE), 
              list(g_11, g_12, g_21, g_22))
  g[is.na(g)] <- mean(s$z)
  g <- within(g, T <- (z11-z12-z21+z22)^2/4)
  sum(g$T)/((nrow(s))^2)
}
```

```{r, echo=FALSE, eval=FALSE}
number_of_samples <- 10000

mz_SY_HT <- mz_SY_ratio <- mz_SI <- sampleSizes <- numeric(length=number_of_samples)
av_SI_mz <- av_STSI_mz <- av_Matern_mz <- numeric(length=number_of_samples)

set.seed(314)
for (i in 1:number_of_samples) {
  mysample <- spsample(x=grdVoorst, n=n, type="regular")
  res <- over(mysample, grdVoorst)
  mysample <- as(mysample, "data.frame")
  mysample$z <- res$z
  sampleSizes[i]<-nrow(mysample)
  mz_SY_HT[i] <- sum(mysample$z)/n
  mz_SY_ratio[i] <- mean(mysample$z)
  
  #SI variance approximation
  av_SI_mz[i] <- var(mysample$z)/nrow(mysample)
  
  #STSI variance approximation
  k <- floor(sampleSizes[i]/2)
  res <- kmeans_equal_size(s1=mysample$x1/1000, s2=mysample$x2/1000, k=k, ntry=20)
  mysample$cluster <- res$clusters
  S2z_h <- tapply(mysample$z, INDEX=mysample$cluster, FUN=var)
  nh <- tapply(mysample$z, INDEX=mysample$cluster, FUN=length)
  v_mz_h <- S2z_h/nh
  w_h <- nh/sum(nh)
  av_STSI_mz[i] <- sum(w_h^2*v_mz_h)
  
  #Matern variance approximation
  mysample <- mysample %>%
    mutate(i=round((x1-min(x1))/spacing), j=round((x2-min(x2))/spacing))
  av_Matern_mz[i] <- matern(mysample)
  
  units <- sample.int(nrow(grdVoorst), size = n, replace = FALSE)
  mz_SI[i] <- mean(grdVoorst$z[units])
}

save(mz_SY_HT, mz_SY_ratio, mz_SI, av_SI_mz, av_STSI_mz, av_Matern_mz, sampleSizes, file="results/SYVoorst_square.RData")
```

```{r samplesizeSY, echo=FALSE, fig.cap="Sampling distribution of sample size of systematic random sampling."}
load(file="results/SYVoorst_square.RData")

df <- data.frame(size=sampleSizes)

ggplot(data = df) +
  geom_histogram(aes(x=size), binwidth=1, fill="black", alpha=0.5, colour="black", breaks=19.5:49.5) +
  scale_y_continuous(name = "Number of samples") +
  scale_x_continuous(name = "Sample size")
```

A large variation in sample size, if the sampling with the sampling design under study would be repeated, is undesirable and should be avoided when possible. In this case a simple solution is to  select a rectangular grid\index{Rectangular grid} instead of a square grid, with a spacing in the North-South direction that results in  a fixed number of East-West oriented rows of sampling points over repeated selection of grids.  This is achieved with a North-South spacing equal to the dimension of the study area in North-South direction divided by an integer.  The spacing in East-West direction is then adapted so that on average a given number of sampling points is selected. The North-South dimension of the study area is 1,000 m. A North-South spacing of 1,000/3 m is chosen, so that the number of East-West oriented rows of sampling points in the systematic sample equals three.

```{r}
dy <- 1000/3
dx <- A/(n*dy)
mySYsample_rect <- spsample(
  x=grdVoorst, cellsize=c(dx,dy), type="regular")
```

The East-West spacing is somewhat larger than the North-South spacing: `r dx` m. The variation in sample size with the random rectangular grid is much smaller than that of the square grid.

```{r, echo=FALSE, eval=FALSE}
set.seed(314)
for (i in 1:number_of_samples) {
  mysample <- spsample(x=grdVoorst, cellsize=c(dx,dy), type="regular")
  sampleSizes[i] <- length(mysample)
}
save(sampleSizes, file="results/SYVoorst_rectangular.RData")
```

```{r, echo=FALSE}
load(file="results/SYVoorst_rectangular.RData")
```

```{r}
summary(sampleSizes)
```

An alternative shape for the grid is triangular\index{Triangular grid}. Triangular grids can be selected with the argument `type = "hexagonal"`^[The centers of hexagonal grid cells form a triangular grid.]. The triangular grid  was shown to be yield most precise estimates of the population mean given the expected sample size [@mat86]. Given the spacing of a triangular grid, the expected sample size can be computed by the area $A$ of the study area divided by the area of hexagonal grid cells with the sampling points at their centers. The area of a hexagon equals $6\sqrt{3}/4\;r^2$, with $r$ the radius of the circle circumscribing the hexagon (distance from center to a corner of the hexagon). So by choosing a radius of $\sqrt{A/(6\sqrt{3}/4)\;n}$ the expected sample equals $n$. The distance between neighbouring points of the triangular grid in the East-West direction then  equals $r \sqrt{3}$. The North-South distance equals $\sqrt{3}/2 \; dx$.

```{r}
cnst <- 6*sqrt(3)/4
r <- sqrt(A/(cnst*n))
dx <- r*sqrt(3)
dy <- sqrt(3)/2*dx
```

Function `spsample` does not work properly in combination with argument `type="hexagonal`. Over repeated sampling the average sample size is not equal to the chosen sample size specified with argument `n`. The same problem remains when using argument `cellsize`.

```{r, eval=FALSE, echo=FALSE}
sampleSizes <- numeric(length=10000)
set.seed(314)
for (i in 1:10000) {
  mysample <- spsample(x=grdVoorst, n=n, type="hexagonal")
  sampleSizes[i] <- length(mysample)
}
save(sampleSizes, file="results/SYVoorst_hexagonal.RData")
```

```{r, echo=FALSE}
load(file="results/SYVoorst_hexagonal.RData")
summary(sampleSizes)
```

The following code can be used for random selection of triangular grids.

```{r}
SY_triangular <- function(dx, grd) {
  dy <- sqrt(3)/2*dx
  # randomly select offset 
  offset_x <- runif(1, min=0, max=dx)
  offset_y <- runif(1, min=0, max=dy)
  #compute x-coordinates of 1 row and y-coordinates of 1 column
  bbox <- bbox(grd)
  nx <- ceiling((bbox[1,2]-bbox[1,1])/dx)
  ny <- ceiling((bbox[2,2]-bbox[2,1])/dy)
  x <- (-1:nx)*dx+offset_x
  y <- (0:ny)*dy+offset_y
  #compute coordinates of rectangular grid
  xy <- expand.grid(x, y)
  names(xy) <- c("x","y")
  #shift points of even rows in horizontal direction
  units <- which(xy$y %in% y[seq(from=2, to=ny, by=2)])
  xy$x[units] <- xy$x[units] + dx/2
  #add coordinates of origin
  xy$x <- xy$x+bbox[1,1]
  xy$y <- xy$y+bbox[2,1]
  #overlay with grid
  coordinates(xy) <- ~x+y
  mysample <- data.frame(coordinates(xy), over(xy, grd))
  #delete points with NA
  mysample <- mysample[!is.na(mysample[,3]),]
}
set.seed(314)
mySYsample_tri <- SY_triangular(dx=dx, grd=grdVoorst)
```


```{r Triangulargrid, echo=FALSE, out.width='100%', fig.cap="Systematic random sample (random triangular grid) from Voorst."}
ggplot(as(grdVoorst,"data.frame")) +
  geom_raster(mapping = aes(x = s1/1000, y = s2/1000), fill="grey") +
  geom_point(mySYsample_tri, mapping=aes(x=x/1000, y=y/1000), size=2) +
  scale_x_continuous(name = "Easting") +
  scale_y_continuous(name = "Northing") +
  theme(legend.position = "none") +
  coord_fixed()
```

```{r, echo=FALSE, eval=FALSE}
mz_SY_ratio <- av_SI_mz <- sampleSizes <- numeric(length=number_of_samples)
set.seed(314)
for (i in 1:number_of_samples) {
  mysample <- SY_triangular(dx=dx, grd=grdVoorst)
  sampleSizes[i] <- nrow(mysample)
  mz_SY_ratio[i] <- mean(mysample$z)
  av_SI_mz <- var(mysample$z)/nrow(mysample)
}
save(mz_SY_ratio, av_SI_mz, sampleSizes, file="results/SYVoorst_triangular.RData")
```

```{r, echo=FALSE}
load(file="results/SYVoorst_triangular.RData")
v_mz_SYtriangular <- var(mz_SY_ratio)
m_av_SI_mz_SYtri <- mean(av_SI_mz)
```

## Estimation of population parameters {#EstVarSY}

With systematic random sampling all units have an equal inclusion probability, equal to $E[n]/N$, with $E[n]$ the expected sample size. Consequently, the population total can be estimated by

\begin{equation}
\hat{t}(z)=\sum_{k \in \mathcal{S}}\frac{z_k}{\pi_k} = N \sum_{k \in \mathcal{S}}\frac{z_k}{E[n]} \;.
(\#eq:HTTotalSY)
\end{equation}

The population mean can be estimated by dividing this $\pi$ estimator of the population total by the population size:

\begin{equation}
\hat{\bar{z}}=\sum_{k \in \mathcal{S}}\frac{z_k}{E[n]} \;.
(\#eq:HTMeanSY)
\end{equation}

In this $\pi$ estimator of the population mean the sample sum of the observations is not divided by the number of selected units, but by the expected number of units.

An alternative estimator is obtained by dividing the $\pi$ estimator of the population total by the $\pi$ estimator of the population size:

\begin{equation}
\hat{N}=\sum_{k \in \mathcal{S}}\frac{1}{\pi_k} = n \frac{N}{E[n]} \;.
(\#eq:EstimatorNSY)
\end{equation}

This yields the ratio estimator\index{Ratio estimator} of the population mean:

\begin{equation}
\hat{\bar{z}}_{\text{ratio}}=\frac{1}{n}\sum_{k \in \mathcal{S}}z_k \;.
(\#eq:RatioMeanSY)
\end{equation}

So the ratio estimator of the population total is equal to the unweighted sample mean. The variance of this ratio estimator is in general smaller than that of the $\pi$ estimator. On the other side the $\pi$ estimator is design-unbiased, whereas the ratio estimator is not, although this bias can be negligibly small. Only in the very special case where the sample size with systematic random sampling is fixed, the two estimators are equivalent.

Recall that for Voorst we have exhaustive knowledge of the study variable $z$: values of SOM were simulated for all pixels. To determine the $z$-values at the selected sampling points first an overlay of the systematic random sample and the `SpatialPixelsDataFrame` is made, using function `over` of package **sp**.

```{r}
set.seed(1956)
mySYsample <- spsample(x=grdVoorst, n=n, type="regular")
res <- over(mySYsample, grdVoorst)
mySYsample <- as(mySYsample, "data.frame")
mySYsample$z <- res$z
mz_HT <- sum(mySYsample$z)/n
mz_ratio <- mean(mySYsample$z)
```

The $\pi$ estimated population mean equals `r round(mz_HT,3)`, the ratio estimate equals `r round(mz_ratio,3)`. The ratio estimate is slightly smaller because the size of the selected sample is one unit larger than the expected sample size.

### Approximating the sampling variance of the estimator of the mean

An unbiased estimator of the sampling variance of the estimator of the mean is not available. A simple, often applied procedure is to calculate the sampling variance as if the sample were a simple random sample (Equation \@ref(eq:HTMeanSI)). In general this procedure overestimates the sampling variance, so that we are on the safe side.

```{r}
av_SI_mz <- var(mySYsample$z)/nrow(mySYsample)
```

The approximated variance equals `r round(av_SI_mz,3)`.

Alternatively, the sampling variance can be estimated by treating the systematic random sample as if it were a stratified simple random sample (Equation \@ref(eq:HTMeanSTSI)). The sampling units are clustered on the basis of their spatial coordinates into $H=n/2$ clusters ($n$ even) or $H=(n-1)/2$ clusters ($n$ odd). In the next code chunk a simple $k$-means function is defined to cluster the sampling units of the grid into equal sized clusters\index{\emph{k}-means clustering}. Arguments `s1` and `s2` are the spatial coordinates of the sampling units, `k` is the number of clusters. As a first step in the function the ids of equal-sized clusters are randomly assigned to the sampling units on the nodes of the grid (initial clustering), and the centers of the clusters are computed, i.e. the means of the spatial coordinates of the clusters are computed (initial cluster centers). There are two for-loops. In the inner-loop it is determined whether the cluster id of the unit selected in the outer-loop should be swopped with that of the next unit. If both units have the same cluster id the next unit is selected, until a unit of a different cluster is found. The cluster ids of the two units are swopped when the sum of the squared distances of the two units to their corresponding cluster centers is reduced. When the cluster ids are swopped, the centers are recomputed. The two loops are repeated until no swops are made anymore.

```{r}
.kmeans_equal_size <- function(s1, s2, k) {
  n <- length(s1)
  cluster_id <- rep(1:k, times=ceiling(n/k))
  cluster_id <- cluster_id[1:n]
  cluster_id <- cluster_id[sample.int(n, size=n)]
  s1_c <- tapply(s1, INDEX=cluster_id, FUN=mean)
  s2_c <- tapply(s2, INDEX=cluster_id, FUN=mean)
  repeat {
    n_swop <- 0
    for (i in 1:(n-1)) {
      ci <- cluster_id[i]
      for (j in (i+1):n) {
        cj <- cluster_id[j]
        if(ci==cj) {next}
        d1 <- (s1[i] - s1_c[ci])^2 + (s2[i] - s2_c[ci])^2 +
          (s1[j] - s1_c[cj])^2 + (s2[j] - s2_c[cj])^2
        d2 <- (s1[i] - s1_c[cj])^2 + (s2[i] - s2_c[cj])^2 +
          (s1[j] - s1_c[ci])^2 + (s2[j] - s2_c[ci])^2
        if (d1 > d2) {
          #swop cluster ids and recompute cluster centers
          cluster_id[i] <- cj; cluster_id[j] <- ci
          s1_c <- tapply(s1, cluster_id, mean)
          s2_c <- tapply(s2, cluster_id, mean)
          n_swop <- n_swop + 1
          break
        }
      }
    }
    if(n_swop==0) {break}
  }
  D <- fields::rdist(x1=cbind(s1_c,s2_c), x2=cbind(s1,s2))
  dmin <- apply(D, MARGIN=2, FUN=min)
  MSSD <- mean(dmin^2)
  list(clusters=cluster_id, MSSD=MSSD)
}
```

The clustering is repeated 100 times (`ntry=100`). The clustering with the smallest sum of the squared distances of the sampling units to their cluster centers (MSSD) is selected. 

```{r}
kmeans_equal_size <- function(s1, s2, k, ntry) {
  res_opt <- NULL
  MSSD_min <- Inf
  for (i in 1:ntry) {
      res <- .kmeans_equal_size(s1, s2, k)
      if (res$MSSD < MSSD_min) {
        MSSD_min <- res$MSSD
        res_opt <- res
      }
  }
  res_opt
}
n <- nrow(mySYsample); k <- floor(n/2)
set.seed(314)
res <- kmeans_equal_size(
  s1=mySYsample$x1/1000, s2=mySYsample$x2/1000,
  k=k, ntry=100)
mySYsample$cluster <- res$clusters
```

Figure \@ref(fig:varapproxSY) shows the clustering of the systematic random sample of Figure \@ref(fig:sampleSY). The two (or three) sampling units of a cluster are then treated as a simple random sample from a stratum, and the variance estimator for stratified random sampling is used. With $n$ even the stratum weights are $1/H$ for all strata, with $n$ odd the weights are computed as $w_h=n_h/n$. For more details on variance estimation with stratified simple random sampling, I refer to Section \@ref(EstimatorsSTSI). 

```{r}
S2z_h <- tapply(mySYsample$z, INDEX=mySYsample$cluster, FUN=var)
nh <- tapply(mySYsample$z, INDEX=mySYsample$cluster, FUN=length)
v_mz_h <- S2z_h/nh
w_h <- nh/sum(nh)
av_STSI_mz <- sum(w_h^2*v_mz_h)
```


```{r varapproxSY, echo=FALSE, out.width='100%', fig.asp=.2, fig.cap="Clustering of grid points selected from Voorst for approximating the variance of the estimator of the population mean of SOM."}
ggplot(as(grdVoorst,"data.frame")) +
  geom_raster(mapping = aes(x = s1/1000, y = s2/1000), fill="grey") +
  geom_point(mySYsample, mapping=aes(x=x1/1000, y=x2/1000, colour=as.factor(cluster)), size=2) +
  scale_colour_viridis_d() +
  scale_x_continuous(name = "Easting") +
  scale_y_continuous(name = "Northing") +
  theme(legend.position = "none") +
  coord_fixed()
```

This method yields an approximated variance of `r round(av_STSI_mz,3)`, which is considerably smaller than the simple random sample approximation.

A similar approach for approximating the variance is proposed a long time ago by Mat&eacute;rn [@Matern1947]. In this approach the variance is approximated by computing the squared difference of two local means. A local mean is computed by linear interpolation of the observations at the two nodes on the diagonal of a square grid cell. The four corners of a square grid cell serve as a group. Every grid node belongs to four groups and so the observation at a grid node is used four times in computing a local mean. Near the edges of the study area we have incomplete groups: one, two or even three observations are missing. To compute a squared difference these missing values are replaced by the sample mean. This results in as many squared differences as we have groups. Note that the number of groups is larger than the sample size. The squared differences are computed by

\begin{eqnarray}
d^2_{r,s} &=& \left(\frac{z_{r,s}+z_{r+1,s+1}}{2}-\frac{z_{r+1,s}+z_{r,s+1}}{2}\right)^2 \notag \\
&=&\frac{(z_{r,s}-z_{r+1,s}-z_{r,s+1}+z_{r+1,s+1})^2}{4}\;,
(\#eq:sqdiflocalmean)
\end{eqnarray}

with $r = 0,1, \dots ,R$ an index for the column-number and $s=0,1, \dots, S$ an index for the row-number of the extended grid. The variance of the estimator of the mean (sample mean) is then approximated by the sum of the squared differences divided by the squared sample size:

\begin{equation}
\widehat{V}(\bar{z}_{\mathcal{S}}) = \frac{\sum_{g=1}^G d^2_g}{n^2}\;,
(\#eq:VarMatern)
\end{equation}

with $d^2_g$ the squared difference of group unit $g$, and $G$ the total number of groups.

To approximate the variance with $\text{Mat{\'e}rn}$'s method\index{Mat$\text{{\'e}}$rn's variance approximation method} a function is defined. 

```{r, echo=FALSE}
matern <- function(s){
  g_11 <- within(s, {gr <- i; gs <- j; z11 <- z})[,c('gr','gs','z11')]
  g_12 <- within(s, {gr <- i; gs <- j-1; z12 <- z})[,c('gr','gs','z12')]
  g_21 <- within(s, {gr <- i-1; gs <- j; z21 <- z})[,c('gr','gs','z21')]
  g_22 <- within(s, {gr <- i-1; gs <- j-1; z22 <- z})[,c('gr','gs','z22')]
  g <- Reduce(function(x,y) merge(x = x, y = y, by = c('gr','gs'), all=TRUE), 
              list(g_11, g_12, g_21, g_22))
  g[is.na(g)] <- mean(s$z)
  g <- within(g, T <- (z11-z12-z21+z22)^2/4)
  sum(g$T)/((nrow(s))^2)
}
```

Before using this function the data frame with the sample data must be extended with two variables: an index $i$ for the column number, and index $j$ for the row number of the square grid.

```{r}
mySYsample <- mySYsample %>%
  mutate(i=round((x1-min(x1))/spacing), 
         j=round((x2-min(x2))/spacing))
matern(mySYsample)
```
 
Figure \@ref(fig:SamplingDistributionSY) shows the sampling distributions of the estimator of the population mean for systematic random sampling, using a randomly placed square grid with fixed orientation and an expected sample size of 40, and simple random sampling, obtained by repeating the random sampling with each design and estimation 10,000 times. To estimate the population mean from the systematic random samples both the $\pi$ estimator and the ratio estimator are used.

```{r SamplingDistributionSY,  echo=FALSE, fig.asp=.8, fig.cap="Sampling distribution of estimators of the population mean of SOM (g per kg) in Voorst, with systematic random sampling (square grid) and simple random sampling and an (expected) sample size of 40. With systematic random sampling both the $\\pi$ estimator (SY.HT) and the ratio estimator (SY.ratio) are used in estimation."}
load(file="results/SYVoorst_square.RData")
estimates <- data.frame(mz_SY_HT, mz_SY_ratio, mz_SI)
names(estimates) <- c("SY.HT","SY.ratio","SI")
df <- estimates %>% pivot_longer(.,cols=c("SY.HT","SY.ratio","SI"))
df$name <- factor(df$name, levels=c("SY.ratio","SY.HT","SI"), ordered=TRUE )
ggplot(data = df) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=mean(grdVoorst$z), colour="red")+
    scale_x_discrete(name = "Sampling design") +
    scale_y_continuous(name = "Estimated mean SOM")

grdVoorst <- as(grdVoorst,"data.frame")
```

The boxplots of the estimated means indicate that systematic random sampling in combination with the ratio estimator is more precise than simple random sampling. The variance of the 10,000 ratio estimates equals `r round(var(mz_SY_ratio),3)`, whereas for simple random sampling this variance equals 0.440. Systematic random sampling in combination with the $\pi$ estimator performs very poor: the variance equals `r round(var(mz_SY_HT),3)`. This can be explained by the strong variation in sample size (Figure \@ref(fig:samplesizeSY)), which is not accounted for in the $\pi$  estimator.

The mean of the 10,000 ratio estimates is `r round(mean(mz_SY_ratio),3)`, which is about equal to the population mean `r round(mean(grdVoorst$z),3)`, showing that in this case the design-bias of the ratio estimator is negligibly small indeed.

The average of the 10,000 approximated variances treating the systematic sample as a simple random sample equals `r round(mean(av_SI_mz),3)`. This is larger than the variance of the ratio estimator (`r round(var(mz_SY_ratio),3)`). The stratified simple random sample approximation of the variance is somewhat better: the mean of this variance approximation equals `r round(mean(av_STSI_mz),3)`. The average of the 10,000 variances approximated with $\text{Mat{\'e}rn}$'s method equals `r round(mean(av_Matern_mz),3)`. Figure \@ref(fig:SamplingDistributionApproxVarSY) shows boxplots of the approximated standard error of the estimated population mean. The horizontal red line is at the standard deviation of the 10,000 ratio estimates of the population mean. Differences between the three approximation methods are small in this case. 

```{r SamplingDistributionApproxVarSY,  echo=FALSE, fig.asp=.8, fig.cap="Sampling distribution of approximated standard error of the ratio estimator of the population mean of SOM (g per kg) in Voorst, with systematic random sampling (square grid) and an expected sample size of 40. Approximations are obtained by treating the systematic sample as a simple random sample (SI), stratified simple random sample (STSI), and with  Matern's method (Mat)."}
estimates <- data.frame(SI=sqrt(av_SI_mz),STSI=sqrt(av_STSI_mz),
                        Mat=sqrt(av_Matern_mz))
df <- estimates %>% pivot_longer(.,cols=c("SI","STSI","Mat"))
df$name <- factor(df$name, levels=c("SI","STSI","Mat"), ordered=TRUE)
ggplot(data = df) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=sqrt(var(mz_SY_ratio)), colour="red")+
    scale_x_discrete(name = "Approximtation method") +
    scale_y_continuous(name = "Approximated standard error")
```

The variance of the 10,000 ratio estimates of the population mean with the triangular grid and an expected sample size of 40 equals `r as.character(round(v_mz_SYtriangular,3))`. Treating the triangular grid as a simple random sample strongly overestimates the variance: the average approximate variances equals `r round(m_av_SI_mz_SYtri,3)`. Mat&eacute;rn's method cannot be used to approximate the variance with a triangular grid. Function `kmeans_equal_size` can be used to cluster the points of the triangular grid into clusters of equal size. 

```{r, echo=FALSE}
n <- nrow(mySYsample_tri)
k <- floor(nrow(mySYsample_tri)/2)
set.seed(314)
res <- kmeans_equal_size(
  s1=mySYsample_tri$x/1000, s2=mySYsample_tri$y/1000,
  k=k, ntry=100)
mySYsample_tri$cluster <- res$clusters
```

```{r, echo=FALSE}
S2z_h <- tapply(mySYsample_tri$z, INDEX=mySYsample_tri$cluster, FUN=var)
nh <- tapply(mySYsample_tri$z, INDEX=mySYsample_tri$cluster, FUN=length)
v_mz_h <- S2z_h/nh
w_h <- nh/sum(nh)
av_STSI_mz_SYtri <- sum(w_h^2*v_mz_h)
```

The approximated variance for this clustering equals `r round(av_STSI_mz_SYtri,3)`.

@Brus2016c compared various variance approximations for systematic random sampling, among which model-based prediction of the variance, using a semivariogram that is estimated from the systematic sample, see Chapter \@ref(MBpredictionofDesignVariance).


#### Exercises {-}  

1. One solution to the problem of variance estimation with systematic random sampling is to select multiple systematic random samples independently from each other. So, for instance, instead of one systematic random sample of with an expected sample size of 40, we may select two systematic random samples with an expected size of 20.  
    + Write an **R** script to select two systematic random samples (random square grids) both with an expected size of 20 from Voorst (data are in `data/Voorst.RData`).  
    + Use each sample to estimate the population mean, so that you obtain two estimated means. Overlay the points of each sample with `grdVoorst`, using function `over` and extract the *z*-values.    
    + Use the two estimated means to estimate the sampling variance of the estimator of the mean for systematic random sampling *with an expected sample size of 20*.  
    + Use the two estimated means to compute a single, final estimate of the population mean, as estimated from *two systematic random samples, each with an expected sample size of 20*.   
    + Estimate the sampling variance of the final estimate of the population mean.  
2. Do you like this solution? What about the variance of the estimator of the mean, obtained by selecting two systematic random samples of half the expected size, as compared with the variance of the estimator of the mean obtained with a single systematic random sample?  Hint: plot the two random square grids. What do you think of the spatial coverage of the two samples?. 
  
```{r, echo=FALSE}
rm(list=ls())
```
 

<!--chapter:end:05-SY.Rmd-->

# Cluster random sampling {#Cl}

With stratified random sampling with geographical strata and systematic random sampling the sampling units are well spread throughout the study area. In general this leads to an increase of the precision of the estimated mean (total). This is because many spatial populations show spatial structure, so that the values of the study variable at two close points are more similar than those at two distant points. With large study areas the price to be paid for this is long travel times, so that fewer sampling units can be observed in a given survey time. In this situation it can be more efficient to select *spatial clusters*\index{Spatial cluster} of population units. In cluster random sampling\index{Cluster random sampling}, once a cluster is selected, *all* units in this cluster are observed. For this reason this design is also referred to as *single-stage* cluster random sampling. The clusters are not subsampled, as in two-stage cluster random sampling (see Chapter \@ref(Twostage)).

In spatial sampling a popular cluster shape is a transect\index{Transect}. This is because the individual sampling units of a transect can easily be located in the field, which was in particular an advantage in the pre-GPS era.

The implementation of cluster random sampling is not straightforward. I have seen many examples in the literature of an improper implementation of this sampling design. A proper selection technique is as follows [@gru06]. In the first step a starting point (unit) is selected, for instance by simple random sampling. Then the remaining units of the cluster to which the starting point belongs are identified by making use of the definition of the cluster. For instance, with clusters defined as E-W oriented transects, with a cluster spacing of 100 m, all points east and west of the starting point at a distance of 100 m, 200 m etc. that fall inside the study area are selected. These two steps are repeated until the required number of *clusters* (not the number of points) is selected.

A requirement of a valid selection method is that the same cluster is selected, regardless of which of its units is used as a starting point. In the example above this is the case: regardless of which of the points on the transect is selected first, the final set of points selected is the same because, as stated above, all points E and W of the starting point are selected.

An example of an improper implementation of this sampling design is the following. A cluster is defined as an E-W oriented transect of four points with a mutual spacing of 100 m. A cluster is selected by randomly selecting a starting point. The remaining three points of the cluster are selected E of this starting point. Points outside the study area are ignored. With this selection method the set of selected points is *not* independent of the starting point, and therefore is invalid.

Note that the size of the clusters, i.e. the number of elementary units (points) of a cluster, need not be constant. With the proper selection method described above the selection probability of a cluster is proportional to its size. With irregularly shaped study areas the size of the cluster can vary strongly. The size of the clusters can be controlled by subdividing the study area into blocks, for instance stripes perpendicular to the direction of the transects, or square blocks in case the clusters are grids. In this case, the remaining units are identified by extending the transect or grid until the boundary of the block. With irregularly shaped areas blocking will not eliminate entirely the variation in cluster sizes\index{Cluster size}.

Cluster random sampling is illustrated with the selection of E-W oriented transects in Voorst. In order to delimit the length of the transects the study area is split into six 1 km $\times$ 1 km zones. In this case the zones have an equal size, but this is not needed. Note that these zones do not serve as strata. When used as strata, from each zone one or more clusters would be selected, see Section \@ref(StratifiedCl).  

In the code chunk below the zones are constructed by first computing a vector with the s1-coordinates of the boundaries  of the zones. Half the size of the cells of the discretisation  grid (12.5 m) is added to `s1bnd` so that the boundaries are halfway discretisation nodes. The function `findInterval` of the **base** package [@R2020] is then used to determine for all discretisation nodes in which zone they fall.

```{r}
library(sp)
load("data/Voorst.RData")
gridded(grdVoorst) <- ~s1+s2 
gridtop <- as(getGridTopology(grdVoorst), "data.frame")
cellsize <- gridtop$cellsize[1]
grdVoorst <- as(grdVoorst, "data.frame")
w <- 1000 #width of zones
s1bnd <- seq(from=min(grdVoorst$s1)+w, to=min(grdVoorst$s1)+5*w,
             by=w)+cellsize/2
grdVoorst$zone <- findInterval(grdVoorst$s1, s1bnd)
```

As a first step in the **R** code below all clusters in the finite representation of the population are constructed. This is done by computing the interaction of three factors:

1. the modulus of the s1-coordinate and the spacing of units within a transect (cluster) (computed with the operator `%%`).  
2. the s2-coordinates of the grid cells.  
3. the zones of the grid cells.

Factor 1 has four levels, as the modulus of the s1-coordinates and a spacing of 100 has four possible values: 0, 25, 50 and 75. The cluster-id is added to the sampling frame. Each point belongs exactly to one cluster. 

```{r SampleCl}
#compute local coordinates
s1local <- grdVoorst$s1-min(grdVoorst$s1)
s2local <- grdVoorst$s2-min(grdVoorst$s2)
spacing <- 100 
mods1 <- s1local%%spacing
#construct clusters (E-W oriented transects within zones)
grdVoorst$cluster <- interaction(
  as.factor(mods1),
  as.factor(s2local),
  as.factor(grdVoorst$zone)) %>%  as.character(.)
M_cl <- tapply(
  grdVoorst$z, INDEX=grdVoorst$cluster, FUN=length)
grdVoorst$unit <- 1:nrow(grdVoorst)
```

```{r clustersize, echo=FALSE, fig.cap="Bar plot of size (number of grid cells) of clusters: E-W oriented transects within zones, with an inter-point spacing of 100 m."}
cnts <- table(M_cl) %>% as.numeric(.)
df <- data.frame(Size=seq(from=min(M_cl), to=max(M_cl), by=1), Count=cnts)
ggplot(data = df) +
  geom_bar(aes(x=Size, y=Count), stat="identity")
```

In total there are `r length(unique(grdVoorst$cluster))` clusters in the population. Figure \@ref(fig:clustersize) shows the distribution of the size (number of grid cells) of the clusters.

Clusters are selected with probabilities proportional to their size and with replacement (ppswr). So the sizes of all clusters must be known, which explains that all clusters must be enumerated. Selection of clusters by ppswr can be done by simple random sampling with replacement of elementary units (grid cells), and identifying the clusters to which these units belong. Finally, all units of the selected clusters are included in the sample. In the code chunk below a function is defined for selecting clusters by ppswr. Note the variable `cldraw`, that has value 1 for all units selected in the first draw, value 2 for all units selected in the second draw, etc. This variable is needed in estimating the population mean, see hereafter.

```{r}
cl_ppswr <- function(sframe, n) {
  units <- sample.int(nrow(sframe), size=n, replace=TRUE)
  units_cl <- sframe$cluster[units]
  mysamples <- NULL
  for (i in 1:length(units_cl)) {
    mysample <- sframe[sframe$cluster %in% units_cl[i],]
    mysample$start <- 0
    mysample$start[mysample$unit %in% units[i]] <- 1
    mysample$cldraw <- rep(i, nrow(mysample))
    mysamples <- rbind(mysamples, mysample)
  }
  mysamples
}
```

The function `cl_ppswr` is now used to select six times a cluster by ppswr.

```{r}
n <- 6 
set.seed(314)
mysample <- cl_ppswr(sframe=grdVoorst, n=n)
```

As our population actually is infinite, the selected sampling points (nodes of the discretisation grid) are jittered to a random point within the selected grid cells. Note that the same noise is added to all points of a cluster.

```{r}
for (i in 1:n) {
  units <- which(mysample$cldraw==i)
  mysample$s1[units] <- mysample$s1[units] + 
    runif(1,min=-12.5,max=12.5)
  mysample$s2[units] <- mysample$s2[units] + 
    runif(1,min=-12.5,max=12.5)
}
```

Figure \@ref(fig:ClVoorst) shows the selected sample. Note that in this case the second west-most zone has two transects (clusters) whereas three zones have none, showing that the zones are not used as strata. The total number of selected points equals `r nrow(mysample)`. Similar to systematic random sampling, with cluster random sampling  the total sample size is random, so that we do not have perfect control of the total sample size. This is because in this case the sizes (number of points) of the clusters is not constant but varies.

```{r ClVoorst, echo=FALSE, out.width='100%', fig.cap="Cluster random sample from Voorst. Six times a cluster (transect) is selected with probabilities proportional to their size and with replacement"}
ggplot(grdVoorst) +        
  geom_raster(mapping = aes(x = s1/1000, y = s2/1000, fill=as.factor(zone))) +
  scale_fill_viridis_d(alpha=0.5) +
  geom_point(data=mysample, mapping = aes(x = s1/1000, y = s2/1000), size = 1.5) +
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  coord_fixed()+
  theme(legend.position = "none")
```

The output data frame of function `cl` has a column named `start`. This is an indicator with value 1 if this point of the cluster is selected first, and 0 otherwise. When in the field it appears that the first selected point of a cluster does not belong to the target population, all other points of that cluster are also discarded. This is to keep the selection probabilities of the clusters exactly proportional to their size. The column `cldraw` is needed in estimation because clusters are selected with replacement. In case a cluster is selected more than once, multiple means of that cluster are used in estimation, see next section.

## Estimation of population parameters {#clustersamplingestimators}

With pps with replacement (ppswr) sampling\index{pps sampling!with replacement (ppswr)} of clusters, the population total can be estimated by the pwr estimator:

\begin{equation}
\hat{t}(z) = \frac{1}{n}\sum_{j \in \mathcal{S}} \frac{t_{j}(z)}{p_{j}} \;,
(\#eq:EstTotalCl1)
\end{equation}

with $n$ the number of cluster draws, $p_j$ the draw-by-draw selection probability of cluster $j$ and $t_j(z)$ the total of cluster $j$:

\begin{equation}
t_j(z) = \sum_{k=1}^{M_j} z_{kj} \;,
(\#eq:clustertotal)
\end{equation}

with $M_j$ the size (number of units) of cluster $j$ and $z_{kj}$ the study variable value of unit $k$ in cluster $j$. 

The draw-by-draw selection probability of a cluster\index{Draw-by-draw selection probability!of a cluster} equals

\begin{equation}
\bar{p}_{j} = \frac{M_j}{M} ;\,
(\#eq:drawbydraw)
\end{equation}

with $M$ the total number of population units (for Voorst $M=7528$). Inserting this in Equation \@ref(eq:EstTotalCl1) yields

\begin{equation}
\hat{t}(z) = \frac{M}{n} \sum_{j \in \mathcal{S}} \frac{t_{j}(z)}{M_{j}} = \frac{M}{n} \sum_{j \in \mathcal{S}} \bar{z}_{j} \;,
(\#eq:EstTotalCl)
\end{equation}

with $\bar{z}_{j}$ the mean of cluster $j$. Note that if a cluster is selected more than once, multiple means of that cluster are in the estimator. 

Dividing this estimator by the total number of population units $M$, gives the estimator of the population mean:

\begin{equation}
\hat{\bar{\bar{z}}}=\frac{1}{n}\sum\limits_{j \in \mathcal{S}} \bar{z}_{j} \;.
(\#eq:EstMeanCl)
\end{equation}

Note the two bars in $\hat{\bar{\bar{z}}}$, indicating that the observations are averaged twice.

The sampling variance of the estimator of the mean with cluster random sampling (clusters selected with probabilities proportional to size with replacement, ppswr) is equal to (Equation 9A.6 in @coc77) 
\begin{equation}
V(\hat{\bar{\bar{z}}})= \frac{1}{d}\sum_{j=1}^N \frac{M_j}{M} (\bar{z}_j-\bar{z})^2  \;,
(\#eq:TrueVarEstMeanCl)
\end{equation}

with $N$ total number of clusters (for Voorst, $N=960$), $\bar{z}_j$ the mean of cluster $j$, and $\bar{z}$ the  population mean. Note that $M_j/M$ is the selection probability of cluster $j$.

This sampling variance can be estimated by (Equation 9A.22 in @coc77) 

\begin{equation}
\widehat{V}\!\left(\hat{\bar{\bar{z}}}\right)=\frac{\widehat{S^2}(\bar{z})}{n} \;,
(\#eq:VarEstMeanCl)
\end{equation}

where $\widehat{S^2}(\bar{z})$ is the estimated variance of cluster means (between cluster variance):

\begin{equation}
\widehat{S^2}(\bar{z}) = \frac{1}{n-1}\sum_{j \in \mathcal{S}}(\bar{z}_{j}-\hat{\bar{z}})^2 \;.
(\#eq:S2EstMeanCl)
\end{equation}

In **R** the population mean and the sampling variance of the estimator of the population means can be estimated as follows.

```{r}
mz_cl <- tapply(
  mysample$z, INDEX=mysample$cldraw, FUN=mean)
mz <- mean(mz_cl)
se_mz <- sqrt(var(mz_cl)/n)
```

The estimated mean equals `r round(mz,3)` and the estimated standard error equals `r round(se_mz,3)`. Note that the size of the clusters (number of units) does not appear in these formulas. This simplicity is due to the fact that the clusters are selected with probabilities proportional to size. The effect of the cluster size on the variance is implicitly accounted for. To understand this, consider that larger clusters result in smaller variance among their means.

The same estimates are obtained with functions `svydesign` and `svymean` of package **survey** [@Lumley2020]. Argument `weights` specifies the  weights of the sampled clusters equal to $M/(M_j\; d)$ (Equation \@ref(eq:EstTotalCl)).

```{r}
library(survey)
M <- nrow(grdVoorst)
mysample$weights <- M/(M_cl[mysample$cluster]*n)
design_cluster <- svydesign(
  id=~cldraw, weights=~weights, data=mysample)
svymean(~z, design_cluster, deff="replace")
```

The design effect\index{Design effect} as estimated from the selected cluster sample is considerably larger than 1. About 3.8 times more sampling points are needed with cluster random sampling compared to simple random sampling to estimate the population mean with the same precision.

A confidence interval estimate of the population mean can be computed with method `confint`. The number of degrees of freedom equals the number of cluster draws minus 1.

```{r}
confint(svymean(
  ~z, design_cluster, df=degf(design_cluster), level=0.95))
```

Figure \@ref(fig:SamplingDistributionCl) shows the sampling distributions of the pwr estimator of the mean with cluster random sampling and of the $\pi$ estimator with simple random sampling, obtained by repeating the random sampling with each design and estimation 10,000 times. The size of the simple random samples is equal to the expected sample size of the cluster random sampling design (rounded to nearest integer).

```{r, echo=FALSE, eval=FALSE}
number_of_samples <- 10000
mz <- v_mz <- mz_SI <- sampleSizes <- numeric(length=number_of_samples)

#compute size of clusters
M_cl <- tapply(grdVoorst$z, INDEX=grdVoorst$cluster, FUN=length)

#compute expected sample size
p <- M_cl/sum(M_cl)
m_n <- round(n*sum(p*M_cl),0)

SI <- function(sframe, n) {
    units <- sample.int(nrow(sframe), size = n, replace = TRUE)
    mysample <- sframe[units,]
    mysample
}

set.seed(314)
for (i in 1:number_of_samples) {
    mysample <- cl_ppswr(sframe=grdVoorst, n=n)
    clusterMeans <- tapply(mysample$z, INDEX=mysample$cldraw, FUN=mean)
    mz[i] <- mean(clusterMeans)
    v_mz[i] <- var(clusterMeans)/n
    sampleSizes[i] <- nrow(mysample)
    mySIsample <- SI(grdVoorst,n=m_n)
    mz_SI[i] <- mean(mySIsample$z)
}

save(mz, mz_SI, v_mz, sampleSizes, m_n, file="results/Cl_Voorst.RData")
```

```{r SamplingDistributionCl, echo=FALSE, fig.asp=.8, fig.cap="Sampling distribution of the pwr estimator of the mean of SOM (g/kg) in Voorst with cluster random sampling, and of the $\\pi$ estimator with simple random sampling, both designs with an (expected) sample size of 49 units."}
load(file="results/Cl_Voorst.RData")
estimates <- data.frame(mz, mz_SI)
names(estimates) <- c("Cl","SI")
df <- estimates %>% pivot_longer(.,cols=c("Cl","SI"))
ggplot(data = df) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=mean(grdVoorst$z), colour="red")+
    scale_x_discrete(name = "Sampling design") +
    scale_y_continuous(name = "Estimated mean SOM")
```

The variance of the 10,000 estimated population means with cluster random sampling equals `r as.character(round(var(estimates$Cl),3))`.  This is considerably larger than with simple random sampling: `r as.character(round(var(estimates$SI),3))`. The large variance is caused by the strong spatial clustering of points. This may save travel time in large study areas, but in Voorst the saved travel time will be very limited, and therefore cluster random sampling in Voorst is not a good idea. The average of the estimated variances with cluster random sampling equals `r as.character(round(mean(v_mz),3))`. The difference with the variance of the 10,000 estimated means is small because the estimator of the variance, Equation \@ref(eq:VarEstMeanCl), is unbiased. Figure \@ref(fig:histsamplesizeCl) shows the sampling distribution of the sample size. The expected sample size can be computed as follows:

```{r}
p <- M_cl/sum(M_cl)
print(m_n <- n*sum(p*M_cl))
```

So the unequal draw-by-draw selection probabilities of the clusters are accounted for in computing the expected sample size\index{Expected sample size}. 

```{r histsamplesizeCl, echo=FALSE, fig.cap="Sampling distribution of sample size with cluster random sampling."}
ggplot() +
  geom_histogram(aes(x=sampleSizes), fill="black", alpha=0.5, breaks= 33.5:60.5, colour="black") +
  scale_y_continuous(name = "Frequency") +
  scale_x_continuous(name = "Sample size")
```

#### Exercises {-}

1. Write an **R** script to compute the true sampling variance of the estimator of the population mean of SOM in Voorst, for cluster random sampling, clusters selected with probabilities proportional to their size and with replacement, $n = 6$, see Equation \@ref(eq:TrueVarEstMeanCl). Compare the sampling variance for cluster random sampling with the sampling variance for simple random sampling with a sample size equal to the expected sample size of cluster random sampling.  
2. As an alternative we may select three times a transect, using three 2 km $\times$ 1 km zones obtained by joining two neighbouring 1 km $\times$ 1 km zones of Figure \@ref(fig:ClVoorst). Do you expect that the sampling variance of the estimator of the  mean is equal, larger or smaller than that of the sampling design with six transects of "half the length"?   

## Clusters selected with probabilities proportional to size, without replacement

In the previous section the clusters were selected with probabilities proportional to size and with replacement (ppswr). The advantage of with replacement sampling is that this keeps the statistical inference simple, more specifically the estimation of the standard error of the estimated population mean. However, in sampling from finite populations, cluster sampling with replacement is less efficient than cluster sampling without replacement sampling, especially with large sampling fractions of clusters, i.e. if $1-n/N$ is small. If a cluster is selected more than once, there is less information about the population mean in this sample than in a sample with all clusters different. Selection of clusters with probabilities proportional to size  without replacement (ppswor) is not straightforward\index{pps sampling!without replacement (ppswor)}. The problem is the computation of the inclusion probabilities of the clusters. After we have selected a first cluster, we must adapt the sum of the sizes of the $N-1$ remaining clusters, and recompute the selection probabilities  of the remaining clusters in the second draw, etc. Section 6.4 of @loh99 nicely describes how the inclusion probabilities of the $N$ clusters in a cluster random sample of size two, selected by ppswor can be computed. Many algorithms have been developed for ppswor sampling, see @Tille2006 for an overview, and many of them are implemented in package **sampling** [@Tille2016]. In the next code chunk function `UPpivotal` is used to select a cluster random sample with ppswor. For an explanation of this algorithm, see Section \@ref(pivotalmethod).

```{r}
library(sampling)
n <- 6
pi <- n*M_cl/M
set.seed(314)
eps <- 1e-6
sampleind <- UPpivotal(pik=pi, eps=eps)
clusters <- sort(unique(grdVoorst$cluster))
sampledclusters <- clusters[sampleind==1]
mysample <- grdVoorst[grdVoorst$cluster %in% sampledclusters,]
```

The population mean can be estimated with function `svymean` of package **survey** [@Lumley2020]. Estimation of the sampling variance in pps sampling of clusters without replacement is difficult^[The problem is the computation of the joint inclusion probabilities of pairs of points.]. A simple solution is to treat the cluster sample as a ppswr sample, and to estimate the variance with Equation \@ref(eq:VarEstMeanCl). With small sampling fractions this variance approximation is fine: the overestimation of the variance is negligible. For larger sampling fractions various alternative variance approximations are developed, see @Berger2004 for details. One of the methods is Brewer's method\index{Brewer's variance estimator}, which is implemented in function `svydesign`.

```{r}
mysample$pi <- n*M_cl[mysample$cluster]/M
design_clppswor <- svydesign(
  id=~cluster, data=mysample, pps="brewer", fpc=~pi)
svymean(~z,design_clppswor)
```

Another variance estimator implemented in function `svydesign`  is the Hartley-Rao estimator\index{Hartley-Rao's variance estimator}. The two estimated standard errors are nearly equal.

```{r}
p2sum<-sum((n*M_cl[mysample$cluster]/M)^2)/n
design_hr <- svydesign(
  id=~cluster,  data=mysample, pps=HR(p2sum), fpc=~pi)
svymean(~z, design_hr)
```

## Simple random sampling of clusters

Suppose the clusters have unequal size, but we do not know the size of the clusters, so that we cannot select the clusters with probabilities proportional to their size, or for some other reason we selected the clusters by simple random sampling without replacement. The inclusion probability of a cluster equals $n/N$ with $n$ the number of selected clusters and $N$ the total number of clusters in the population. This  yields the following $\pi$ estimator of the population total:

\begin{equation}
\hat{t}(z) = \frac{N}{n} \sum_{j \in \mathcal{S}} t_{j}(z)\;,
(\#eq:EstTotalClEqual)
\end{equation}

The population mean can be estimated by dividing this estimator of the population total by the total number of units in the population $M$:

\begin{equation}
\hat{\bar{\bar{z}}}_{\pi}(z) = \frac{\hat{t}(z)}{M}\;.
(\#eq:EstMeanHTClEqual)
\end{equation}

Alternatively, we may estimate the population mean by dividing the estimate of the population total by the *estimated* population size:

\begin{equation}
\widehat{M} = \sum_{j \in \mathcal{S}} \frac{M_{j}}{\pi_{j}} = \frac{N}{n} \sum_{j \in \mathcal{S}} M_{j} \;.
(\#eq:EstPopulatonSizeClEqual)
\end{equation}

This leads to the ratio estimator\index{Ratio estimator} of the population mean:

\begin{equation}
\hat{\bar{\bar{z}}}_{\text{ratio}}(z) = \frac{\hat{t}(z)}{\widehat{M}} \;.
(\#eq:EstMeanRatioClEqual)
\end{equation}

The $\pi$ estimator and ratio estimator are equal when the clusters are selected with probabilities proportional to size. This is because the estimated population size is equal to the true population size.

```{r}
print(M_HT <- sum(1/mysample$pi))
```

However, when clusters of different size are selected with equal probabilities, the two estimators are different. This is shown below. Six clusters are selected by simple random sampling without replacement.

```{r}
set.seed(314)
clusters <- sort(unique(grdVoorst$cluster))
units_cl <- sample.int(length(clusters), size=n, replace=FALSE) 
sampledclusters <- clusters[units_cl]
mysample <- grdVoorst[grdVoorst$cluster %in% sampledclusters,]
```

The $\pi$ estimator and ratio estimator of the population mean are computed for the selected sample.

```{r}
N <- length(clusters)
mysample$pi <- n/N
tz_HT <- sum(mysample$z/mysample$pi)
mz_HT <- tz_HT/M
M_HT <- sum(1/mysample$pi)
mz_ratio <- tz_HT/M_HT
```

The $\pi$ estimate equals `r round(mz_HT,3)`, and the ratio estimate equals `r round(mz_ratio,3)`. The $\pi$ estimator of the population mean can also be computed by first computing totals of clusters, see Equation \@ref(eq:EstTotalClEqual). 

```{r}
tz_cluster <- tapply(mysample$z, INDEX=mysample$cluster, FUN=sum)
pi_cluster <- n/N
tz_HT <- sum(tz_cluster/pi_cluster)
print(mz_HT <- tz_HT/M)
```

The variance of the $\pi$ estimator of the population mean can be estimated by first estimating the variance of the estimator of the  total, and dividing this variance by the squared number of population units:

\begin{align}
\widehat{V}(\hat{t}(z)) = N^2\left(1-\frac{n}{N}\right)\frac{\widehat{S^2}(t(z))}{n} \notag \\
\widehat{V}(\hat{\bar{\bar{z}}}) = \frac{1}{M^2} \widehat{V}(\hat{t}(z)) \;.
(\#eq:EstVarTotalandMeanHTClequal)
\end{align}

```{r}
fpc <- 1-n/N
v_tz <- N^2*fpc*var(tz_cluster)/n
se_mz_HT <- sqrt(v_tz/M^2)
```

The estimated standard error equals `r round(se_mz_HT,3)`. To compute the variance of the ratio estimator of the population mean we first compute residuals of cluster totals:

\begin{equation}
e_j = t_j(z)-\hat{b}M_j \;,
(\#eq:residualsclustertotals)
\end{equation}

with $\hat{b}$ the ratio of the estimated population mean of the cluster totals to the estimated population mean of the cluster sizes:

\begin{equation}
\hat{b}=\frac{\frac{1}{n}\sum_{j \in \mathcal{S}} t_{j}}{\frac{1}{n}\sum_{j \in \mathcal{S}} M_{j}} \;.
(\#eq:ratioclustertotalclustersize)
\end{equation}

The variance of the ratio estimator of the population mean can be estimated by

\begin{equation}
\hat{V}(\hat{\bar{\bar{z}}}_{\text{ratio}})=\left(1-\frac{n}{N}\right)\frac{1}{(\frac{1}{n}\sum_{j \in \mathcal{S}} M_{j})^2}\frac{\widehat{S^2}_e}{n} \;,
(\#eq:varratioestimatormeanCl)
\end{equation}

with $\widehat{S^2}_e$ the estimated variance of the residuals.


```{r}
m_M_cl <- mean(M_cl[unique(mysample$cluster)])
b <- mean(tz_cluster)/m_M_cl
e_cl <- tz_cluster - 
  b*M_cl[sort(unique(mysample$cluster))]
S2e <- var(e_cl)
print(se_mz_ratio <- sqrt(fpc*1/m_M_cl^2*S2e/n))
```

The ratio estimate can also be computed with function `svymean` of package **survey**, which also provides an estimate of the standard error of the estimated mean.

```{r}
design_SIC <- svydesign(
  id=~cluster, probs=~pi, fpc=~pi, data=mysample)
svymean(~z, design_SIC)
```



## Stratified cluster random sampling {#StratifiedCl}

The basic sampling designs stratified random sampling (Chapter \@ref(STSI)) and cluster random sampling can be combined into stratified cluster random sampling\index{Stratified random sampling!stratified cluster random sampling}. So instead of selecting simple random samples from the strata, within each stratum clusters are randomly selected. Figure \@ref(fig:STCl) shows a stratified cluster random sample from Voorst. The strata consist of three 2 km $\times$ 1 km zones, obtained by joining two neighbouring 1 km $\times$ 1 km zones (Figure \@ref(fig:ClVoorst)). The clusters are the same as before, i.e. E-W oriented transects within 1 km $\times$ 1 km zones, with a inter-point spacing of 100 m.  Within each stratum two times a cluster is selected by ppswr.  The stratification avoids the clustering of the selected transects in one part of the study area. Compared to (unstratified) cluster random sampling, the geographical spreading of the clusters is improved, which may lead to an increase of the precision of the estimated population mean. In Figure \@ref(fig:STCl) in the most western stratum the two selected transects are in the same  1 km $\times$ 1 km zone. The alternative would be to use the six zones as strata, leading to an improved spreading of the clusters, but there is also a downside with this design, see Exercise 3.

```{r}
grdVoorst$zonestratum <- as.factor(grdVoorst$zone)
levels(grdVoorst$zonestratum) <- rep(c("a","b","c"), each=2)
n_h <- c(2,2,2)
set.seed(324)
stratumlabels <- unique(grdVoorst$zonestratum)
mysample <- NULL
for (i in 1:3) {
  grd_h <- grdVoorst[grdVoorst$zonestratum==stratumlabels[i],]
  mysample_h <- cl_ppswr(sframe=grd_h, n=n_h[i])
  mysample <- rbind(mysample, mysample_h)
}
```

```{r STCl, echo=FALSE, out.width='100%', fig.cap="Stratified cluster random sample from Voorst, with three strata."}
ggplot(grdVoorst) +        
  geom_raster(mapping = aes(x = s1/1000, y = s2/1000, fill=zonestratum)) +
  scale_fill_viridis_d(alpha=0.5) +
  geom_point(data=mysample, mapping = aes(x = s1/1000, y = s2/1000), size = 1.5) +
  geom_vline(xintercept=s1bnd/1000)+
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  coord_fixed()+
  theme(legend.position = "none")
```

The population mean is estimated by first estimating the stratum means using Equation \@ref(eq:EstMeanCl), followed by computing the weighted average of the estimated stratum means using Equation \@ref(eq:HTMeanSTSI2). The variance of the estimator of the  population mean is estimated in the same way, by first estimating the variance of the estimator of the  stratum means using Equation \@ref(eq:VarEstMeanCl), followed by computing the weighted average of the estimated variances of the estimated stratum means (Equation \@ref(eq:EstVarMeanSTSI)).

```{r}
mz_h <- v_mz_h <- numeric(length=3)
for (i in 1:3) {
  units <- which(mysample$zonestratum==letters[i])
  mysample_h <- mysample[units,]
  mz_cl <- tapply(mysample_h$z,
                  INDEX=mysample_h$cldraw, FUN=mean)
  mz_h[i] <- mean(mz_cl)
  v_mz_h[i] <- var(mz_cl)/n_h[i]
}
M_h <- tapply(
  grdVoorst$z, INDEX=grdVoorst$zonestratum, FUN=length)
w_h <- M_h/M
mz <- sum(w_h*mz_h)
se_mz <- sqrt(sum(w_h^2*v_mz_h))
```

The estimated mean equals `r round(mz,3)`, and the estimated standard error equals `r round(se_mz,3)`. The same estimates are obtained with function `svymean`. Weights for the clusters are computed as before, but now at the level of the strata. Note the argument `nest=TRUE`, which means that the clusters are nested within the strata.

```{r}
mysample$weights <- M_h[mysample$zonestratum]/
  (M_cl[mysample$cluster]*n_h[mysample$zonestratum])
design_strcluster <- svydesign(
  id=~cldraw, strata=~zonestratum, weights=~weights,
  data=mysample, nest=TRUE)
svymean(~z,design_strcluster)
```

#### Exercises {-}

3. Why is it attractive in stratified random cluster sampling to select at least two clusters per stratum?  

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:06-Cluster.Rmd-->

# Two-stage cluster random sampling {#Twostage}

As opposed to cluster random sampling in which all population units of cluster are observed (Chapter \@ref(Cl)), in two-stage cluster random sampling\index{Two-stage cluster random sampling} not all sampling units of the selected clusters are observed, but only some of them. In two-stage cluster random sampling the clusters will generally be contiguous groups of units, for instance all points in a map polygon (the polygons on the map are the clusters), whereas in single-stage cluster random sampling the clusters generally are non-contiguous. The sampling units to be observed are selected by random subsampling of the randomly selected clusters. In two-stage cluster sampling the clusters are commonly referred to as primary sampling units\index{Primary sampling units} (psu's) or shortly primary units (pu's), and the units selected in the second stage as the secondary sampling units\index{Secondary sampling units} (ssu's) or secondary units (su's).

As with cluster random sampling, two-stage cluster random sampling may lead to a strong spatial clustering of the selected sampling units (ssu's) in the study area. This may save considerable time for fieldwork, and more population units can be observed for the same budget. However, due to the spatial clustering the estimates will generally be less precise compared to samples of the same size selected by a design that leads to a much better spreading of the sampling units throughout the study area, such as systematic random sampling.

In two-stage cluster random sampling in principle any type of sampling design can be used at the two stages, leading to numerous combinations. An example is (SI,SI), in which both psu's and ssu's are selected by simple random sampling.

Commonly the psu's have unequal size, i.e. the number of ssu's (finite population) or the area (infinite population) are not equal for all psu's. Think for instance of the agricultural fields, forest stands, lakes, river sections etc., in an area. If the psu's are of unequal size, then psu's can best be selected with probabilities proportional to their size (pps). Recall that in (one-stage) cluster random sampling I also recommended to select the clusters with probabilities proportional to their size, see Chapter \@ref(Cl). If the total of the study variable of a psu is proportional  to its size, then pps sampling leads to more precise estimates compared to simple random sampling of psu's. Also, with pps sampling of psu's the estimation of means or totals and of their sampling variances is much simpler compared to selection with equal probabilities. Implementation of selection with probabilities proportional to size is easiest when units are replaced (pps with replacement, ppswr)\index{pps sampling!with replacement (ppswr)}. This implies that a psu might be selected more than once, especially if the total number of psu's in the population is small compared to the number of psu draws (large sampling fraction in first stage).
 
Using a list as a sampling frame, the following algorithm can be used to select $n$ times a psu by ppswr from a total of $N$ psu's in the population:

1. Select randomly one ssu from the list with $M=\sum_{j=1}^N M_j$ ssu's ($M_j$ is number of ssu's of psu $j$), and determine the psu of the selected ssu.  
2. Repeat step 1 until $n$ selections have been made.  

In the first stage a ssu is selected in order to select a psu. This may seem unnecessary complicated. The reason for this is that this procedure automatically adjusts for the size of the psu's (number of ssu's within a psu), i.e. a psu is selected with probability proportional to its size. In the second stage, a *pre-determined* number of secondary sampling units, $m_{j}$, is selected every time psu $j$ is selected. Predetermined means that it is not allowed to decide on the secondary sample sizes (number of ssu's) per selected psu after the selection of the psu's. Note that the ssu selected in the first step of the two algorithms primarily serve to identify the psu, but these ssu's can also be used as selected ssu's.   

The selection of a two-stage cluster random sample is illustrated again with Voorst. Twenty-four blocks of 0.5 km $\times$ 0.5 km are constructed that serve as psu's. Note that due to built-up areas, roads etc., these psu's have unequal size, i.e. the number of secondary units (pixels) within the psu's varies among the psu's. 

```{r}
load("data/Voorst.RData")
w <- 500 #width of psu's
s1bnd <- seq(from=min(grdVoorst$s1)+w, to=min(grdVoorst$s1)+(11*w), by=w)+12.5
s1f <- findInterval(grdVoorst$s1,s1bnd)
s2bnd <- min(grdVoorst$s2)+w+12.5
s2f <- findInterval(grdVoorst$s2, s2bnd)
grdVoorst$psu <- as.character(interaction(s1f, s2f))
```

To select a two-stage cluster random sample a function is defined.

```{r}
twostage <- function(sframe, psu, n, m) {
  units <- sample.int(nrow(sframe), size=n, replace=TRUE)
  mypsusample <- sframe[units,psu]
  ssunits <- NULL
  for (psunit in mypsusample) {
    ssunit <- sample(
      x = which(sframe[,psu]==psunit), size=m, replace=TRUE)
    ssunits <- c(ssunits, ssunit)
  }
  psudraw <- rep(c(1:n), each=m)
  mysample <- data.frame(ssunits,sframe[ssunits,], psudraw)
  mysample
}
```

Note that both the primary and secondary sampling units are selected with replacement. The secondary units are selected by simple random sampling with replacement because the actual population is infinite. The infinite population is discretised by a finite number of grid nodes (centers of grid cells). If a grid node is selected, one point is selected fully randomly from the associated grid cell. This is done with function `jitter`. In every grid cell there is an infinite number of points, so we must select the grid cells with replacement. If a grid node is selected more than once, more than one point is selected from that grid cell. The column `psudraw` in the output data frame of function `twostage` is needed in estimation because psu's are selected with replacement. In case a psu is selected more than once, multiple estimates of the mean of that psu are used in estimation, see next section.

The function `twostage` is used to select four times a psu ($n=4$), with probabilities proportional to size and with replacement (ppswr). The second stage sample size $m_i$ equals 10 for all psu's. These secondary sampling units (ssu's) are selected by simple random sampling. 

```{r}
n <- 4
m <- 10
set.seed(314)
mysample <- twostage(sframe=grdVoorst, psu="psu", n=n, m=m)
cellsize <- 25
mysample$s1 <- jitter(mysample$s1, amount=cellsize/2)
mysample$s2 <- jitter(mysample$s2, amount=cellsize/2)
```

Figure \@ref(fig:TwostageVoorst) shows the selected sample.

```{r TwostageVoorst, echo=FALSE, out.width='100%', fig.cap="Two-stage cluster random sample from Voorst. Four times a psu is selected by ppswr. Each time a psu is selected, ten points are selected from that psu."}
ggplot(data=grdVoorst) +        
  geom_raster(mapping = aes(x = s1/1000, y = s2/1000, fill=as.factor(psu))) +
  scale_fill_viridis_d(alpha=0.5) +
  geom_point(data=mysample, mapping = aes(x=s1/1000, y = s2/1000), size = 2) +
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  coord_fixed()+
  theme(legend.position = "none")
```

## Estimation of population parameters {#twostagesamplingestimators}

The population total can be estimated by substituting the estimated cluster (primary unit) totals in Equation \@ref(eq:EstTotalCl). This yields the following estimator for the population total:

\begin{equation}
\hat{t}(z) = \frac{M}{n} \sum_{j \in \mathcal{S}} \frac{\hat{t}_{j}(z)}{M_{j}} = \frac{M}{n} \sum_{j \in \mathcal{S}} \hat{\bar{z}}_{j} \;,
(\#eq:EstTotalTwostage)
\end{equation}

where $n$ is the number of psu selections and $M_{j}$ is total number of ssu's in psu $j$. This shows that the mean of cluster $j$, $\bar{z}_j$, is replaced by the estimated mean of psu $j$, $\hat{\bar{z}}_j$. Dividing this estimator by the total number of population units $M$ gives the pwr  estimator of the population mean:

\begin{equation}
\hat{\bar{\bar{z}}}=
\frac{1}{n}\sum\limits_{j \in \mathcal{S}}\hat{\bar{z}}_{j} \;,
(\#eq:EstMeanTwostage)
\end{equation}

with $\hat{\bar{z}}_{j}$ the estimated mean of the psu $j$. With simple random sampling of ssu's this mean can be estimated by the sample mean of this psu. Note the two bars $\hat{\bar{\bar{z}}}$, indicating that the population mean is estimated as the mean of estimated primary unit means. When $m_i$ is equal for all psu's the sampling design is self-weighting\index{Self-weighting sampling design}, i.e. the average of $z$ over all selected secondary units is an unbiased estimator of the population mean.

The sampling variance of the estimator of the mean with two-stage cluster random sampling (primary units selected with probabilities proportional to size with replacement, secondary units by simple random sampling (with replacement in case of finite populations) and $m_j = m, j = 1, \dots, N$) is equal to (@coc77, Equation 11.33)^[The equation in Cochran (1977) is the variance estimator for the population total. In Exercise 5 you are asked to derive the estimator of the variance of the estimator of the population mean from the estimator of the variance of the estimator of the population total.]

\begin{equation}
V(\hat{\bar{\bar{z}}}) = \frac{S^2_{\mathrm{b}}}{n} + \frac{S^2_{\mathrm{w}}}{n\;m} \;,
(\#eq:TrueVarEstMeanTwostage)
\end{equation}

with

\begin{equation}
S^2_{\mathrm{b}}=\sum_{j=1}^N p_j\left(\bar{z}_j-\bar{z}\right)^2\;,
(\#eq:PooledBetweenClusterVariance)
\end{equation}

and

\begin{equation}
S^2_{\mathrm{w}}=\sum_{j=1}^N p_j S^2_j
(\#eq:PooledWithinClusterVariance)
\end{equation}

with $N$ the total number of psu's in the population, $p_j=M_j/M$ the draw-by-draw selection probability of psu $j$\index{Draw-by-draw selection probability!of a primary sampling unit}, $\bar{z}_j$ the mean of psu $j$, $\bar{z}$ the population mean of $z$, and $S^2_j$ the variance of $z$ within primary unit $j$:

\begin{equation}
S^2_j = \frac{1}{M_j} \sum_{k=1}^{M_j} (z_{kj}-\bar{z}_j)^2 \;.
(\#eq:WithinClusterVariance)
\end{equation}

Note that the first term of Equation \@ref(eq:TrueVarEstMeanTwostage) is equal to the variance of Equation \@ref(eq:TrueVarEstMeanCl). This variance component accounts for the variance of the true primary unit means within the population. The second variance component quantifies our additional uncertainty about the population mean, as we do not observe all secondary units of the selected primary units, but only a subset (sample) of these units.

The sampling variance of the estimator of the population mean can simply be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{\bar{z}}}\right)=\frac{\widehat{S^2}(\hat{\bar{z}})}{n}  \;,
(\#eq:VarEstMeanTwostage)
\end{equation}

with $\widehat{S^2}(\hat{\bar{z}})$ the estimated variance of the *estimated* primary unit means:

\begin{equation}
\widehat{S^2}(\hat{\bar{z}}) = \frac{1}{n-1}\sum_{j \in \mathcal{S}}(\hat{\bar{z}}_{j}-\hat{\bar{\bar{z}}})^2 \;,
(\#eq:S2psuMeans)
\end{equation}

with $\hat{\bar{z}}_{j}$ the estimated mean of psu $j$, and $\hat{\bar{\bar{z}}}$ the estimated population mean (Equation \@ref(eq:EstMeanTwostage)). Note that neither the sizes of the psu's, $M_j$, nor the secondary sample sizes $m_{j}$ occur in these formulas. This simplicity is due to the fact that the psu's are selected with replacement and with probabilities proportional to size. The effect of the secondary sample sizes on the variance is implicitly accounted for. To understand this, note that the larger $m_{j}$, the less variable $\hat{\bar{z}}_{j}$, and the smaller its contribution to the variance.

Let us assume a linear model for the total costs: $C = c_1d + c_2n\;m$, with $c_1$ the cost per primary unit and $c_2$ the cost per secondary unit. We want to minimise the total costs, under the constraint that the variance of the estimator of the population mean may not exceed $V_{\mathrm{max}}$. The total costs can then be minimised by selecting [@gru06]

\begin{equation}
n=\frac{1}{V_{\mathrm{max}}}\left(S_{\mathrm{w}}S_{\mathrm{b}}\sqrt{\frac{c_2}{c_1}}+S^2_{\mathrm{b}}\right)
(\#eq:nopt)
\end{equation}

primary units, and 

\begin{equation}
m=\frac{S_{\mathrm{w}}}{S_{\mathrm{b}}}\sqrt{\frac{c_1}{c_2}}
(\#eq:mopt)
\end{equation}

secondary units per primary unit.

Conversely, given a budget $C_{\mathrm{max}}$, the optimal number of primary unit selections\index{Optimal sample size in two-stage cluster random sampling} can be computed with [@gru06]

\begin{equation}
n=\frac{C_{\mathrm{max}}S_{\mathrm{b}}}{S_{\mathrm{w}}\sqrt{c_1c_2}+S_{\mathrm{b}}c_1}\;,
(\#eq:nopt2)
\end{equation}

and $m$ as above.

In **R** the population mean and the sampling variance of the estimator of the mean can be estimated as follows.

```{r}
mz_psu <- tapply(mysample$z, INDEX=mysample$psudraw, FUN=mean)
mz <- mean(mz_psu)
se_mz <- sqrt(var(mz_psu)/n)
```

The estimated mean equals `r round(mz,3)` and the estimated standard error equals `r round(se_mz,3)`. The sampling design is self-weighting, and so the estimated mean is equal to the sample mean.

```{r}
print(mean(mysample$z))
```

The same estimate is obtained with functions `svydesign` and `svymean` of package **survey** [@Lumley2020]. The estimator of the population total can be written as a weighted sum of the observations with all weights equal to $M/(d\;m$. These weights are assigned to argument `weight`. 

```{r}
library(survey)
M <- nrow(grdVoorst)
mysample$weights <- M/(n*m)
design_2stage <- svydesign(
  id=~psudraw+ssunits, weight=~weights, data=mysample)
svymean(~z, design_2stage, deff="replace")
```

Similar to (one-stage) cluster random sampling the estimated design effect\index{Design effect} is much larger than 1.

A confidence interval estimate of the population mean can be computed with method `confint`. The number of degrees of freedom equals the number of psu draws minus one.

```{r}
confint(svymean(
  ~z, design_2stage, df=degf(design_2stage), level=0.95))
```

Figure \@ref(fig:SamplingDistributionTwostage) shows the sampling distributions of the pwr estimator of the population mean with two-stage cluster random sampling and of the $\pi$ estimator with simple random sampling from Voorst, obtained by repeating the random sampling with each design and estimation 10,000 times. For simple random sampling the sample size is equal to $n \times m$. 

```{r, echo = FALSE, eval=FALSE}
number_of_samples <- 10000
mz <- v_mz <- mz_SI <- numeric(length=number_of_samples)

set.seed(31415)
SI <- function(sframe, n) {
    units <- sample.int(nrow(sframe), size=n, replace=FALSE)
    mysample <- sframe[units,]
    mysample
}

for (i in 1:number_of_samples) {
  mysample <- twostage(grdVoorst, "psu", n, m)
  psuMeans <- tapply(mysample$z, INDEX=mysample$psudraw, FUN=mean)
  mz[i] <- mean(psuMeans, na.rm=TRUE)
  v_mz[i] <- var(psuMeans, na.rm=TRUE)/n
  mySIsample <- SI(grdVoorst, n=n*m)
  mz_SI[i] <- mean(mySIsample$z)
}

save(mz, mz_SI, v_mz, file="results/Twostage_Voorst.RData")
```

```{r SamplingDistributionTwostage, echo=FALSE, fig.asp=.8, fig.cap="Sampling distribution of pwr estimator of mean of SOM (g/kg) in Voorst with two-stage random sampling, and of the $\\pi$ estimator with simple random sampling, bot design with a sample size of 40 units."}
load(file="results/Twostage_Voorst.RData")
estimates <- data.frame(mz, mz_SI)
names(estimates) <- c("Twostage","SI")
df <- estimates %>% pivot_longer(.,cols=c("Twostage","SI"))
df$name <- factor(df$name, levels=c("Twostage","SI"), ordered=TRUE )
ggplot(data = df) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=mean(grdVoorst$z), colour="red")+
    scale_x_discrete(name = "Sampling design") +
    scale_y_continuous(name = "Estimated mean SOM")
v_mz_sim <- var(mz)
m_vmz_sim <- mean(v_mz)
v_mz_SI_sim <- var(mz_SI)
```

The variance of the 10,000 means with two-stage cluster random sampling equals `r as.character(round(var(mz),3))`. This is considerably larger than with simple random sampling: `r as.character(round(var(mz_SI),3))`. The average of the estimated variances equals `r as.character(round(mean(v_mz),3))`. 

Optimal sample sizes for two-stage cluster random sampling (ppswr in first stage, simple random sampling without replacement in second stage) can be computed with function `clusOpt2` of **R** package **PracTools** (@PracTools, @Vaillant2018). This function requires as input various variance measures, which can be computed with function `BW2stagePPS` in case the study variable is known for the whole population, or estimated from a sample with function `BW2stagePPSe`. This is left as an exercise (Exercise 5).

#### Exercises {-}

1. Write an **R** script to compute the true sampling variance of the estimator of the population mean for $n=4$ and $m=10$, see Equation \@ref(eq:TrueVarEstMeanTwostage).   
2. Do you expect that the standard error of the estimated population mean with ten psu draws ($n=10$) and four ssu's per psu draw ($m=4$) are larger or smaller than with four psu draws ($n=4$) and ten ssu's per psu draw ($m=10$)?  
3. Compute the optimal sample sizes $n$ and $m$ for a maximum variance of the estimator of the population mean of 1, $c_1=2$ and $c_2=1$ monetary unit, see Equations \@ref(eq:nopt) and \@ref(eq:mopt).  
4. Compute the optimal sample sizes $n$ and $m$ for a budget of 100 monetary units,  $c_1=2$ and $c_2=1$ monetary units, see Equations \@ref(eq:nopt2) and \@ref(eq:mopt).  
5. Use function `clusOpt2` of **R** package **PracTools** to compute optimal sample sizes given the precision requirement for the estimated population mean of Exercise 3 and given the budget of Exercise 4. First use function `BW2stagePPS` to compute the variance measures needed as input for function ` optClus2`. Note that the precision requirement of function `clusOpt2` is the coefficient of variation of the estimated population total, i.e. the standard deviation of the estimated population total divided by the population total. Compute this coefficient of variation from the maximum variance of the estimator of the population mean used in Exercise 3.  
6. Derive the variance estimator for the estimated population mean, Equation \@ref(eq:TrueVarEstMeanTwostage), from the variance estimator of the estimated population total [@coc77]: 

\begin{equation}
V(\hat{t}(z)) = \frac{1}{n} \sum_{j=1}^N p_j\left(\frac{t_j(z)}{p_j}-t(z)\right)^2 + \frac{1}{n} \sum_{j=1}^N \frac{M_j^2 (1-f_{2j})S^2_j}{m_j p_j}  \;,
(\#eq:EstVarTotalTwostageCochran)
\end{equation}

with $\hat{t}(z)$ and $t(z)$ the estimated and true population total of $z$, respectively, $t_j(z)$ the total of psu $j$, and $p_j = M_j/M$. Use $m_j = m, j = 1, \dots, N$, and $f_{2j}=0$, i.e. sampling from infinite population, or sampling of ssu's within psu's by simple random sampling *with* replacement from finite population.

## Primary sampling units selected with probabilities proportional to size, without replacement

Similar to cluster random sampling, we may prefer to select the primary sampling units without replacement\index{pps sampling!without replacement (ppswor)}. This leads to less strong spatial clustering of the sampling points, especially with large sampling fractions of primary sampling units. The psu's are selected with function `UPpivotal` of package **sampling** [@Tille2016], see Section \@ref(pivotalmethod). The second stage sample of secondary sampling units is selected with function `strata` of the same package, using the psu's as strata.

```{r}
library(sampling)
M_psu <- tapply(grdVoorst$z, INDEX=grdVoorst$psu, FUN=length)
n <- 6
pi <- n*M_psu/M
set.seed(314)
sampleind <- UPpivotal(pik=pi, eps=1e-6)
psus <- sort(unique(grdVoorst$psu))
sampledpsus <- psus[sampleind==1]
mysample_stage1 <- grdVoorst[grdVoorst$psu %in% sampledpsus,]
units <- sampling::strata(
  mysample_stage1, stratanames="psu",
  size=rep(m,n), method="srswor")
mysample <- getdata(mysample_stage1, units)
mysample$ssunits <- units$ID_unit
mysample$pi <- n*m/M
print(mean_HT <- sum(mysample$z/mysample$pi)/M)
```

The population mean can be estimated with function `svymean` of package **survey** [@Lumley2020]. A simple solution is to treat the two-stage cluster random sample as a pps sample with replacement, and to estimate the variance with Equation \@ref(eq:VarEstMeanTwostage). With small sampling fractions of psu's the overestimation of the variance is negligible. As in cluster random sampling without replacement, the variance is approximated with Brewer's method, see @Berger2004 (option 2)\index{Brewer's variance estimator}.

```{r}
mysample$fpc1 <- n*M_psu[mysample$psu]/M
mysample$fpc2 <- m/M_psu[mysample$psu]
design_2stageppswor <- svydesign(
  id=~psu+ssunits, data=mysample, pps="brewer", fpc=~fpc1+fpc2)
svymean(~z,design_2stageppswor)
```


## Simple random sampling of primary sampling units

Suppose the primary sampling units are for some reason not selected  with probabilities proportional to their size, but by simple random sampling without replacement. The inclusion probability of the psu's then equal $\pi_j=n/N, j = 1, \dots, N$, and the population total can be estimated by (compare with Equation \@ref(eq:EstTotalClEqual))

\begin{equation}
\hat{t}(z) =  \sum_{j=1}^n \frac{\hat{t}_j(z)}{\pi_j} = \frac{N}{n} \sum_{j=1}^n \hat{t}_j(z)\;,
(\#eq:EstTotalTwostageEqual)
\end{equation}

with $\hat{t}_j(z)$ an estimator of the total of psu $j$. The population mean can be estimated by dividing this estimator by the population size $M$. 

Alternatively, we may estimate the population mean by dividing the estimate of the population total by the *estimated* population size. The $\pi$ estimator of the population size for two-stage cluster sampling is equal to that for cluster random sampling,  see Equation \@ref(eq:EstPopulatonSizeClEqual). The $\pi$ estimator and ratio estimator are equal when the psu's are selected with probabilities proportional to size and with replacement, but not so when the psu's of different size are selected with equal probabilities. This is shown below. First a sample is selected by selecting both psu's and ssu's by simple random sampling without replacement. 

```{r}
library(sampling)
set.seed(314)
psus <- sort(unique(grdVoorst$psu))
ids_psu <- sample.int(length(psus), size=n, replace=FALSE) 
sampledpsus <- psus[ids_psu]
mysample_stage1 <- grdVoorst[grdVoorst$psu %in% sampledpsus,]
units <- sampling::strata(
  mysample_stage1, stratanames="psu",
  size=rep(m,n), method="srswor")
mysample <- getdata(mysample_stage1, units)
mysample$ssunits <- units$ID_unit
```

The population mean is estimated by the $\pi$ estimator and the ratio estimator.

```{r}
N <- length(unique(grdVoorst$psu))
M_psu <- tapply(grdVoorst$z, INDEX=grdVoorst$psu, FUN=length)
pi_psu <- n/N
pi_ssu <- m/M_psu[mysample$psu]
mysample$pi <- pi_psu*pi_ssu
z_piexpanded <- with(mysample,z/pi)
tz_HT <- sum(z_piexpanded)
mz_HT <- tz_HT/M
M_HT <- sum(1/mysample$pi)
mz_ratio <- tz_HT/M_HT
```

The $\pi$ estimate equals `r round(mz_HT,3)` and the ratio estimate equals `r round(mz_ratio,3)`. The $\pi$ estimator of the population mean can also be computed by first estimating totals of psu's, see Equation \@ref(eq:EstTotalTwostageEqual). 

```{r}
tz_psu <- tapply(mysample$z/pi_ssu, INDEX=mysample$psu, FUN=sum)
tz_HT <- sum(tz_psu/pi_psu)
(mz_HT <- tz_HT/M)
```

The variance of the $\pi$ estimator of the population mean can be estimated by first estimating the variance of the estimator of the psu totals, and dividing this variance by the squared number of population units:

\begin{eqnarray}
\widehat{V}(\hat{t}(z)) &=& N^2\left(1-\frac{n}{N}\right)\frac{\widehat{S^2}(\hat{t}_i(z))}{n} \notag \\
\widehat{V}(\hat{\bar{\bar{z}}}) &=& \frac{1}{M^2} \widehat{V}(\hat{t}(z))\;.
(\#eq:EstVarTotalandMeanHTTwostageSI)
\end{eqnarray}


```{r}
fpc <- 1-n/N
v_tz <- N^2*fpc*var(tz_psu)/n
(se_mz_HT <- sqrt(v_tz/M^2))
```

The ratio estimator of the population mean and its standard error can be computed with function `svymean` of package **survey**.

```{r}
mysample$fpc1 <- N
mysample$fpc2 <- M_psu[mysample$psu]
design_2stage <- svydesign(
  id=~psu+ssunits, fpc=~fpc1+fpc2, data=mysample)
svymean(~z, design_2stage)
```
The estimated standard error of the ratio estimator is slightly smaller than the standard error of the $\pi$ estimator.


## Stratified two-stage cluster random sampling {#StratifiedTwostage}

The basic sampling designs stratified random sampling (Chapter \@ref(STSI)) and two-stage cluster random sampling can be combined into stratified two-stage cluster random sampling\index{Stratified random sampling!stratified two-stage cluster random sampling}. Figure \@ref(fig:STtwostage) shows a stratified two-stage cluster random sample from Voorst. The strata are 2 km $\times$ 1 km blocks, as before in stratified cluster random sampling (Figure \@ref(fig:ClVoorst)). The primary sampling units are 0.5 km $\times$ 0.5 km blocks, as before in (unstratified) two-stage cluster random sampling (Figure \@ref(fig:TwostageVoorst)).  Within each stratum two times a psu is selected by ppswr, and every time a psu is selected, six ssu's (points) are selected by simple random sampling. The stratification avoids the clustering of the selected psu's in one part of the study area. Compared to (unstratified) two-stage cluster random sampling, the geographical spreading of the psu's is somewhat improved, which may lead to an increase of the precision of the estimated population mean.

```{r, echo=FALSE}
w <- 1000 #width of strata
s1bnd <- seq(min(grdVoorst$s1)+w, min(grdVoorst$s1)+5*w, w)+12.5
grdVoorst$zonestratum <- as.factor(findInterval(grdVoorst$s1, s1bnd))
levels(grdVoorst$zonestratum) <- rep(c("a","b","c"), each=2)
```


```{r}
n_h <- c(2,3,4)
m <- 6
set.seed(314)
stratumlabels <- unique(grdVoorst$zonestratum)
mysample <- NULL
for (i in 1:3) {
  grd_h <- grdVoorst[grdVoorst$zonestratum==stratumlabels[i],]
  mysample_h <- twostage(sframe=grd_h, psu="psu", n=n_h[i], m=m)
  mysample <- rbind(mysample, mysample_h)
}
mysample$s1 <- jitter(mysample$s1, amount=cellsize/2)
mysample$s2 <- jitter(mysample$s2, amount=cellsize/2)
```

```{r STtwostage, echo=FALSE, out.width='100%', fig.cap="Stratified twostage random sample from Voorst. Strata are 2 km by 1 km blocks."}
ggplot(grdVoorst) +        
  geom_raster(mapping = aes(x = s1/1000, y = s2/1000, fill=as.factor(psu))) +
  scale_fill_viridis_d(alpha=0.5) +
  geom_point(data=mysample, mapping = aes(x = s1/1000, y = s2/1000), size = 1.5) +
  geom_vline(xintercept=s1bnd[c(2,4)]/1000)+
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  coord_fixed()+
  theme(legend.position = "none")
```

The population mean can be estimated in much in the same way as with stratified cluster random sampling. With function `svymean` this is an easy task.  

```{r}
N_h <- tapply(
  grdVoorst$psu, INDEX=grdVoorst$zonestratum,
  FUN=function(x) {length(unique(x))})
M_h <- tapply(
  grdVoorst$z, INDEX=grdVoorst$zonestratum, FUN=length)
mysample$w1 <- N_h[mysample$zonestratum]
mysample$w2 <- M_h[mysample$zonestratum]
design_str2stage <- svydesign(
  id=~psudraw+ssunits, strata=~zonestratum,
  weights=~w1+w2, data=mysample, nest=TRUE)
svymean(~z, design_str2stage)
```

```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:07-Twostage.Rmd-->

# Sampling with probabilities proportional to size {#pps}

In simple random sampling the inclusion probabilities are equal for all population units. The advantage of this is simple and straightforward statistical inference. With equal inclusion probabilities the unweighted sample mean is an unbiased estimator of the spatial mean, i.e. the sampling design is *self-weighting*. However, in some situations equal probability sampling is not very efficient, i.e. given the sample size the precision of the estimated mean or total will be relatively low. An example is the following. In order to estimate the total area of a given crop in a country, a raster of square cells of, for instance, 10 km x 10 km is constructed and projected on the country. The square cells are the population units, and these units serve as the sampling units. Note that near the country border cells cross the border. Some of them may contain only a few hectares of the target population, the country under study. We do not want to select many of these squares with only a few hectares of the study area, as intuitively it is clear that this will result in a low precision of the estimated crop area. In such situation it can be more efficient to select sampling units with probabilities proportional to the area of the target population within the squares, so that small sampling units near the border have smaller probability of being selected than interior sampling units. Actually, the sampling units are not the square cells, but the pieces of land obtained by overlaying the cells and the GIS map of the country under study. As a consequence the sampling units have unequal size, i.e. the support is different (Chapter \@ref(GeneralIntro)). The sampling units of unequal size are selected by probabilities proportional to their size (pps). In the previous Chapters \@ref(Cl) and \@ref(Twostage)  pps sampling was already used to select clusters (primary sampling units) of population units. In this chapter the *individual* population units (elementary sampling units) are selected with probabilities proportional to size. 

If we have a GIS map of land use categories such as agriculture, built-up areas, water bodies, forests, etc., we may use this file to further adapt the selection probabilities. The crop will be grown in agricultural areas only, so we expect small crop areas in cells largely covered by non-agricultural land. As a size measure in computing the selection probabilities we may use the agricultural area (as represented in the GIS map) in the country under study within the cells. Note that size now has a different meaning. It does not refer to the area of the sampling units anymore, but to an ancillary variable that we expect to be related to the study variable, i.e. the crop area. When the crop area per cell is proportional to the agricultural area per cell, then the precision of the estimated total area of the crop can be increased by selecting the cells with probabilities proportional to the agricultural area.

In this example the sampling units have an area. However, sampling with probabilities proportional to size is not restricted to areal sampling units\index{Areal sampling unit}, but can also be used for selecting points. If we have a map of an ancillary variable that is expected to be (linearly) related to the study variable, this ancillary variable can be used as a size measure. For instance, in areas where soil organic carbon shows a positive (linear) relation with (relative) elevation, it can be efficient to select sampling points with a selection probability proportional to  this environmental variable. The ancillary variable must be strictly positive for all points.

Sampling units can be selected with probabilities proportional to their size *with* or *without* replacement. This distinction is immaterial for infinite populations, as in sampling points from an area. pps sampling with replacement (ppswr) is much easier to implement than pps sampling without replacement (ppswor). The problem with ppswor is that after each draw the selected unit is removed from the sampling frame, so that the sum of the size variable over all remaining units changes, and as a result the draw-by-draw selection probabilities of the units.

pps sampling is illustrated with the simulated map of poppy area per 5 km $\times$ 5 km square in the province of Kandahar (Figure \@ref(fig:mapsKandahar)). 

```{r}
load("data/Kandahar.RData")
head(grdKandahar)
```

## Probability-proportional-to-size sampling with replacement {#ppswr}

In the first draw a sampling unit is selected with probability $p_k = x_k/t(x)$, with $x_k$ the size variable for unit $k$ and $t(x) = \sum_{k=1}^N x_k$ the population total of the size variable\index{pps sampling!with replacement (ppswr)}. The selected unit is then replaced, and these two steps are repeated $n$ times. Note that with this sampling design population units can be selected more than once, especially with large sampling fractions\index{Sampling fraction} $n/N$.

The population total can be estimator by the pwr estimator: 

\begin{equation}
\hat{t}(z)=\frac{1}{n}\sum_{k \in \mathcal{S}}\frac{z_{k}}{p_{k}} \;,
(\#eq:HHTotalppswr)
\end{equation}

where $n$ is the sample size (number of draws). The population mean can be estimated by the estimated population total divided by the population size $N$. With independent draws the sampling variance of the estimator of the population total can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{t}(z)\right)=
\frac{1}{\,n\,(n-1)}\sum_{k \in \mathcal{S}}\left( \frac{z_{k}}{p_{k}}-\hat{t}(z)\right)^{2} \;.
(\#eq:VarHHTotalppswr)
\end{equation}

The sampling variance of the estimator of the mean can be estimated by the variance of the estimator of the total divided by $N^2$. ppswr samples can be selected with function `sample.int`. As a first step I check whether the size variable is strictly positive. The minimum equals `r round(min(grdKandahar$agri)*10000,3)` m$^2$, so this is the case. If there are values equal to or smaller than 0 these must be replaced by a small number, so that these units also have a positive probability of being selected. Then the draw-by-draw selection probabilities are computed.  

```{r}
grdKandahar$p <- grdKandahar$agri/sum(grdKandahar$agri)
N <- nrow(grdKandahar)
n <- 40
set.seed(314)
units <- sample.int(N, size=n, replace=TRUE, prob=grdKandahar$p)
mysample <- grdKandahar[units,]
```

To select the units, computing the selection probabilities is not strictly needed. Exactly the same units are selected when the agricultural area within the units (column `agri` in the data frame) are used in argument `prob` of `sample.int`. Four units are selected twice:

```{r}
table_frq <- table(units) %>% data.frame(.)
print(table_frq[table_frq$Freq>1,])
```

Figure \@ref(fig:ppswrKandahar) shows the selected sampling units, plotted on a map of the agricultural area within the units, used as a size variable.

```{r ppswrKandahar, echo=FALSE, out.width='100%', fig.cap="ppswr sample of size 40 from Kandahar, using agricultural area as a size variable. Four units are selected twice, so that the number of distinct units is 36."}
ggplot(data=grdKandahar) +
  geom_raster(mapping=aes(x=x, y=y, fill=agri)) +
  geom_tile(data=mysample,mapping=aes(x=x, y=y), colour="white", width=5, height=5, size=0.7, fill=NA) +
  scale_fill_viridis_c(name="Agriarea") +
  scale_y_continuous(name="Northing (km)") +
  scale_x_continuous(name="Easting (km)") +
  coord_fixed()
```

The next code chunk shows how the population total of the poppy area can be estimated, using Equation \@ref(eq:HHTotalppswr), as well as its standard error (Equation \@ref(eq:VarHHTotalppswr), followed by taking the square root). As a first step the observations are inflated (expanded) through division of the observations by the selection probabilities of the corresponding units. 

```{r}
z_pexpanded <- mysample$poppy/mysample$p
tz <- mean(z_pexpanded)
se_tz <- sqrt(var(z_pexpanded)/n)
```

The estimated total equals `r as.character(round(tz,0))` ha, with a standard error of `r as.character(round(se_tz,0))`. The same estimates are obtained with package **survey** [@Lumley2020].

```{r}
library(survey)
mysample$weight <- 1/(mysample$p*n)
design_ppswr <- svydesign(id=~1, data=mysample, weights=~weight)
svytotal(~poppy, design_ppswr)
```

In pps sampling with replacement a sampling unit can be selected more than once, especially with large sampling fractions $n/N$. This may decrease the sampling efficiency. With large sampling fractions the alternative is pps sampling without replacement, see next section. For infinite populations the probability that a unit is selected more than once is 0, so that there is no reason not to use  estimator of Equation \@ref(eq:HHTotalppswr). If the spatial population is discretised by a finite set of grid points, one must make the discretisation grid fine enough. 

#### Exercises {-}

1. Write an **R** script to select a pps with replacement sample from Eastern Amazonia to estimate the population mean of aboveground biomass (AGB), using log-transformed short-wave infrared (SWIR2) as a size variable. Use the 5 km x 5 km subgrid to reduce computing time (data are in `data/Amazonia_5km.RData`).      
    +  The correlation of AGB and lnSWIR2 is negative. The first step is to compute an appropriate size variable, so that the larger the size variable the larger the selection probability is. Multiply the lnSWIR2 values by -1. Then add a small value, so that the size variable becomes strictly positive.   
    +  Select in a for-loop 10,000 times a ppswr sample of size 100 ($n=100$), and estimate from each sample the population mean of AGB with the pwr estimator (Hansen-Hurwitz estimator), and its sampling variance.  Compute the variance of the 10,000 estimated population means, and the mean of the 10,000 estimated variances. Make a histogram of the 10,000 estimated means.   
    +  Compute the true sampling variance of the $\pi$ estimator with simple random sampling with replacement and the same sample size.  
    +  Compute the gain in precision by the ratio of the variance of the estimator of the mean with simple random sampling to the variance with ppswr.   

## Probability-proportional-to-size sampling without replacement {#ppswor}

The alternative to pps sampling with replacement (ppswr) is pps sampling without replacement (ppswor)\index{pps sampling!without replacement (ppswor)}, i.e. sampling with inclusion probabilities proportional to a size variable. ppswor sampling is also referred to as $\pi$ps sampling, stressing that the *inclusion* probabilities are proportional to a size variable, instead of the draw-by-draw selection probabilities. ppswor sampling starts with assigning target inclusion probabilities to all units in the population. With inclusion probabilities proportional to a size variable $x$ the target inclusion probabilities are computed by $\pi_k=  n\;x_k/\sum_{j=1}^Nx_j, k = 1 \dots N$. 

### Systematic pps sampling without replacement {#Systematicpps}

Many algorithms are available for ppswor sampling, see @Tille2006 for an overview. A simple, straightforward method is systematic ppswor sampling\index{Systematic ppswor sampling}. The sampling frame is a list of the population units. Two subtypes can be distinguished, systematic ppswor sampling with fixed frame order and systematic ppswor sampling with random frame order [@Rosen1997b]. Given some order of the units, the cumulative sum of the inclusion probabilities is computed. Each population unit is then associated with an interval of cumulative inclusion probabilities. The larger the inclusion probability of a unit, the wider the interval. Then a random number from the uniform distribution is drawn, which serves as the start of a 1-dimensional systematic sample of size $n$ with an interval of 1. Finally, the units are determined for which the systematic random values are in the interval of cumulative inclusion probabilities, see Figure \@ref(fig:sysppswor) for ten population units and a sample size of four. The units selected are 2, 5, 7 and 9.

```{r}
library(sampling)
set.seed(314)
N <- 10
x <- rnorm(N, mean=20, sd=5)
n <- 4
pi <- inclusionprobabilities(x, n)
print(df <- data.frame(id=seq(1:10), x, pi))
```

```{r }
cumsumpi <- c(0, cumsum(pi))
start <- runif(1, min=0, max=1)
sys <- 0:(n-1)+start
print(units <- findInterval(sys, cumsumpi))
```

```{r sysppswor, echo=FALSE, fig.asp=.15, fig.cap = "Systematic random sample along a line with unequal inclusion probabilities."}
x <- cumsumpi[1:N]+pi/2
dat <- data.frame(x, y=rep(1,N), pi)
ggplot(data=dat) +
  geom_tile(mapping=aes(x=x, y=y, width=pi), fill="grey") +
  geom_text(mapping=aes(x=x, y=y, label=round(pi,3))) +
  geom_vline(xintercept=cumsumpi, linetype=2) +
  scale_x_continuous("", breaks=sys) +
  scale_y_continuous("", breaks=c()) +
  scale_fill_discrete(guide="none")
``` 

In Figure \@ref(fig:sysppswor) the population units are in random order. Sampling efficiency can be increased by ordering the units in the frame, for instance in a way leading to an improved geographical spreading (see Section \@ref(GRTS)), or by the size variable. In Figure \@ref(fig:sysppsworsort) the ten units are ordered by size.  With this design the third, fourth, fifth and second unit in the original frame are selected, with sizes 15.8, 16.5, 20.6 and 23.6, respectively. Ordering the units by size leads to a large within-sample variance of the size variable, and a small between-sample variance. If the study variable is proportional to the size variable, this results in a smaller sampling variance of the estimator of the mean of the study variable. A drawback of systematic ppswor sampling with fixed order is that no unbiased estimator of the sampling variance exists.

```{r sysppsworsort, echo=FALSE, fig.asp=.15, fig.cap = "Systematic random sample along a line with unequal inclusion probabilities. Units are ordered by size."}
pisorted <- pi[order(pi)]
cumsumpi <- c(0, cumsum(pisorted))
sys <- 0:3 + start
units <- findInterval(sys, cumsumpi)
x <- cumsumpi[1:N]+pisorted/2
dat <- data.frame(x, y=rep(1, N), pisorted)
ggplot(data=dat) +
  geom_tile(mapping=aes(x=x, y=y, width=pisorted), fill="grey") +
  geom_text(mapping=aes(x=x, y=y, label=round(pisorted,3))) +
  geom_vline(xintercept=cumsumpi, linetype=2) +
  scale_x_continuous("", breaks=sys) +
  scale_y_continuous("",  breaks=c())
```

A small simulation study is done next to see how much gain in precision can be achieved by ordering the units by size. A size variable $x$ and a study variable $z$ are simulated  by drawing 1,000 values from a bivariate normal distribution with a correlation coefficient of 0.8. Function `mvtnorm` of package **MASS** [@VenablesRipley2002] is used for the simulation. 

```{r}
library(MASS)
rho <- 0.8
mu1 <- 10; sd1 <- 2
mu2 <- 15; sd2 <- 4
mu <- c(mu1, mu2)
sigma <- matrix(data=c(sd1^2, sd1*sd2*rho, sd1*sd2*rho, sd2^2),
                nrow=2, ncol=2)
N <- 1000
set.seed(314)
dat <- as.data.frame(mvrnorm(N, mu=mu, Sigma=sigma))
names(dat) <- c("z","x")
head(dat)
```

Twenty units are selected by systematic ppswor sampling with random order and ordered by size. This is repeated 10,000 times.

```{r simululationsyspps, echo=FALSE}
n <- 20
dat$pi <- inclusionprobabilities(dat$x, n)
datsorted   <- dat[order(dat$x),]

mz_syspps <- mz_sysppssorted <- numeric(length=10000)
set.seed(314)
for (i in 1:10000) {
  s <- UPsystematic(dat$pi)
  mysample <- dat[s==1,]
  mz_syspps[i] <- sum(mysample$z/mysample$pi)/N
  s <- UPsystematic(datsorted$pi)
  mysample <- datsorted[s==1,]
  mz_sysppssorted[i] <- sum(mysample$z/mysample$pi)/N
}
se_syspps <- sqrt(var(mz_syspps))
se_syspps_sorted <- sqrt(var(mz_sysppssorted))
se_SI <- sqrt((1-n/N)*var(dat$z)/n)
```

The standard deviation of the 10,000 estimated means with systematic ppswor sampling with random order is `r round(se_syspps,3)`, and when ordered by size `r round(se_syspps_sorted,3)`. So a small gain in precision is achieved through ordering the units by size. For comparison I also computed the standard error for simple random sampling without replacement (SI) of the same size. The standard error with this basic design is `r round(se_SI,3)`.

### The pivotal method {#pivotalmethod}

Another interesting algorithm for ppswor sampling is the pivotal method\index{Pivotal method for ppswor sampling} [@Deville1998]. A nice adaptation of this algorithm, the local pivotal method, leading to samples with improved geographical spreading, is described in  Section \@ref(Spreaded). In the pivotal method the $N$-vector with inclusion probabilities is successively updated to a vector with indicators.  If the indicator value for sampling unit $k$ becomes one, then this sampling unit is selected, if it becomes0 then it is not selected. The updating algorithm can be described as follows:

1. select randomly two units $k$ and $l$ with $0<\pi_k<1$ and $0<\pi_l<1$  
2. If $\pi_k + \pi_l < 1$ then update the probabilities by

\begin{equation}
(\pi^{\prime}_k,\pi^{\prime}_l)=\left\{
\begin{array}{cc}
(0,\pi_k+\pi_l) & \;\;\;\text{with probability}\frac{\pi_l}{\pi_k+\pi_l} \\
(\pi_k+\pi_l,0) & \;\;\;\text{with probability}\frac{\pi_k}{\pi_k+\pi_l}
\end{array}
\right.
(\#eq:algppswor1)
\end{equation}

and if $\pi_k + \pi_l \geq 1$ then update the probabilities by

\begin{equation}
(\pi^{\prime}_k,\pi^{\prime}_l)=\left\{
\begin{array}{cc}
(1,\pi_k+\pi_l-1) & \;\;\;\text{with probability}\frac{1-\pi_l}{2-(\pi_k+\pi_l)} \\
(\pi_k+\pi_l-1,1) & \;\;\;\text{with probability}\frac{1-\pi_k}{2-(\pi_k+\pi_l)}
\end{array}
\right.
(\#eq:algppswor2)
\end{equation}  

3. Replace ($\pi_k,\pi_l$) by ($\pi^{\prime}_k,\pi^{\prime}_l$), and repeat the first two steps until each population unit is either selected (inclusion probability equals 1) or not selected (inclusion probability equals 0).

In words, when the sum of the inclusion probabilities is smaller than one, the updated inclusion probability of one of the units will become 0, which means that this unit will not be sampled. The inclusion probability of the other unit will become the sum of the two inclusion probabilities, which means that the probability increases that this unit will be selected in one of the subsequent iterations. The probability of a unit of being excluded from the sample is proportional to the inclusion probability of the other unit, so that the larger the inclusion probability of the other unit, the larger the probability that it will not be selected.

When the sum of the inclusion probabilities of the two units is larger than or equal to one, then one of the units is selected (updated inclusion probability is one), while the inclusion probability of the other is lowered by one minus the inclusion probability of the selected unit. The probability of being selected is proportional to the complement of the inclusion probability of the other unit. After the inclusion probability of a unit is updated to either 0 or 1, this unit cannot be selected anymore in the next iteration.

With this ppswor design the population total can be estimated by the $\pi$ estimator:

\begin{equation}
\hat{t}(z)=\sum_{k \in \mathcal{S}}w_k z_{k} \;,
(\#eq:HTTotalppswor)
\end{equation}

where $w_i = 1/\pi_i$. Note that the inclusion probabilities $\pi_i$ are not the final probabilities obtained with the local pivotal method, which are either 0 or 1, but the initial inclusion probabilities. The $\pi$ estimator of the mean is obtained simply by dividing the estimator for the total by the population size $N$.

An alternative estimator of the population mean is the Hajek estimator\index{Hajek estimator}:

\begin{equation}
\hat{\bar{z}}_{\text{Hajek}}(z)=\frac{\sum_{k \in \mathcal{S}} w_k z_k}{\sum_{k \in \mathcal{S}} w_k} \;,
(\#eq:HTTotalppsworHajek)
\end{equation}

with $w_k = 1/\pi_k$. The denominator is an estimator of the population size $N$. The Hajek estimator of the total is obtained by multiplying the Hajek estimator of the mean with the population size $N$.

Various functions in package **sampling** [@Tille2016] can be used to select a ppswor sample. In the code chunk below I use the function `UPrandompivotal`. With this function the order of the population units is randomized before function `UPpivotal` is used. In function `UPpivotal` in each iteration the first two units are selected. The argument `pi` is a numeric with the inclusion probabilities. These are computed with the function `inclusionprobabilities`. Recall that $\pi_k=  n\;x_k/t(x)$). The sum of the inclusion probabilities should be equal to the sample size $n$. Function `UPpivotal` returns a numeric of length $N$ with elements 1 and 0, 1 if the unit is selected, 0 if it is not selected. `eps` is a small number; the default value is $10^{-6}$. 

```{r}
library(sampling)
n <- 40
size=ifelse(grdKandahar$agri<1E-12, 0.1, grdKandahar$agri)
pi <- inclusionprobabilities(size, n)
set.seed(314)
eps <- 1e-6
sampleind <- UPrandompivotal(pik=pi, eps=eps)
mysample <- data.frame(
  grdKandahar[sampleind==1,], pi=pi[sampleind==1])
nrow(mysample)
```

As can be seen not 40 but only 39 units are selected. If we replace `sampleind==1` by `sampleind>1-eps`, 40 units are selected. 

```{r}
mysample <- data.frame(grdKandahar[sampleind>1-eps,],
                       pi=pi[sampleind>1-eps])
nrow(mysample)
```

The total poppy area can be estimated from the ppswor sample by

```{r}
tz_HT <- sum(mysample$poppy/mysample$pi)
tz_Hajek <- N*sum(mysample$poppy/mysample$pi)/
  sum(1/mysample$pi)
```

The total poppy area as estimated with the $\pi$ estimator equals `r as.character(round(tz_HT,0))` ha. The Hajek estimator results in a much smaller estimated total: `r as.character(round(tz_Hajek,0))` ha.

The $\pi$ estimate can also be computed with function `svytotal` of package **survey**, which also provides an approximate estimate of the standard error. Various methods are implemented in function `svydesign` for approximating the standard error. These methods differ in the way the pairwise inclusion probabilities are approximated from the unit-wise inclusion probabilities. These approximated pairwise inclusion probabilities are then used in the $\pi$ variance estimator, or the Yates-Grundy variance estimator\index{Yates-Grundy variance estimator}. In the next code chunks Brewer's method\index{Brewer's variance estimator} is used, see option 2 of Brewer's method in @Berger2004, as well as Hartley-Rao's method\index{Hartley-Rao's variance estimator} for approximating the variance. 

```{r}
library(survey)
design_ppsworbrewer <- svydesign(
  id=~1, data=mysample, pps="brewer", fpc=~pi)
svytotal(~poppy, design_ppsworbrewer)
```

```{r}
p2sum<-sum(mysample$pi^2)/n 
design_ppsworhr <- svydesign(
  id=~1, data=mysample, pps=HR(p2sum), fpc=~pi)
svytotal(~poppy, design_ppsworhr)
```

In package **samplingVarEst** [@samplingVarEst] also various functions are available for approximating the variance: `VE.Hajek.Total.NHT`, `VE.HT.Total.NHT`, and `VE.SYG.Total.NHT`. The first variance approximation is the Hajek-Rosen variance estimator\index{Hajek-Rosen variance estimator} (see Equation 4.3 in @Rosen1997b). The latter two functions require the pairwise inclusion probabilities\index{Pairwise inclusion probability}, which can be estimated by function `Pkl.Hajek.s`.

```{r HajekRosenVarianceEstimator}
library(samplingVarEst)
se_tz_Hajek <- sqrt(VE.Hajek.Total.NHT(
  mysample$poppy, mysample$pi))
pikl <- Pkl.Hajek.s(mysample$pi)
se_tz_HT <- sqrt(VE.HT.Total.NHT(
  mysample$poppy, mysample$pi, pikl))
se_tz_SYG <- sqrt(VE.SYG.Total.NHT(
  mysample$poppy, mysample$pi, pikl))
```

The three standard errors equal `r as.character(round(se_tz_Hajek,0))`, `r as.character(round(se_tz_HT,0))`, and `r as.character(round(se_tz_SYG,0))`. The differences in the approximated standard errors are small when related to the estimated total.

Figure \@ref(fig:SamplingDistributionPps) shows the sampling distributions of estimators of the total poppy area with ppswor sampling and simple random sampling without replacement of size 40, obtained by repeating the random sampling with each design and estimation 10,000 times. With the ppswor samples the total poppy area is estimated by the $\pi$ estimator and the Hajek estimator. For each ppswor sample the variance of the $\pi$ estimator is approximated by the Hajek-Rosen variance estimator (using function `VE.Hajek.Total.NHT` of package **samplingVarEst**).

```{r repeatedpps, eval=FALSE, echo=FALSE}
ppswor <- function(sframe, size, n) {
    pi <- inclusionprobabilities(size, n)
    sampleind <- UPpivotal(pik=pi, eps=eps)
    mysample <- data.frame(sframe[sampleind>1-eps,], pi=pi[sampleind>1-eps])
    mysample
}

SI <- function(sframe, n) {
    units <- sample.int(nrow(sframe), size=n, replace=FALSE)
    mysample <- sframe[units,]
    mysample
}

#number of samples
number_of_samples <- 10000
N <- nrow(grdKandahar)

tz_HT <- v_tz_HR <- tz_Hajek <- tz_SI <- numeric(length=number_of_samples)
set.seed(314)
for (i in 1:number_of_samples){
  mysample <- ppswor(sframe=grdKandahar, size=ifelse(grdKandahar$agri<1E-12,0.1,grdKandahar$agri), n=n)
  tz_HT[i] <- sum(mysample$poppy/mysample$pi)
  tz_Hajek[i] <- N*sum(mysample$poppy/mysample$pi)/sum(1/mysample$pi)
  #approximate variance by variance of Hansen-Rosen estimator (for pps-with replacement)
  v_tz_HR[i] <- VE.Hajek.Total.NHT(mysample$poppy, mysample$pi)
  mySIsample <- SI(sframe=grdKandahar, n=n)
  tz_SI[i] <- mean(mySIsample$poppy)*N
}
save(tz_HT, tz_Hajek, v_tz_HR, tz_SI,file="results/pps_Kandahar.RData")
```

```{r SamplingDistributionPps, echo=FALSE, fig.asp=.8, echo=FALSE, fig.cap="Sampling distribution of estimators of the total poppy area (ha) in Kandahar with ppswor sampling and simple random sampling without replacement (SI) of 40 units. In ppswor sampling the total poppy area is estimated by the $\\pi$ estimator (ppswor.HT) and Hajek estimator (ppswor.Hajek)."}
load(file="results/pps_Kandahar.RData")
estimates <- data.frame(tz_HT, tz_Hajek, v_tz_HR, tz_SI)
names(estimates)[c(1,2,4)] <- c("ppswor.HT","ppswor.Hajek","SI")

df <- estimates %>% pivot_longer(., cols=c("ppswor.HT","ppswor.Hajek","SI"))
df$name <- factor(df$name, levels=c("ppswor.Hajek","ppswor.HT","SI"), ordered=TRUE)

ggplot(data=df) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=mean(grdKandahar$poppy)*N, colour="red")+
    scale_x_discrete(name="Sampling strategy") +
    scale_y_continuous(name="Estimated total poppy area")

#standard deviation of estimated totals with ppswor and $\pi$ estimator
sd_tz_ppsworHT_sim <- sqrt(var(estimates$ppswor.HT))

#standard deviation of estimated totals with SI
sd_tz_SI_sim <- sqrt(var(estimates$SI))

#mean of square root of Hajek-Rosen approximate variances
m_se_tz_HR_sim <- mean(sqrt(estimates$v_tz_HR))
```

Sampling design ppswor in combination with the $\pi$ estimator is clearly much more precise than simple random sampling. The standard deviation of the 10,000 $\pi$ estimates of the total poppy area with ppswor equals  `r as.character(round(sd_tz_ppsworHT_sim,0))`. The average of the square root of the Hajek-Rosen approximate variances equals `r as.character(round(m_se_tz_HR_sim,0))`.

Interestingly, with ppswor sampling the variance of the 10,000 Hajek estimates is much larger than that of the $\pi$ estimates. The standard deviation of the 10,000 Hajek estimates with ppswor sampling is about equal to that of the $\pi$ estimates with simple random sampling: `r round(sqrt(var(estimates$ppswor.Hajek)),0)` and `r round(sqrt(var(estimates$SI)),0)`, respectively.

#### Exercises {-}  

2. A field with poppy was found outside Kandahar in a selected sampling unit crossing the boundary. Should this field be included in the sum of the poppy area of that sampling unit?  
3. In another sampling unit a poppy field was encountered in Kandahar but in the area represented as non-agriculture in the GIS map. Should this field be included in the sum of that sampling unit?

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:08-pps.Rmd-->

# Balanced and well-spread sampling {#BalancedSpreaded}

In this chapter two sampling designs are described and illustrated that are related but also fundamentally different. The similarities and difference are shortly described, but will become more clear in following sections. Roughly speaking, a balanced sample is a sample of which the sample mean of one or more covariates is equal to the population means of these covariates. When the covariates are linearly related to the study variable this may yield a more accurate estimate of the population mean or total.

A well-spread sample\index{Well-spread sample} is a sample with a large range of values for the covariates, from small to large values, but also intermediate values. In more technical terms: the sampling units are well-spread along the axes spanned by the covariates. If the spatial coordinates are used as covariates (spreading variables), this results in samples that are well-spread in geographical space. Such samples are commonly referred to as spatially balanced samples, which is somewhat confusing, as the geographical spreading is not implemented through balancing on the geographical coordinates. On the other hand, the averages of the spatial coordinates of a sample well-spread in geographical space will be close to the population means of the coordinates, and therefore will be approximately balanced on the spatial coordinates [@Grafstrom2014]. The reverse is not true: with balanced sampling\index{Balanced sampling} the spreading of the sampling units in the space spanned by the balancing variables can be poor. A sample with all values of a covariate used in balancing near the population mean of that variable has a poor spreading along the covariate axis, but can still be perfectly balanced.  

## Balanced sampling {#Balanced}

Balanced sampling is a sampling method that exploits one or more quantitative covariates that are related to the study variable. The idea behind balanced sampling is that, if we know the mean of the covariates, then the sampling efficiency can be increased by selecting a sample whose averages of the covariates must be equal to the population means of the covariates.

The simulated population shown in Figure \@ref(fig:simpleexample) shows a linear trend from West to East, and also a trend from South to North, but we will ignore this South to North trend for the moment. In other words, the simulated study variable $z$ is correlated with the covariate Easting. To estimate the population mean of the simulated study variable, intuitively it is attractive to select a sample with an average of the Easting coordinate that is equal to the population mean of Easting (which is 10). Figure \@ref(fig:simpleexample)(a) shows such a sample; we say that the sample is `balanced' on the covariate Easting.

```{r simpleexample, echo=FALSE, out.width='100%', fig.cap = "Sample balanced on Easting (E) and on Easting and Northing (E and N)."}
library(sampling)
library(gstat)
#define residual variogram for simulation
vgmodel <- vgm(model="Exp", psill=10, range=4, nugget=0)

#define discretisation grid
x <- 1:20 - 0.5
y <- x
grid <- expand.grid(x,y)
names(grid) <- c("x1","x2")
distx <- outer(grid$x1, grid$x1, FUN="-")
disty <- outer(grid$x2, grid$x2, FUN="-")
dist <- sqrt(distx^2+disty^2)

#compute matrix with covariances
C <- variogramLine(vgmodel, dist_vector=dist, covariance=TRUE)

#now simulate values for grid by Cholesky decomposition
Upper <- chol(C)

set.seed(31415)
G <- rnorm(n=nrow(grid),0,1) #simulate random numbers from standard normal distribution

#trend coefficient in x-direction
b1 <- 2
b2 <- 1
grid$z <- crossprod(Upper,G) + b1*grid$x1 + b2*grid$x2

#compute population size
N <- nrow(grid)

#set sample size)
n <- 4

#define matrix with covariate for balancing; first column of matrix must be filled with ones
X <- cbind(rep(1,times=N), grid$x1)

#compute inclusion probabilities; use equal probabilities
pi <- rep(n/N,times=N)

nsam <- 100
mx_pop <- mean(grid$x1)
set.seed(31415)
repeat {
    sample_ind <- samplecube(X=X, pik=pi, comment=FALSE, method=1)
    mysample <- grid[sample_ind==1,]
    mx_sample <- mean(mysample$x1)
    if (mx_sample == mx_pop) {break}    
}

#now select a sample balanced on Easting and Northing
X <- cbind(rep(1,times=N),grid$x1,grid$x2)

mx1_pop <- mean(grid$x1)
mx2_pop <- mean(grid$x2)
set.seed(314)
repeat {
  sample_ind <- samplecube(X=X, pik=pi, comment=FALSE, method=1)
  mysample2 <- grid[sample_ind==1,]
  mx1_sample <- mean(mysample2$x1)
  mx2_sample <- mean(mysample2$x2)
  if (mx1_sample == mx1_pop & mx2_sample == mx2_pop) {break}    
}

mysamples <- rbind(mysample,mysample2)
mysamples$samid <- rep(c("E","E and N"), each=4)

ggplot(data=grid) +
  geom_tile(mapping=aes(x=x1, y=x2, fill=z)) +
  geom_tile(data=mysamples, mapping=aes(x=x1, y=x2), colour="white", size=0.8, width=1, height=1, fill=NA)+
  scale_fill_continuous(name="x",type= "viridis") +
  scale_x_continuous(name="Easting") +
  scale_y_continuous(name="Northing") +
  facet_wrap(~ samid, ncol=2, nrow=1) +
  coord_fixed()
```

### Balanced sample versus balanced sampling design

We must distinguish a balanced *sample* from a balanced sampling *design*. A sampling design is balanced on a covariate $x$ when *all possible* samples that can be generated by the design are balanced on $x$. So, simple random sampling is not a balanced sampling design, because for many simple random samples the sample mean of $x$ is not equal to the population mean of $x$. Only the *expectation* of the sample mean of $x$, i.e. the mean of the sample mean over an infinite number of simple random samples, equals the population mean of $x$.

Figure \@ref(fig:scatterplotsqerror) shows for one thousand simple random samples the squared error of the estimated population mean of the study variable $z$ against the difference between the sample mean of $x$ and the population mean of $x$.

```{r scatterplotsqerror, echo=FALSE, fig.cap="Squared error in estimated mean of $z$ against difference between population and sample mean of a covariate."}
nsam <- 1000
n <- 4
mz_sample <- mx_sample <- numeric(length=nsam)
set.seed(31415)
for (i in 1:nsam) {
  #select simple random sample from the data
  sample_ind <- sample.int(nrow(grid), size=n)
  mz_sample[i] <- mean(grid$z[sample_ind])
  mx_sample[i] <- mean(grid$x1[sample_ind])
}

sqerror <- (mz_sample - mean(grid$z))^2
devx <- mx_sample - mean(grid$x1)
df <- data.frame(sqerror, devx)
ggplot(data=df) +
  geom_point(mapping=aes(y=sqerror ,x=devx), size=2) +
  scale_x_continuous(name="Sample mean x - population mean x", limits=c(-9,9)) +
  scale_y_continuous(name="Squared error")
```

Clearly, the larger the absolute value of the difference, the larger on average the squared error. So to obtain an accurate estimate of the population mean of $z$, we better select samples with a difference close to 0.

Sampling designs can also be balanced on multiple covariates. Figure \@ref(fig:simpleexample)(b) shows a sample balanced on both Easting and Northing. Using Easting as a balancing variable reduced the sampling variance of the estimator of the mean substantially, see Table \@ref(tab:tablebalanced). Using Northing as a second balancing variable further reduced the sampling variance.  

```{r tablebalanced, echo=FALSE}
tbl <- data.frame(x=c("SI","Balanced","Balanced"),y=c("-","Easting","Easting+Northing"),z=c(39.7,14.4,9.77))

knitr::kable(
  tbl, caption = 'Sampling variances of estimated mean for simple random sampling and balanced sampling of four units.',
  col.names=c("Sampling design","Balancing variables","Sampling variance"),
  booktabs = TRUE
) %>%
  kable_classic()
```

### Unequal inclusion probabilities

Until now we assumed that the inclusion probabilities of the population units are equal, but this is not a requirement for balanced sampling designs. A more general definition is: a sampling design is balanced on variable $x$ when for all samples generated by the design the $\pi$ estimator of the population total of $x$ equals the population total of $x$:  

\begin{equation}
\sum_{k \in \mathcal{S}} \frac{x_k}{\pi_k}= \sum_{k=1}^{N} x_k \;,
(\#eq:generaldefinitionbalanced)
\end{equation}

with $\pi_k$ the inclusion probability of unit $k$, $x_k$ the covariate of unit $k$, and $N$ the total number of units in the population.

Similar to the regression estimator\index{Regression estimator} (Section \@ref(RegressionEstimator)), balanced sampling exploits the linear relation between the study variable and one or more covariates. In the regression estimator this is done at the estimation stage. Balanced sampling does so at the sampling stage. For a single covariate the regression estimator of the population total equals (see Equation \@ref(eq:SimpleRegressionEstimatorSI))

\begin{equation}
\hat{t}_{\mathrm{regr}}(z) = \hat{t}_{\pi}(z) + \hat{b}\left(t(x) - \hat{t}_{\pi}(x)\right) \;,
(\#eq:RegressionEstimatoranydesign)
\end{equation}

with $\hat{t}_{\pi}(z)$ and $\hat{t}_{\pi}(x)$ the $\pi$ estimators of the population total of the study variable $z$ and the covariate $x$, respectively, $t(x)$ the population total of the covariate, and $\hat{b}$ the estimated slope parameter (see hereafter). With a perfectly balanced sample the adjustment term in the regression estimator (the second term) equals zero.

Balanced samples can be selected with the cube algorithm\index{Cube algorithm for balanced sampling} of @Deville2004, see also @Brus2015 for a detailed description of this algorithm. The population total can be estimated by the $\pi$ estimator:

\begin{equation}
\hat{t}(z) = \sum_{k \in \mathcal{S}} \frac{z_k}{\pi_k}.
(\#eq:HTMeanBalanced)
\end{equation}

So with equal inclusion probabilities, equal to $n/N$, the population total is estimated by the sample mean of the study variable multiplied by the number of population units $N$. The population mean is estimated by dividing the estimated population total by $N$.

The approximate variance of the $\pi$ estimator of the population mean can be estimated by (@Deville2005, @Grafstrom2013) 

\begin{equation}
\widehat{V}(\hat{\bar{z}}) = \frac{1}{N^2}\frac{n}{n-p} \sum_{k \in \mathcal{S}} c_k \left(\frac{\epsilon_k}{\pi_k}\right)^2 \;,
(\#eq:approxvarianceBalanced)
\end{equation}

with $p$ the number of balancing variables, $c_k$ a weight for unit $k$ (see hereafter), and $\epsilon_k$ the residual of unit $k$ given by

\begin{equation}
\epsilon_k = z_k - \mathbf{x}_k^{\text{T}}\hat{\mathbf{b}} \;,
(\#eq:residualsBalanced)
\end{equation}

with $\mathbf{x}_k$ a vector of length $p$ with the balancing variables for unit $k$, and $\hat{\mathbf{b}}$ the estimated population regression coefficients\index{Population regression coefficient}, given by

\begin{equation}
\hat{\mathbf{b}} = \left(\sum_{k \in \mathcal{S}} c_k \frac{\mathbf{x}_k}{\pi_k} \frac{\mathbf{x}_k}{\pi_k}^{\text{T}} \right)^{-1} \sum_{k \in \mathcal{S}} c_k \frac{\mathbf{x}_k}{\pi_k} \frac{z_k}{\pi_k} \;.
(\#eq:betasbalanced)
\end{equation}

Working this out for balanced sampling without replacement with equal inclusion probabilities, $\pi_k = n/N, k = 1, \dots , N$, yields

\begin{equation}
\widehat{V}(\hat{\bar{z}}) = \frac{1}{n(n-p)} \sum_{k \in \mathcal{S}} c_k \epsilon_k^2 \;.
(\#eq:approxvarianceBalancedSI)
\end{equation}

@Deville2005 give several formulas for computing the weights $c_k$, one of which is $c_k = (1-\pi_k)$.

Balanced sampling is now illustrated with the aboveground biomass (AGB) data of Eastern Amazonia, see Figure \@ref(fig:mapsAmazonia). Log-transformed short-wave infrared (lnSWIR2) is used as a balancing variable. The `samplecube` function of the **sampling** package [@Tille2016] implements the cube algorithm. Argument `X` of this function specifies the matrix of ancillary variables on which the sample must be balanced. The first column of this matrix must be filled with ones, so that the sample size is fixed. Equal inclusion probabilities are used, i.e. for all population units the inclusion probability equals $n/N$.

```{r}
load("data/Amazonia_5km.RData")
gridAmazonia$lnSWIR2 <- log(gridAmazonia$SWIR2)
library(sampling)
N <- nrow(gridAmazonia)
n <- 100
X <- cbind(rep(1,times=N), gridAmazonia$lnSWIR2)
pi <- rep(n/N,times=N)
sample_ind <- samplecube(X=X, pik=pi, comment=FALSE, method=1)
eps <- 1e-6
units <- which(sample_ind>(1-eps))
mysample <- gridAmazonia[units,]
```

The population mean can be estimated by the sample mean.

```{r}
mz_sample <- mean(mysample$AGB)
```

To estimate the variance a function is defined for estimating the population regression coefficients.

```{r}
estimate_b <- function(z,X,c) {
  cXX <- matrix(nrow=ncol(X),ncol=ncol(X),data=0)
  cXz <- matrix(nrow=1,ncol=ncol(X),data=0)
  for (i in 1:length(z)) {
    x <- X[i,]
    cXX_i <- c[i]*(x %*% t(x))
    cXX <- cXX+cXX_i
    cXz_i <- c[i]*t(x)*z[i]
    cXz <- cXz+cXz_i
  }
  b <- solve(cXX,t(cXz))
  b
}
```

The next code chunk shows how the variance of the $\pi$ estimator of the population mean can be estimated.

```{r}
pi <- rep(n/N,n)
c <- (1-pi)
b <- estimate_b(z=mysample$AGB/pi, X=X[units,]/pi, c=c)
zpred <- X%*%b
e <- mysample$AGB-zpred[units]
v_tz <- n/(n-ncol(X))*sum(c*(e/pi)^2)
v_mz <- v_tz/N^2
```

Figure \@ref(fig:BalancedSampleAmazonia) shows the result. The sample mean of AGB equals `r as.character(round(mz_sample,1))`. The population mean of AGB equals `r as.character(round(mean(gridAmazonia$AGB),1))`. Note the spatial clustering of some units. The standard error of the estimated mean equals `r as.character(round(sqrt(v_mz),1))`.

```{r BalancedSampleAmazonia, echo=FALSE, out.width='100%', fig.cap="Balanced sample from Eastern Amazonia (Brazil), balanced on covariate lnSWIR2."}
ggplot(data=gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=lnSWIR2)) +
  geom_point(data=mysample, mapping=aes(x=x1/1000, y=x2/1000), size=2)+
  scale_fill_continuous(name="lnSWIR2", type="viridis") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

Figure \@ref(fig:SamplingDistributionBalanced) shows the sampling distributions of the $\pi$ estimator of the mean of AGB with balanced sampling and simple random sampling, obtained by repeating the random sampling with both designs and estimation 1,000 times.

```{r, echo=FALSE, eval=FALSE}
mz <- v_mz <- mx_sample <- mz_SI <- numeric(length=1000)

pi <- rep(n/N, n)
c <- (1-pi)

set.seed(314)
for (i in 1:1000) {
  sample_ind <- samplecube(X=X, pik=rep(n/N,N), comment=FALSE, method=1)
  units <- which(sample_ind>(1-eps))
  mysample <- gridAmazonia[units,]

  mz[i] <- mean(mysample$AGB)
  
  b <- estimate_b(z=mysample$AGB/pi, X=X[units,]/pi, c=c)
  zpred <- X%*%b
  e <- mysample$AGB-zpred[units]
  v_tz <- n/(n-ncol(X))*sum(c*(e/pi)^2)
  v_mz[i] <- v_tz/N^2

  mx_sample[i] <- mean(mysample$lnSWIR2)
  
  units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
  mz_SI[i] <- mean(gridAmazonia$AGB[units])
}
save(mz, mz_SI, v_mz, mx_sample, file="results/Balanced_Amazonia.RData")
```

```{r SamplingDistributionBalanced, echo=FALSE, fig.asp=.8, fig.cap="Sampling distribution of $\\pi$ estimator of the mean aboveground biomass in Eastern Amazonia, with balanced sampling (balanced on lnSWIR2) and simple random sampling, bot designs with a sample size of 100 units."}
load(file="results/Balanced_Amazonia.RData")
estimates <- data.frame(mz, mz_SI, v_mz, mx_sample)
names(estimates)[c(1,2)] <- c("Balanced","SI")

df <- estimates %>% pivot_longer(.,cols=c("Balanced","SI"))
ggplot(data=df) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=mean(gridAmazonia$AGB), colour="red")+
    scale_x_discrete(name="Sampling design") +
    scale_y_continuous(name="Estimated mean AGB")
```

The variance of the 1000 estimates of the population mean of the study variable AGB equals `r as.character(round(var(estimates$Bal),1))`. The gain in precision compared to simple random sampling, equals `r as.character(round(var(estimates$SI)/var(estimates$Bal),1))`, so with simple random sampling three times more sampling units are needed to estimate the population mean with the same precision. The mean of the 1,000 estimated variances equals `r as.character(round(mean(estimates$v_mz),1))`, indicating that the approximate variance estimator somewhat underestimates the true variance in this case. The population mean of the balancing variable lnSWIR2 equals `r round(mean(gridAmazonia$lnSWIR2),3)`. The sample mean of lnSWIR2 varies a bit among the samples (Figure \@ref(fig:histSampleMeanSWIR)). In other words, many samples are not perfectly balanced on lnSWIR2. This is not exceptional, in most cases perfect balance is impossible.

```{r histSampleMeanSWIR, echo=FALSE, fig.cap="Sampling distribution of sample mean of balancing variable lnSWIR2."}
ggplot(data=estimates) +
  geom_histogram(aes(x=mx_sample), binwidth=0.0025, fill="black", alpha=0.5, color="black") +
  scale_y_continuous(name="Frequency") +
  scale_x_continuous(name="Sample mean lnSWIR2")
```
### Stratified random sampling {#StratifiedsamplingasBalancedsampling}

In the previous section a continuous variable was used to balance the sample. However, also a categorical variable can be used for this. A sample balanced on a categorical variable actually is a  stratified random sample. Figure \@ref(fig:BalancedSampleCategorical) shows four strata. These four strata can be used in balanced sampling by constructing the following design matrix\index{Design matrix} $\mathbf{X}$ with as many columns as there are classes:

\begin{eqnarray}
\left[
\begin{array}{cccc}
\pi_{1,1} &0 &0 &0 \\
\pi_{2,1} &0 &0 &0 \\
\pi_{3,1} &0 &0 &0 \\
\pi_{4,1} &0 &0 &0 \\
\ &\pi_{5,2} &0 &0 \\
0 &\pi_{6,2} &0 &0 \\
0 &0 &\pi_{7,3} &0 \\
\vdots &\vdots &\vdots &\vdots\\
0 & 0 & 0 & \pi_{400,4} \\
\end{array}\right]  \;,
\end{eqnarray}

The first four rows refer to the four leftmost bottom row population units in Figure \@ref(fig:BalancedSampleCategorical). These units belong to class A, which explains that the first column for these units contain non-zeroes. These non-zeroes are the inclusion probabilities of the units in stratum A. The other three columns for these rows contain all zeroes. The fifth and sixth unit belong to stratum B, so that the second column for these rows contain the inclusion probabilities for stratum B, and so on. The final row is the upper-right sampling unit in stratum D, so the first three columns contain zeroes, and the fourth column is filled with the inclusion probability of this stratum. The sum of the inclusion probabilities in the first column is the sample size of stratum A. Or reversely, if, for instance, we want to select $n_h$ units from stratum $h$ with equal probability for all units in this stratum, then the inclusion probabilities should equal $n_h/N_h$, with $N_h$ the total number of units in this stratum.

```{r BalancedSampleCategorical, out.width="70%", echo=FALSE, fig.cap="Sample balanced on a categorical variable with four classes."}
s1 <- s2 <- 1:20 - 0.5
mypop <- expand.grid(s1, s2)
names(mypop) <- c("s1", "s2")
mypop$stratum <- as.factor(findInterval(mypop$s1, c(4,6,14)))
levels(mypop$stratum) <- LETTERS[1:4]

N_h <- tapply(mypop$s1, INDEX=mypop$stratum, FUN=length)
n <- 20
n_h <- n*N_h/sum(N_h)
labels <- sort(unique(mypop$stratum))
lut <- data.frame(stratum=labels, pi=n_h/N_h)
mypop <- merge(x=mypop, y=lut)

X <- model.matrix(~ stratum-1, mypop)

set.seed(314)
sample_ind <- samplecube(X=X, pik=mypop$pi, comment=FALSE, method=1)
mysample <- mypop[sample_ind==1,]

ggplot(data=mypop) +
  geom_tile(mapping=aes(x=s1, y=s2, fill=factor(stratum)), width=1, height=1, size=0.5, colour="white") +
  geom_tile(data=mysample, mapping=aes(x=s1, y=s2), fill=NA, width=1, height=1, size=0.7, colour="black") +
  scale_fill_viridis_d(name="Stratum") +
  scale_x_continuous(name="Easting") +
  scale_y_continuous(name="Northing") +
  coord_fixed()
```


As a first step inclusion probabilities are computed by $\pi_{hk}=n_h/N_h, k=1, \dots , N_h$, with $n_h=N_h/N$ (proportional allocation). 

```{r, eval=FALSE}
N_h <- tapply(mypop$s1,INDEX=mypop$stratum,FUN=length)
n <- 20
n_h <- n*N_h/sum(N_h)
labels <- sort(unique(mypop$stratum))
lut <- data.frame(stratum=labels, pi=n_h/N_h)
mypop<- merge(x=mypop, y=lut, by="stratum")
```

The design matrix $\mathbf{X}$ is computed with function `model.matrix`, expanding the factor `stratum` to a set of dummy variables. By adding `-1` to the formula, we avoid that the first column in the design matrix has all ones. The design matrix has four columns with dummy variables (indicators), indicating to which stratum a unit belongs. 

The columns in the design matrix with dummy variables are multiplied by the vector with inclusion probabilities, using function `sweep `. This is not strictly needed. Using the design matrix with dummy variables implies that the population totals equal the number of population units in the strata, $N_h$. For a perfectly balanced sample, the sample sums of the balancing variables, the dummy variables,  divided by the inclusion probability are also equal to $N_h$.  Multiplication of the dummy variables with the vector with inclusion probabilities implies that the population totals equal the targeted sample sizes per stratum. For a perfectly balanced sample, the sample sums of the balancing variable (having value $\pi_{hk}$ or 0), divided by the inclusion probability are also equal to $n_h$.

```{r }
X <- model.matrix(~ stratum-1, data=mypop)
X <- sweep(X, MARGIN= 1, mypop$pi, `*`)
set.seed(314)
sample_ind <- samplecube(
  X=X, pik=mypop$pi, comment=FALSE, method=1)
mysample <- mypop[sample_ind>(1-eps),]
```

In this case all units in a stratum have the same inclusion probability, yielding  a stratified simple random sample. We may also use variable inclusion probabilities, for instance proportional to a size measure of the units, yielding a stratified pps random sample.

The advantage of selecting a stratified random sample by balancing the sample on a categorical variable becomes clear in case we have multiple classifications that we would like to use in stratification, and we cannot afford to use all cross-classifications as strata. This is the topic of the next section.

### Multi-way stratification {#Multiwaystratification}

@Falorsi2008 describe how a multi-way stratified sample\index{Multi-way stratification} can be selected as a balanced sample. Multi-way stratification is of interest when one has multiple stratification variables, each stratification variable leading to several strata, so that the total number of cross-classification strata\index{Cross-classification strata} becomes so large that the stratum sample sizes are strongly disproportional to their size, or even exceed the total sample size.

Let $M$ be the sum of the number of map units over all maps used for stratification.  For instance, if we have three maps with $4+3+6$ map units, $M$ equals 13.  Instead of using all cross-classification map units as strata, the $M$ map units are used as strata.  The sample sizes of the marginal strata can be controlled by using a design matrix with as many columns as there are strata. The units of an individual map used for stratification are referred to as marginal strata\index{Marginal strata}. Each row $k = 1, \dots, N$ in the design matrix  $\mathbf{X}$ has as many non-zero values as we have maps, in entries corresponding with the cross-classification map unit population unit $k$ belongs to, and zeroes in the remaining entries. The non-zero value is the inclusion probability of that unit. The inclusion probability of a unit is independent of the map used for stratification, so the non-zero values in a row are all equal. Each column of the design matrix has non-zero values at entries corresponding with the population units in that marginal stratum, and zeroes at all other entries.

Two-way stratified random sampling is illustrated with a simulated population of 400 units (Figure \@ref(fig:TwowaystratifiedPopulation)).

```{r TwowaystratifiedPopulation, echo=FALSE, fig.cap="Simulated population, used for illustration of two-way stratified random sampling."}
s1 <- s2 <- 1:20 - 0.5
mypop <- expand.grid(s1, s2)
names(mypop) <- c("s1", "s2")

library(gstat)
vgmodel <- vgm(model="Exp", psill=4, range=4, nugget=0)

dists1 <- outer(mypop$s1, mypop$s1, FUN="-")
dists2 <- outer(mypop$s2, mypop$s2, FUN="-")
dist <- sqrt(dists1^2+dists2^2)
C <- variogramLine(vgmodel, dist_vector=dist, covariance=TRUE)

Upper <- chol(C)
set.seed(314)
N <- nrow(mypop)
G <- rnorm(N,0,1) #simulate random numbers from standard normal distribution
mypop$z <- crossprod(Upper,G)+10

mypop$A <- as.factor(findInterval(mypop$s1, c(5,8,12)))
mypop$B <- as.factor(findInterval(mypop$s2, c(8,15)))
levels(mypop$A) <- c("A1","A2","A3","A4")
levels(mypop$B) <- c("B1","B2","B3")

ggplot(data=mypop) +
  geom_tile(mapping=aes(x=s1, y=s2, fill=z), width=1, height=1, size=0.5) +
  scale_fill_continuous(type="viridis") +
  scale_x_continuous(name="Easting") +
  scale_y_continuous(name="Northing") +
  coord_fixed()
```

Figure \@ref(fig:Twowaystratifiedsample) shows two classifications of the population units. Classification A consists of four classes (map units), classification B of three classes. Instead of using $4 \times 3 = 12$ cross-classifications as strata in random sampling, only $4+3=7$ marginal strata are used in two-way stratified random sampling.

As a first step the inclusion probabilities are added to the data frame `mypop` with the spatial coordinates and simulated values. To keep it simple I computed inclusion probabilities equal to two divided by the number of population units in a cross-classification stratum. Note that this does not imply that a sample is selected with two units per cross-stratum. As we will see later it is possible that in some  cross-classification stratum no units are selected at all, while in other cross-classification strata more than two units are selected. In multi-way stratified sampling the marginal stratum sample sizes are controlled. The inclusion probabilities  should result in six selected units for all four units of map A, and eight selected units for all three units of map B.   

```{r}
mypop <- mypop %>%
    group_by(A, B) %>%
    summarise(N_h=n(), .groups="drop") %>%
    mutate(pih=rep(2,12)/N_h) %>%
    right_join(mypop, by=c("A","B"))
```

The next step is to create the design matrix. Two submatrices are computed, one per stratification. The two submatrices are joined column-wise, using function `cbind`.  The columns are multiplied by the vector with inclusion probabilities.

```{r}
XA <- model.matrix(~A-1, mypop)
XB <- model.matrix(~B-1, mypop)
X <- cbind(XA,XB)
X <- sweep(X, MARGIN= 1, mypop$pih, `*`)
```

Matrix $\mathbf{X}$ can be reduced by one column if in the first column the inclusion probabilities of *all* population units are inserted. This first column contains no zeroes. Balancing on this variable implies that the total sample size is controlled. Now there is no need anymore to control the sample sizes of all marginal strata. It is sufficient to control the sample sizes of three marginal strata of map A and two marginal strata of map B.

```{r}
X <- model.matrix(~A+B, mypop)
X <- sweep(X, MARGIN= 1, mypop$pih, `*`)
```

This reduced design matrix is not strictly needed for selecting a multi-way stratified sample, but must be used in estimation. If in estimation as many balancing variables are used as we have marginal strata, the matrix with the sum of squares of balancing variables in Equation \@ref(eq:betasbalanced)) cannot be inverted (matrix is singular), and as a consequence the population regression coefficients cannot be estimated.

Finally, the two-way stratified random sample is selected with function `samplecube` of package **sampling** [@Tille2016]. 

```{r}
sample_ind <- samplecube(
  X=X, pik=mypop$pih, method=1, comment=FALSE)
eps <- 1e-6
units <- which(sample_ind>(1-eps))
mysample <- mypop[units,]
```

Figure \@ref(fig:Twowaystratifiedsample) shows the selected sample.

```{r, Twowaystratifiedsample, echo=FALSE, out.width='100%', fig.cap="Two-way stratified sample."}
plt1 <- ggplot(data=mypop) +
  geom_tile(mapping=aes(x=s1, y=s2, fill=factor(A)), width=1, height=1, size=0.5, colour="white") +
  geom_tile(data=mysample, mapping=aes(x=s1, y=s2), fill=NA, width=1, height=1, size=0.7, colour="black") +
  scale_fill_viridis_d(name="Stratum") +
  scale_x_continuous(name="") +
  scale_y_continuous(name="") +
  coord_fixed()

plt2 <- ggplot(data=mypop) +
  geom_tile(mapping=aes(x=s1, y=s2, fill=factor(B)), width=1, height=1, size=0.5, colour="white") +
  geom_tile(data=mysample, mapping=aes(x=s1, y=s2), fill=NA, width=1, height=1, size=0.7, colour="black") +
  scale_fill_viridis_d(name="Stratum") +
  scale_y_continuous(name="") +
  scale_x_continuous(name="") +
  coord_fixed()

grid.arrange(plt1, plt2, nrow=1)
```

All marginal sample sizes\index{Marginal sample size} of map A are six, and all marginal sample sizes of map B are eight, as expected. The sample sizes of the cross-classification strata vary from zero to four.

```{r}
addmargins(table(mysample$A, mysample$B))
```

The population mean can be estimated by the $\pi$ estimator.

```{r}
N <- nrow(mypop)
print(mean <- sum(mysample$z/mysample$pih)/N)
```

The variance is estimated as before (Equation \@ref(eq:approxvarianceBalanced)).

```{r}
c <- (1-mysample$pih)
b <- estimate_b(
  z=mysample$z/mysample$pih, X=X[units,]/mysample$pih, c=c)
zpred <- X%*%b
e <- mysample$z-zpred[units]
n <- nrow(mysample)
v_tz <- n/(n-ncol(X))*sum(c*(e/mysample$pih)^2)
print(v_mz <- v_tz/N^2)
```


#### Exercises {-}

1. Spatial clustering of sampling units is not avoided in balanced sampling. What effect do you expect of this spatial clustering on the precision of the estimated mean? Can you think of a situation where this effect does not occur?   

## Well-spread sampling {#Spreaded}

With balanced sampling the spreading of the sampling units in the space spanned by the balancing variables can be poor. For instance, in Figure \@ref(fig:simpleexample)(a) the Easting coordinates of all units of a sample balanced on Easting can be equal or close to the population mean of 10. So, in this example balancing does not guarantee a good geographical spreading. A balanced sample can be selected that shows strong clustering in the space spanned by the balancing variables. This clustering may inflate the standard error of the estimated population total and mean. The clustering in geographical or covariate space can be avoided by the local pivotal method [@Grafstrom2012], and the spatially correlated Poisson sampling method\index{Spatially correlated Poisson sampling} [@Grafstrom2012b]. 

For spreading in *geographical* space various other designs are available. A simple design is stratified random sampling from compact geographical strata, see Section \@ref(geostrata). Alternative designs are generalised random-tessellation stratified sampling [@stevens2004], and balanced acceptance sampling\index{Balanced acceptance sampling} [@Robertson2013].

### Local pivotal method {#LPM}

The local pivotal method (LPM) is a modification of the pivotal method explained in Section \@ref(ppswor)\index{Local pivotal method for well-spread sampling}. The only difference with the pivotal method is the selection of the pairs of units. In the pivotal method at each step two units are selected, for instance, the first two units in the vector with inclusion probabilities after randomizing the order of the units. In the local pivotal method the first unit is selected fully randomly and the nearest neighbour of this unit is used as its counterpart. Recall that when one unit of a pair is included in the sample, the inclusion probability of its counterpart is decreased. This leads to a better spreading of the sampling units in the space spanned by the spreading variables.

LPM can be used for arbitrary inclusion probabilities. The inclusion probabilities can be equal, but as in the pivotal method these probabilities may also differ among the population units.   

Selecting samples with LPM can be done with functions `lpm`, `lpm1` or `lpm2` of package **BalancedSampling** [@Grafstrom2016]. The functions `lpm1` and `lpm2` only differ in the selection of neighbours that are allowed to compete, for details see @Grafstrom2012. For most populations the two algorithms perform similar (personal communication Anton Grafstr&ouml;m). The algorithm implemented in the function `lpm` is only recommended when the population size is too large for `lpm1` or `lpm2`. It only uses a subset of the population in search for nearest neighbours, and is thus not as good. Another function ` lpm2_kdtree` of package  **SamplingBigData** [@samplingBigData] is developed for big data sets.

Inclusion probabilities are computed with function `inclusionprobabilities` of package **sampling**.  A matrix $\mathbf{X}$ must be defined with the values of the spreading variables of the population units. Figure \@ref(fig:LPMKandahar) shows a sample of 40 units selected from the sampling frame of Kandahar, using the spatial coordinates of the population units as spreading variables. Inclusion probabilities are proportional to the agricultural area within the population units. The geographical spreading is improved compared with the sample shown in Figure \@ref(fig:ppswrKandahar). 

```{r}
library(BalancedSampling)
library(sampling)
load("data/Kandahar.RData")
n <- 40
pi <- inclusionprobabilities(grdKandahar$agri, n)
X <- cbind(grdKandahar$x, grdKandahar$y)
set.seed(314)
units <- lpm1(pi, X)
myLPMsample <- grdKandahar[units,]
```

```{r LPMKandahar, echo=FALSE, out.width='100%', fig.cap="Spatial ppswor sample selected by local pivotal method, using agricultural area as size variable."}
ggplot(data=grdKandahar) +
  geom_raster(mapping=aes(x=x, y=y, fill=agri)) +
  geom_tile(data=myLPMsample, mapping=aes(x=x, y=y), colour="white", size=0.7, width=5, height=5, fill=NA) +
  scale_fill_viridis_c(name="Agric. area") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

The total poppy area can be estimated with the $\pi$ estimator (Equation \@ref(eq:HTTotalppswor)).

```{r}
myLPMsample$pi <- pi[units]
tz_HT <- sum(myLPMsample$poppy/myLPMsample$pi)
```

The estimated total poppy area equals `r as.character(round(tz_HT,0))` ha. The sampling variance of the estimator of the population total with the local pivotal method can be estimated by [@Grafstrom2014]

\begin{equation}
\widehat{V}(\hat{t}(z)) = \frac{1}{2} \sum_{k \in \mathcal{S}} \left( \frac{z_k}{\pi_k} - \frac{z_{k_j}}{\pi_{k_j}} \right)^2 \;,
(\#eq:VartotalLPM)
\end{equation}

with ${k_j}$ the nearest neighbour of unit $k$ in the sample. This variance estimator is for the case where we have only one nearest neighbour.

Function `vsb` of package **BalancedSampling** is an implementation of a more general variance estimator that accounts for more than one nearest neighbour (equation 6 in @Grafstrom2014). We expect a somewhat smaller variance compared to pps sampling, so we may use the variance of the pwr estimator (Equation \@ref(eq:VarHHTotalppswr)) as a conservative variance estimator\index{Conservative variance estimator}.

```{r vartotLPM}
Xsample <- X[units,]
se_tz_HT <- sqrt(vsb(pi[units], myLPMsample$poppy, Xsample))
pk <- myLPMsample$pi/n
se_tz_pwr <- sqrt(var(myLPMsample$poppy/pk)/n)
```

The standard error obtained with function `vsb` equals `r as.character(round(se_tz_HT,0))`, the standard error of the Hansen-Hurwitz estimator equals  `r as.character(round(se_tz_pwr,0))`. So in this case the Hansen-Hurwitz variance estimator is smaller than the other variance estimator, but on average it will be larger.

As explained above, the LPM design can also be used to select a probability sample well-spread in the space spanned by one or more quantitative covariates. Matrix $\mathbf{X}$ then should contain the values of the *scaled* (standardised) covariates instead of the spatial coordinates.

#### Exercises {-}

2. Geographical spreading of the sampling units can also be achieved by random sampling from compact geographical strata (Section \@ref(geostrata)). Can you think of one or more advantages of LPM sampling over random sampling from geostrata?  

### Generalised random-tessellation stratified sampling {#GRTS}

Generalised random-tessellation stratified sampling\index{Generalised random-tessellation stratified sampling} (GRTS) is designed for sampling discrete objects scattered throughout space, think for instance of the lakes in Finland, segments of hedgerows in England etc.  Each object is represented by a point in 2D-space. It is a complicated design, and for sampling points from a continuous universe, or raster cells from a finite population, I recommend more simple designs such as the local pivotal method (Section \@ref(LPM)), balanced sampling with geographical spreading (Section \@ref(BalancedandSpreaded)), or sampling from compact geographical strata (Section \@ref(geostrata)).  Let me try to explain the GRTS design with a simple example of a finite population of point objects in a circular study area (Figure  \@ref(fig:GRTSNumbering)). For a more detailed description of this design I refer to @Hankin2019. As a first step a square bounding box of the study area is constructed. This bounding box is recursively partitioned into square grid cells. First 2 x 2 grid cells are constructed. These grid cells are numbered in a predefined order. In Figure  \@ref(fig:GRTSNumbering)(b) this numbering is from lower left, lower right, upper left to upper right. Each grid cell is then subdivided into four subcells; the subcells are numbered using the same order. This is repeated until at most one population unit occurs in each subcell. For our population only two iterations were needed, leading to 4 x 4 subcells. Note that in some subcells no population unit occurs. Each address of a subcell consists of two digits, the first digit is for the grid cell, the second digit for the subcell. 

```{r GRTSNumbering, echo=FALSE, out.width="100%", fig.cap = "Numbering of grid cells and subcells for GRTS sampling."}
s1 <- s2 <- 1:100 - 0.5
pxl <- expand.grid(s1, s2)
names(pxl) <- c("s1", "s2")

#construct strata level 1
s1bnd <- 50
s1f <- findInterval(pxl$s1, s1bnd)
s2f <- findInterval(pxl$s2, s1bnd)
pxl$partit1 <- factor(interaction(s1f, s2f), labels=c(1,2,3,4))

#construct strata level 2
s1bnd <- seq(from=25, to=75, by=25)
s1f <- findInterval(pxl$s1, s1bnd)
s2f <- findInterval(pxl$s2, s1bnd)
lbl <- c("00","01","10","11","02","03","12","13","20","21","30","31","22","23","32","33")
pxl$partit2 <- factor(interaction(s1f,s2f), labels=lbl)

n_h <- rep(1,times=16)
set.seed(314)
units <- sampling::strata(pxl,stratanames="partit2",
                size=n_h,method="srswor")
myfinpop <- getdata(pxl,units)
#remove some units, and shift fourth point into circle
myfinpop$s1[4] <- 78
units <- sample.int(nrow(myfinpop),2)
myfinpop <- myfinpop[-units,]
N <- nrow(myfinpop)

circle <- data.frame(s1=50, s2=50)
plt1 <- ggplot(data=myfinpop) +
  geom_raster(data=pxl, mapping=aes(x=s1,y=s2), fill="lightgrey")+
  geom_circle(data=circle, aes(x0=s1, y0=s2, r=50), fill="grey")+
  geom_point(mapping=aes(x=s1, y=s2), size=2) +
  scale_fill_discrete(guide="none") +
  coord_fixed()

dat <- expand.grid(x=seq(from=12.5, to=87.5, by=25), y=seq(from=12.5,to=87.5,by=25))
dat$labels <- lbl

plt2 <- ggplot(data=myfinpop) +
  geom_raster(data=pxl, mapping=aes(x=s1, y=s2, fill=as.factor(partit1)), alpha=0.5)+
  geom_circle(data=circle, mapping=aes(x0=s1, y0=s2, r=50))+
  geom_vline(xintercept=c(25,50,75))+
  geom_hline(yintercept=c(25,50,75))+
  geom_point(mapping=aes(x=s1, y=s2), size=2) +
  geom_text(data=dat,mapping=aes(x=x, y=y, label=labels)) +
  scale_fill_viridis_d(guide="none") +
  coord_fixed()

grid.arrange(plt1, plt2, nrow=1)
```

The next step is to place the sixteen subcells on a line in a random order. The randomisation is done hierarchically. First the four grid cells at the highest level are randomized. In our example the randomized order is 1, 2, 3, 0 (Figure \@ref(fig:GRTS)). Then within each grid cell the order of the subcells is randomized. This is done independently for the grid cells. In our example for grid cell 1 the randomized order of the subcells is 2, 1, 3, 0 (Figure \@ref(fig:GRTS)). Note that the empty subcells, subcells (0,0) and (3,3) are removed from the line.

```{r}
set.seed(314)
ord <- sample.int(4,4)
myfinpop_rand <- NULL
for (i in ord) {
  units <- which(myfinpop$partit1==i)
  units_rand <- sample(units, size=length(units))
  myfinpop_rand <- rbind(myfinpop_rand, myfinpop[units_rand,])
}
```

After the subcells are placed on a line, a one-dimensional systematic random sample is selected (Figure \@ref(fig:GRTS)), see also Section \@ref(Systematicpps). This can be done either with equal or unequal inclusion probabilities. With equal inclusion probabilities the length of the lines representing the population units is constant. With unequal inclusion probabilities the length of the lines is proportional to a size variable. For a sample size of $n$, the total line is divided into $n$ segments of equal length. A random point is selected in the first segment, and the other points of the systematic sample are determined. Finally, the population units corresponding with the selected systematic sample are identified. With equal probabilities the five selected units are the units in subcells 11, 23, 22, 32 and 03 (Figure \@ref(fig:GRTS)). 

```{r sys1D}
size <- rep(1,N)
n <- 5
interval <- sum(size)/n
start <- round(runif(1)*interval,2)
mysys <- c(start,1:(n-1)*interval+start)
```

```{r GRTS, echo=FALSE, fig.asp=.15, fig.cap = "Systematic random sample along a line with equal inclusion probabilities."}
cellbound <- c(0, cumsum(size))
#compute width of cells
w <- diff(cellbound)
#compute x coordinates halfway the cell boundaries
x <- cellbound[1:N]+w/2

n1 <- table(myfinpop_rand$partit1)
address_1 <- rep(ord, n1[ord])
address <- myfinpop_rand$partit2

datfr <- data.frame(x, y=rep(1,N), address_1, address, w)
ggplot(data=datfr) +
  geom_tile(mapping=aes(x=x, y=y, fill=factor(address_1), width=w), alpha=0.5) +
  geom_text(mapping=aes(x=x, y=y, label=address)) +
  geom_vline(xintercept=cellbound, linetype=2)+
  scale_y_continuous("", breaks=c())+
  scale_x_continuous("", breaks=mysys)+
  scale_fill_viridis_d(guide="none")
```
Figure \@ref(fig:GRTSpps) shows a systematic random sample along a line with unequal inclusion probabilities. The inclusion probabilities are proportional to a size variable, with values 1, 2, 3 or 4. The selected population units are the units in subcells 10, 20, 31, 01 and 02.

```{r GRTSpps, echo=FALSE, fig.asp=.15, fig.cap = "Systematic random sample along a line with inclusion probabilities proportional to size."}
size <- sample.int(4, size=N, replace=TRUE)
n <- 5
interval <- sum(size)/n
start <- round(runif(1)*interval,2)
mysyspps <- c(start,1:(n-1)*interval+start)

cellbound <- c(0,cumsum(size))
w <- diff(cellbound)
x <- cellbound[1:N]+w/2
datfr <- data.frame(x, y=rep(1,N), address_1, address, w)
ggplot(data=datfr) +
  geom_tile(mapping=aes(x=x, y=y, fill=factor(address_1), width=w), alpha=0.5) +
  geom_text(mapping=aes(x=x, y=y, label=address)) +
  geom_vline(xintercept=cellbound, linetype=2)+
  scale_y_continuous("", breaks=c())+
  scale_x_continuous("", breaks=mysyspps)+
  scale_fill_viridis_d(guide="none")
```

GRTS samples can be selected with function `grts` of package **spsurvey** [@spsurvey]. The next code chunk shows the selection of a GRTS sample of 40 units from Kandahar. First a data frame is created representing the sampling frame. With unequal inclusion probabilities this data frame  must include a variable for the inclusion probabilities. Next, a named list specifying the sampling design is created. The first element specifies how many units must be selected. In case of stratified random sampling these sample sizes must be set per stratum. Also, more than one sample can be selected (per stratum), referred to as panels. Per sampling round only one panel is observed. After multiple rounds the sample data can be used for estimating the temporal change of the spatial mean or total. The element `seltype` in the design list must be set to "Continuous" for sampling with probabilities proportional to an ancillary variable specified with argument `mdcaty`. If the argument `shift.grd` is set to TRUE (the default value), the hierarchical grid is shifted to a random position.

```{r GRTSppsKandahar}
library(spsurvey)
n <- 40
pi <- inclusionprobabilities(grdKandahar$agri, n)
N <- nrow(grdKandahar)
samplingframe <- data.frame(
  x=grdKandahar$x, y=grdKandahar$y, mdcaty=pi, ids=1:N)
design <- list(
  None=list(panel=c(PanelOne=n), seltype="Continuous"))
set.seed(314)
res <- grts(
  design, type.frame="finite", src.frame="att.frame",
  att.frame=samplingframe, xcoord="x", ycoord="y",
  mdcaty="mdcaty", do.sample=TRUE, shapefile=FALSE)
units <- res$ids
myGRTSsample <- grdKandahar[units,]
```

The total poppy area is estimated by the $\pi$ estimator.

```{r estimationGRTSKandahar}
tz_GRTS <- sum(myGRTSsample$poppy/pi[units])
```

The estimated total is `r as.character(round(tz_GRTS,0))`. Function `vsb` of package **BalancedSampling** can be used to estimate the standard error of the estimated total poppy area.

```{r}
X <- cbind(grdKandahar$x, grdKandahar$y)
Xsample <- X[units,]
sqrt(vsb(pi[units], myGRTSsample$poppy, Xsample)) %>% round(.,0)
```


## Balanced sampling with spreading {#BalancedandSpreaded}

As mentioned in the introduction to this chapter a sample balanced on a covariate still may have a poor spreading along the axis spanned by the covariate. @Grafstrom2013 presented a method for selecting balanced samples that are also well-spread in the space spanned by the covariates, which they refer to as doubly-balanced sampling\index{Doubly-balanced sampling}. If we take one or more covariates as balancing variables, and besides Easting and Northing as spreading variables, this leads to balanced samples with good *geographical* spreading. When the residuals of the regression model show spatial structure (are spatially correlated), the estimated population mean of the study variable becomes more precise thanks to the improved geographical spreading. Balanced samples with spreading can be selected with function `lcube` of package **BalancedSampling** [@Grafstrom2016]. This is illustrated with Eastern Amazonia, using as before lnSWIR2 for balancing the sample.  

```{r lcube}
library(BalancedSampling)
N <- nrow(gridAmazonia)
n <- 100
Xbal <- cbind(rep(1,times=N), gridAmazonia$lnSWIR2)
Xspread <- cbind(gridAmazonia$x1, gridAmazonia$x2)
pi <- rep(n/N, times=N)
set.seed(314)
units <- lcube(Xbal=Xbal, Xspread=Xspread, prob=pi)
mysample <- gridAmazonia[units,]
```

```{r DoublyBalanceSampleAmazonia, echo=FALSE, out.width='100%', fig.cap="Balanced sample, balanced on lnSWIR2, with geograhical spreading from Eastern Amazonia (Brazil)."}
ggplot(data=gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=lnSWIR2)) +
  geom_point(data=mysample, mapping=aes(x=x1/1000, y=x2/1000), size=2)+
  scale_fill_continuous(name="lnSWIR2", type="viridis") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```
Comparing this sample with the balanced sample in Figure \@ref(fig:BalancedSampleAmazonia) shows that the geographical spreading of the sample is improved, although there still are some close points. The $\pi$ estimate of the mean is `r mean(mysample$AGB)`.

The variance of the estimator of the mean can be estimated by (equation 7, @Grafstrom2013)

\begin{equation}
\widehat{V}(\hat{\bar{z}}) = \frac{n}{n-p}\frac{p}{p+1} \sum_{k \in \mathcal{S}}(1-\pi_k) \left(\frac{\epsilon_k}{\pi_k}-\bar{\epsilon}_k \right)^2 \;,
(\#eq:VarmeanDoublyBalanced)
\end{equation}

with $p$ the number of balancing variables, $\epsilon_k$ the regression model residual of unit $k$ (Equation \@ref(eq:residualsBalanced)), and $\bar{\epsilon}_k$ the local mean of the residuals of this unit, computed by

\begin{equation}
\bar{\epsilon}_k = \frac{\sum_{j=1}^{p+1}(1-\pi_j)\frac{\epsilon_j}{\pi_j}}{\sum_{j=1}^{p+1}(1-\pi_j)}\;.
(\#eq:localmeanresdual)
\end{equation}

This variance estimator is easy to compute with functions `localmean.weight` and `localmean.var` of package **spsurvey** [@spsurvey].

```{r}
library(spsurvey)
pi <- rep(n/N,n)
c <- (1-pi)
b <- estimate_b(z=mysample$AGB/pi, X=Xbal[units,]/pi, c=c)
zpred <- Xbal%*%b
e <- mysample$AGB-zpred[units]
weights <- localmean.weight(
  x=mysample$x1, y=mysample$x2, prb=rep(pi,n), nbh=3)
v_mz <- localmean.var(z=e/pi, weight.lst=weights)/N^2
```

The estimated standard error is `r as.character(round(sqrt(v_mz),1))`, which is considerably smaller than the estimated standard error of the balanced sample without geographical spreading.

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:09-BalancedandSpreaded.Rmd-->

# Model-assisted estimation {#Modelassisted}

In many cases ancillary information is available that could be useful to increase the accuracy of the estimated mean or total of the study variable. The ancillary variable(s) can be qualitative (i.e. classifications) or quantitative. As we have seen before, both types of ancillary variable can be used at the design stage, i.e. in selecting the sampling units, to improve the performance of the sampling strategy, for instance by stratification (Chapter \@ref(STSI)), selecting sampling units with probabilities proportional to size (Chapter \@ref(pps)), or through balancing and/or spreading the sample on the covariates (Chapter \@ref(BalancedSpreaded)). In this chapter I explain how these covariates can be used at the stage of *estimation*, once the data are collected.

In the design-based approach for sampling various estimators are developed that exploit one or more covariates. These estimators are derived from different superpopulation model\index{Superpopulation model} of the study variable. A superpopulation model is a statistical model that can be used to generate an infinite number of populations, a superpopulation, through simulation. An example is the simulation of spatial populations using a geostatistical model, through sequential Gaussian simulation, see Chapter \@ref(MBpredictionofDesignVariance). A superpopulation is a construct, it does not exist in reality. We assume that the population of interest is one of the populations that can be generated with the chosen model. The combination of probability sampling and estimators that are build on a superpopulation model, is referred to as the model-assisted approach\index{Model-assisted approach}. Also in the model-based approach a superpopulation model is used, however, its role is fundamentally different from that in the model-assisted approach, see Chapter \@ref(Approaches). To stress the different use of the superpopulation model in the model-assisted approach this model is referred to as the "working model"\index{Working model}, i.e. the superpopulation model that is used to derive a model-assisted estimator.

@Breidt2017 present an overview of model-assisted estimators derived from a general working model:

\begin{equation}
z_k = \mu(\mathbf{x}_k)+\epsilon_k\;,
(\#eq:workingmodel)
\end{equation}

with $\mu(\mathbf{x}_k)$ the model mean\index{Model mean} for population unit $k$ which is a function of the covariate values of that unit collected in vector $\mathbf{x}_k = (1, x_{1,k}, \dots , x_{J,k})^\mathrm{T}$, and $\epsilon_k$ a random variable with zero mean. The model mean $\mu(\mathbf{x}_k)$ can be a linear or a non-linear combination of the covariates. If the study variable and the covariate values were observed for all population units, all these data can be used to compute a so-called hypothetical population fit\index{Population fit of model parameters} of the model parameters. These model parameters can then be used to compute *estimates* of the model means $\mu(\mathbf{x}_k)$, denoted by $m(\mathbf{x}_k)$, for all population units. For instance, with a multiple regression model $m(\mathbf{x}_k)=\mathbf{x}_k^T \mathbf{b}$, with $\mathbf{b}$ the vector with regression coefficients estimated from observations of the study variable $z$ and the covariates on *all* population units. In practice we have a sample only, which is used to estimate $m(\mathbf{x}_k)$ by $\hat{m}(\mathbf{x}_k)$. For the multiple regression model $\hat{m}(\mathbf{x}_k)= \mathbf{x}_k^T \mathbf{\hat{b}}$, with $\mathbf{\hat{b}}$ the vector with regression coefficients estimated from the sample data. This leads to the generalised difference estimator\index{Generalised difference estimator} [@Wu2001]:

\begin{equation}
\hat{\bar{z}}_{\mathrm{dif}}=\frac{1}{N} \sum_{k=1}^N \hat{m}(\mathbf{x}_k) + \frac{1}{N} \sum_{k \in \mathcal{S}} \frac{z_k-\hat{m}(\mathbf{x}_k)}{\pi_k}\;,
(\#eq:GeneralizedDifferenceEstimator)
\end{equation}

with $\pi_k$ the inclusion probability of unit $k$. The first term is the population mean of model predictions of the study variable, the second term is the $\pi$ estimator of the population mean of the residuals. 

A wide variety of model-assisted estimators have been developed and tested in the past decades. They differ in the working model used to obtain the estimates $\hat{m}(\mathbf{x}_k)$ in Equation \@ref(eq:GeneralizedDifferenceEstimator). The best known class of model-assisted estimators is the generalised regression estimator\index{Regression estimator!generalised regression estimator} that uses a linear model in prediction [@sar92]. Alternative model-assisted estimators are the estimators using machine learning techniques for prediction. In the era of big data with a vastly increasing number of exhaustive data sets, and a rapid development of machine learning techniques, these estimators have great potentials for spatial sample survey.

## Generalized regression estimator {#GREG}

The working model of the generalised regression estimator is the heteroscedastic multiple linear regression model\index{Heteroscedastic multiple linear regression model}:

\begin{equation}
Z_k = \mathbf{x}^\mathrm{T}_k \boldsymbol{\beta}+\epsilon_k \;,
(\#eq:GREGmodel)
\end{equation}

with $\epsilon_k$ uncorrelated residuals, with zero mean and variance $\sigma^2(\epsilon_k)$. Note that I use uppercase $Z$ to distinguish the random variable $Z_k$ of unit $k$ from one realization of this random variable for unit $k$ in the population of interest, $z_k$. Further note that the variance of the residuals $\sigma^2(\epsilon_k)$ need not be constant but may differ among the population units. If $\{z_k,x_{1,k}, \dots , x_{J,k}\}$ were observed for all units $k= 1, \dots , N$ in the population, the regression coefficients $\boldsymbol{\beta}$ would be estimated by

\begin{equation}
\mathbf{b} = \left(\sum_{k=1}^N \frac{\mathbf{x}_k\mathbf{x}_k^{\mathrm{T}}}{\sigma^2(\epsilon_k)}  \right)^{-1} \sum_{k=1}^N \frac{\mathbf{x}_k z_k}{\sigma^2(\epsilon_k)}\;,
(\#eq:populationfitGREG)
\end{equation}

with $\mathbf{x}_k$ the vector $(1, x_{1,k}, \dots , x_{J,k})^\mathrm{T}$, and $\sigma^2(\epsilon_k)$ the variance of the residual of unit $k$. So, similar to the distinction between model mean and population mean (see Chapter \@ref(Approaches)), here the model regression coefficients\index{Model regression coefficient} $\boldsymbol{\beta}$ are distinguished from the population regression coefficients\index{Population regression coefficient} $\mathbf{b}$. The means $m(\mathbf{x}_k)$ would then be computed by

\begin{equation}
m(\mathbf{x}_k) = \mathbf{x}_k^{\mathrm{T}} \mathbf{b}\;.
(\#eq:mxi)
\end{equation}

If we have a probability sample from the population of interest, $\mathbf{b}$ is estimated by replacing the population totals in Equation \@ref(eq:populationfitGREG) by their $\pi$ estimators:

\begin{equation}
\hat{\mathbf{b}} = \left(\sum_{k \in \mathcal{S}} \frac{\mathbf{x}_k\mathbf{x}_k^{\mathrm{T}}}{\sigma^2(\epsilon_k) \pi_k}  \right)^{-1} \sum_{k \in \mathcal{S}} \frac{\mathbf{x}_k z_k}{\sigma^2(\epsilon_k) \pi_k} \;,
(\#eq:EstimatorGREGCoefficients)
\end{equation}

Note that with unequal inclusion probabilities, the design-based estimators of the population regression coefficients differ from the usual ordinary least squares\index{Ordinary least squares} (OLS) estimators of the regression coefficients defined as model parameters. The values $\hat{b}_j$ are estimates of the *population parameters* $b_j$.

The mean values $m(\mathbf{x}_k)$ are now estimated by

\begin{equation}
\hat{m}(\mathbf{x}_k) = \mathbf{x}_k^{\mathrm{T}} \hat{\mathbf{b}}\;.
(\#eq:estmxi)
\end{equation}

Plugging Equation \@ref(eq:estmxi) into the generalised difference estimator, Equation \@ref(eq:GeneralizedDifferenceEstimator), leads to the generalised regression estimator\index{Regression estimator!generalised regression estimator} for the population mean:

\begin{equation}
\hat{\bar{z}}_{\mathrm{regr}} = \frac{1}{N} \sum_{k=1}^N \mathbf{x}_k^{\mathrm{T}} \hat{\mathbf{b}} + \frac{1}{N} \sum_{k \in \mathcal{S}} \frac{z_k-\mathbf{x}^\mathrm{T}_k\hat{\mathbf{b}}} {\pi_k}
  \;.
(\#eq:GREG)
\end{equation}

This estimator can also be written as

\begin{equation}
\hat{\bar{z}}_{\text{regr}}= \hat{\bar{z}}_{\pi}+\sum_{j=1}^J \hat{b}_j(\bar{x}_j-\hat{\bar{x}}_{j,\pi})  \;,
(\#eq:GREG2)
\end{equation}

with $\hat{\bar{z}}_{\pi}$ and $\hat{\bar{x}}_{j,\pi}$ the $\pi$ estimator of the study variable $z$ and the $j$th covariate, respectively, $\bar{x}_j$ the population mean of the $j$th covariate, and $\hat{b}_j$ the estimated slope coefficient associated with the $j$th covariate. So the generalised regression estimate is equal to the $\pi$ estimate when the estimated means of the covariates are equal to the population means. This is the rationale of balanced sampling (Chapter \@ref(BalancedSpreaded)).

The alternative formulation of the regression estimator (Equation \@ref(eq:GREG2)) shows that we do not need to know the covariate values for all population units. Knowledge of the population means of the covariates is sufficient. This is because a linear relation is assumed between the study variable and the covariates. On the contrary, for non-linear working models such as a random forest model, exhaustive knowledge of the covariates is needed so that the estimated mean $\hat{m}(\mathbf{x}_k)$ in Equation \@ref(eq:GeneralizedDifferenceEstimator) can be computed for every unit in the population.

@sar92 worked out the generalised regression estimator for various superpopulation models, such as the simple and multiple linear regression model, the ratio model and the ANOVA model.

### Simple and multiple regression estimators {#RegressionEstimator}

The working model of the simple and multiple regression estimator is the homoscedastic linear regression model\index{Homoscedastic linear regression model}. The only difference with the heteroscedastic model (Equation \@ref(eq:GREGmodel)) is that the variance of the residuals is assumed constant: $\sigma^2(\epsilon_k) = \sigma^2(\epsilon), k = 1 , \dots , N$.

In the simple linear regression model the mean is a linear combination of a single covariate, $\mu(x_k)= \alpha + \beta\;x_k$. The simple linear regression model\index{Simple linear regression model} leads to the simple regression estimator\index{Regression estimator!simple regression estimator}. With simple random sampling this estimator for the population mean is

\begin{equation}
\hat{\bar{z}}_{\text{regr}}= \bar{z}_{\mathcal{S}}+\hat{b}\left( \bar{x}-\bar{x}_{\mathcal{S}}\right) \;,
(\#eq:SimpleRegressionEstimatorSI)
\end{equation}

where $\bar{z}_{\mathcal{S}}$ and $\bar{x}_{\mathcal{S}}$ are the sample means of the study variable and the covariate, respectively, $\bar{x}$ is the population mean of the covariate, and $\hat{b}$ is the estimated slope coefficient:

\begin{equation}
\hat{b}=\frac{\sum_{k \in \mathcal{S}} (x_k-\bar{x}_{\mathcal{S}})(z_k-\bar{z}_{\mathcal{S}})}{\sum_{k \in \mathcal{S}}(x_k-\bar{x}_{\mathcal{S}})^2} \;.
(\#eq:OLSSlope)
\end{equation}

The rationale of the regression estimator is that when the estimated mean of the covariate is, for instance, smaller than the population mean of the covariate, then with a positive correlation between the study variable and covariate, also the estimated mean of the study variable is expected to be smaller than the population mean of the study variable. The difference between the population mean and estimated mean of the covariate can be used to improve the $\pi$ estimate of the mean of $z$ (which is for simple random sampling equal to the sample mean $\bar{z}_{\mathcal{S}}$), by adding a term proportional to the difference between the estimated mean and population mean of the covariate. As a scaling factor the estimated slope of the fitted regression line is used.

The sampling variance of this regression estimator can be estimated by computing first the regression residuals $e_k= z_k - \hat{z}_k,\, i = 1 \dots n$ at the sampling points. To compute these residuals we also need an estimate of the intercept. With simple random sampling this intercept can be estimated by

\begin{equation}
\hat{a} = \bar{z}_{\mathcal{S}} - \hat{b}\; \bar{x}_{\mathcal{S}}\;.
(\#eq:OLSIntercept)
\end{equation}

The sampling variance of the regression estimator is *approximately* equal to the sampling variance of the estimator of the mean of these residuals:

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\mathrm{regr}}\right)=\frac{\widehat{S^{2}}(e)}{n} \;,
(\#eq:VarianceRegressionEstimatorSI)
\end{equation}

with $\widehat{S^{2}}(e)$ the estimated population variance of the regression residuals

\begin{equation}
\widehat{S^{2}}(e)=\frac{1}{n-1}\sum_{k \in \mathcal{S}} e_k^2 \;.
(\#eq:VarianceResiduals)
\end{equation}

The variance estimator is an approximation because the regression coefficients are also estimated from the sample, which makes the regression estimator nonlinear. The approximation of the variance is based on a Taylor linearisation\index{Taylor linearisation of regression estimator} of the regression estimator (@sar92, p. 235). For simple random sampling without replacement from finite populations, the variance estimator must be multiplied by the finite population correction factor  $1-n/N$, see Chapter \@ref(SI).

In the multiple linear regression model\index{Multiple linear regression model} the mean is a linear function of multiple covariates. This model leads to the multiple regression estimator \index{Regression estimator!multiple regression estimator}. With simple random sampling the population regression coefficients of this estimator can be estimated by

\begin{equation}
\hat{\mathbf{b}} = \left(\sum_{k \in \mathcal{S}} \mathbf{x}_k\mathbf{x}_k^{\mathrm{T}} \right)^{-1} \sum_{k \in \mathcal{S}} \mathbf{x}_k z_k \;.
(\#eq:EstimatorMultipleRegressionCoefficients)
\end{equation}

Comparison with the general regression estimator of the population regression coefficients (Equation \@ref(eq:EstimatorGREGCoefficients)) shows that both the variance of the residuals, $\sigma^2(\epsilon_k)$, and the inclusion probabilities $\pi_k$ are missing, as they are (assumed) constant.

The simple regression estimator is illustrated with Eastern Amazonia, see Section \@ref(Datasets). The population mean of the aboveground biomass (AGB) is estimated by the simple regression estimator, using natural logarithms of  MODIS short-wave infrared radiation (SWIR2) as a covariate.

```{r, echo=FALSE}
load("data/Amazonia_1km.RData")
gridAmazonia$lnSWIR2 <- log(gridAmazonia$SWIR2)
units <- sample.int(nrow(gridAmazonia), size=10000, replace=FALSE)
mysample <- gridAmazonia[units,c("AGB","lnSWIR2")]
lm_pop <- lm(AGB~lnSWIR2, data=gridAmazonia)
ab <- coef(lm_pop)
r <- cor(gridAmazonia$AGB, gridAmazonia$lnSWIR2)
```

The correlation coefficient equals `r as.character(round(r,3))`. The slope of the fitted line equals `r as.character(round(ab[2],1))`. Now a simple random sample without replacement of 100 units is selected, and the two population regression coefficients are estimated with Equation \@ref(eq:EstimatorMultipleRegressionCoefficients). 

```{r}
N <- nrow(gridAmazonia) 
n <- 100
set.seed(321)
units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
mysample <- gridAmazonia[units,c("AGB","lnSWIR2")]
X <- matrix(nrow=n,ncol=2,data=1)
X[,2] <- mysample$lnSWIR2
XX <- t(X) %*% X
XX_inv <- chol2inv(chol(XX))
Xz <- t(X) %*% mysample$AGB
print(ab <- t(XX_inv %*% Xz))
```

The same estimates are obtained by ordinary least squares (OLS) fitting of the model with function `lm`. 

```{r}
lm_sample <- lm(AGB~lnSWIR2, data=mysample)
print(ab.mb <- coef(lm_sample))
```

But care must be taken: the design-based estimates of the population regression coefficients are only equal to these model-based OLS estimates of the regression coefficients for equal probability sampling designs. Also be aware that the variance of the design-based estimates of the population regression coefficients is not equal to the model-based variance of the model regression coefficients. See Section 11.2.2.1 in @loh99 for how to estimate the variance of the design-based estimates of the population regression coefficients.

Figure \@ref(fig:ScatterAGBvsSWIR2) shows the scatter plot for the sample and the fitted simple linear regression model. 

```{r ScatterAGBvsSWIR2, echo=FALSE, fig.asp=.6, fig.cap="Scatterplot and fitted simple linear regression model for aboveground biomass (AGB), using lnSWIR2 as predictor, for simple random sample."}
ggplot(data=mysample) +
        geom_point(mapping=aes(x=lnSWIR2, y=AGB)) +
        geom_abline(intercept=ab[1], slope=ab[2])+
        scale_x_continuous(name="lnSWIR2") +
        scale_y_continuous(name="AGB")
```

The simple random sample is used to estimate the population mean of the study variable AGB by the simple regression estimator, and to approximate the sampling variance of the regression estimator. The residuals of the fitted model can be extracted with function `residuals`, because in this case the model-based estimates of the regression coefficients are equal to the design-based estimates.

```{r}
mx_pop <- mean(gridAmazonia$lnSWIR2) 
mx_sam <- mean(mysample$lnSWIR2) 
mz_sam <- mean(mysample$AGB)
mz_regr <- mz_sam+ab[2]*
  (mx_pop-mx_sam)
e <- residuals(lm_sample)
S2e <- var(e)
N <- nrow(gridAmazonia)
se_mz_regr <- sqrt((1-n/N)*S2e/n)
```

The difference $\delta(x)$ between the population mean of the covariate lnSWIR2 (`r as.character(round(mx_pop,3))`) and its estimated mean (`r as.character(round(mx_sam,3))`) equals `r as.character(round(mx_pop - mx_sam,3))`. We may expect the difference between the unknown population mean of the study variable AGB and its sample mean (`r as.character(round(mz_sam,3))`) to be equal to $\delta(x)$, multiplied by the estimated slope of the line, which equals `r as.character(round(ab[2],1))`. The result (`r as.character(round(ab[2]*(mx_pop - mx_sam),4))`) is added to the simple random sample estimate. 

The estimated approximate standard error of the regression estimator equals `r as.character(round(se_mz_regr,3))`. The approximated variance is a simplification of a more complicated approximation derived from writing the regression estimator of the population total as a weighted sum of the observations divided by the inclusion probabilities, see Equation (6.5.9) in @sar92. The alternative expression for the regression estimator of the population mean is

\begin{equation}
\hat{\bar{z}}_{\mathrm{regr}}=\frac{1}{N}\sum_{k \in \mathcal{S}} g_k \frac{z_k}{\pi_k}\;,
(\#eq:AlternativeRegressionEstimator)
\end{equation}

with $g_k$ the weight attached to the observation on sampling unit $k$. For simple random sampling the weights are equal to (Equation 6.5.12 in @sar92)

\begin{equation}
g_k = 1+\frac{(\bar{x}-\bar{x}_{\mathcal{S}})(x_k-\bar{x}_{\mathcal{S}})}{\widehat{S^2}(x)}\;.
(\#eq:RegressionWeights)
\end{equation}

```{r}
S2x <- sum((mysample$lnSWIR2-mean(mysample$lnSWIR2))^2)/n
g <- 1+((mx_pop-mx_sam)*(mysample$lnSWIR2-mx_sam))/S2x
```

The sample mean of the weights equals one,

```{r}
mean(g)
```

and the sample mean of the product of the weights and the covariate $x$ equals the population mean of the covariate.

```{r}
all.equal(mean(g*mysample$lnSWIR2),mean(gridAmazonia$lnSWIR2))
```

In other words, the sample is calibrated on the known population means. The variance of the regression estimator of the population mean can then be approximated by (Section 6.6 in @sar92)

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\mathrm{regr}}\right)=\left(1-\frac{n}{N}\right)\frac{\sum_{k \in \mathcal{S}} g_k^2e_k^2}{n(n-1)} \;.
(\#eq:AlternativeVarianceRegressionEstimator)
\end{equation}

Comparing this with Equation \@ref(eq:VarianceRegressionEstimatorSI) shows that in the first approximation we assumed that all weights are equal to one.

```{r}
S2ge <- sum(g^2*e^2)/(n-1)
(se_mz_regr <- sqrt((1-n/N)*S2ge/n))
```

The regression estimator and its standard error can be computed with package **survey**. After specifying the sampling design with function `svydesign`, function `calibrate` is used to calibrate the sample on the known population totals $N$ and $t(x) = \sum_{k=1}^N x_k$, with $x_k$ the value of covariate lnSWIR2 for unit $k$. 

```{r}
library(survey)
mysample$fpc <- N
design_si <- svydesign(id=~1, data=mysample,  fpc=~fpc)
populationtotals <- c(N,sum(gridAmazonia$lnSWIR2))
mysample_cal <- calibrate(
  design_si, formula=~lnSWIR2, population=populationtotals,
  calfun="linear")
```

The calibrated weights\index{Calibrated weights} can be extracted with function `weights`. These weights are divided by the inclusion probabilities $\pi=n/N$, so that the sample sum of the weights equals $N$, and not the sample size $n$ (as in the code chunk above), 

```{r}
g <- weights(mysample_cal)
all.equal(sum(g),N)
```
and the sample sum of the product of the weights and the covariate equals the population total of the covariate:

```{r}
all.equal(sum(g*mysample$lnSWIR2),sum(gridAmazonia$lnSWIR2))
```

Finally, the population mean can be estimated with function `svymean`. This is simply the sample sum of the product of the weights and the study variable AGB, divided by $N$.

```{r}
svymean(~AGB, mysample_cal)
```

Figure \@ref(fig:SamplingDistributionRegression) shows the sampling distribution of the simple regression estimator along with the distribution of the $\pi$ estimator, obtained by repeating simple random sampling of 100 units and estimation 10,000 times.

```{r, eval=FALSE, echo=FALSE}
number_of_samples <- 10000
mz_HT <- mz_regr <- v_mz_regr <-  numeric(length=number_of_samples)
set.seed(314)
for (i in 1:number_of_samples) {  
  units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
  mysample <- gridAmazonia[units,c("AGB","lnSWIR2")]
  mz_HT[i] <- mean(mysample$AGB)
  mysample$fpc <- N
  design_si <- svydesign(id=~1, data=mysample,  fpc=~fpc)
  mysample_cal <- calibrate(design_si, formula=~lnSWIR2, population=populationtotals, calfun="linear")
  res <- svymean(~AGB,mysample_cal) %>% as.data.frame(.)
  mz_regr[i] <- res$mean
  v_mz_regr[i] <- res$AGB^2
}
save(mz_HT,mz_regr,v_mz_regr, file="results/SimpleRegressionEstimatesAGB_Amazonia.RData")
```

```{r SamplingDistributionRegression, echo=FALSE, fig.asp=.8, fig.cap="Sampling distribution of simple regression estimator and $\\pi$ estimator of mean aboveground biomass (AGB) in Eastern Amazonia, for simple random sampling without replacement of size 100."}
load(file="results/SimpleRegressionEstimatesAGB_Amazonia.RData")
estimates <- data.frame(mz_regr,mz_HT)
names(estimates) <- c("Regression","HT")
df <- estimates %>% pivot_longer(.,cols=c("Regression","HT"))
df$name <- factor(df$name, levels=c("Regression","HT"), ordered=TRUE)
ggplot(data=df) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=mean(gridAmazonia$AGB), colour="red")+
    scale_x_discrete(name="Estimator") +
    scale_y_continuous(name="Estimated mean AGB")

bias <- mean(mz_regr)-mean(gridAmazonia$AGB)
v_mz_regr_sim <- var(mz_regr)
m_v_mz_regr_sim <- mean(v_mz_regr)
v_mz_SI <- (1-n/N)*var(gridAmazonia$AGB)/n
gain <- v_mz_SI/var(mz_regr)
```

The average of the 10,000 regression estimates equals `r as.character(round(mean(mz_regr),3))`. The population mean of the study variable AGB equals `r as.character(round(mean(gridAmazonia$AGB),3))`, so the estimated bias of the regression estimator equals `r as.character(round(bias,3))`. The variance of the 10,000 regression estimates equals `r as.character(round(v_mz_regr_sim,3))`, and the average of the 10,000 estimated approximate variances equals `r as.character(round(m_v_mz_regr_sim,3))`. The gain in precision due to the regression estimator, quantified by the ratio of the variance of the $\pi$ estimator to the variance of the regression estimator equals `r as.character(round(gain,3))`.

Using multiple covariates in the regression estimator is straightforward with the function `calibrate`. As a first step the best model is selected with function `regsubsets` of package **leaps** [@leaps].

```{r}
library(leaps)
n <- 100
set.seed(321)
units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
covars <- c("AGB","lnSWIR2","Terra_PP","Prec_dm",
            "Elevation","Clay")
mysample <- gridAmazonia[units,covars]
models <- regsubsets(AGB~., data=mysample, nvmax=4)
res.sum <- summary(models)
res.sum$outmat
```

The best model with one predictor is the model with lnSWIR2, the best model with two predictors is the one with lnSWIR2 and Terra_PP, etc. Of these models the third model, i.e. the model with lnSWIR2, Terra_PP and Elevation is the best when using adjusted $R^2$ as a selection criterion.

```{r}
which.max(res.sum$adjr2)
```

The standard error of the estimated mean of AGB is somewhat reduced by adding the covariates Terra_PP and Elevation to the regression estimator.

```{r}
mysample$fpc <- nrow(gridAmazonia)
design_si <- svydesign(id=~1, data=mysample, fpc=~fpc)
totals <- c(nrow(gridAmazonia),
            sum(gridAmazonia$lnSWIR2),
            sum(gridAmazonia$Terra_PP),
            sum(gridAmazonia$Elevation))
mysample_cal <- calibrate(
  design_si, formula=~lnSWIR2+Terra_PP+Elevation,
  population=totals, calfun="linear")
svymean(~AGB, mysample_cal)
```

Another interesting package for model-assisted estimation is package **mase** [@mase2018]. The regression estimate can be computed with function `greg`.

```{r}
library(mase)
covars <- c("lnSWIR2","Terra_PP","Elevation")
res <- greg(
  y=mysample$AGB, xsample=mysample[covars],
  xpop=gridAmazonia[covars], pi=rep(n/N,n),
  var_est=TRUE, var_method="LinHTSRS", model="linear")
res$pop_mean
```

The multiple regression estimate is equal to the estimate obtained with function `calibrate` of package **survey**. The estimated standard error equals

```{r}
sqrt(res$pop_mean_var)
```

which is slightly smaller than the standard error computed with package **survey**. This standard error is computed by ignoring the g-weights [@McConville2020].  

```{r, eval=FALSE}
mlr <- lm(AGB~lnSWIR2+Terra_PP+Elevation,data=mysample)
e <- residuals(mlr)
S2e <- var(e)
print(se <- sqrt((1-n/N)*S2e/n))
```

### Penalised least squares estimation

In the previous section I first selected a best subset of covariates before using these covariates in estimating the population regression coefficients. The alternative is to skip the selection of the best model, and to estimate the population regression coefficients of *all* covariates by penalised least squares estimation\index{Penalised least squares estimation} (PLS). In PLS a penalty equal to the sum of the absolute or squared values of the population regression coefficients is added to the minimisation criterion, see  @McConville2020 for details. PLS is implemented in function `gregElasticNet` of package **mase**. 

```{r}
covars <- c("lnSWIR2","Terra_PP","Prec_dm","Elevation","Clay")
res <- gregElasticNet(
  y=mysample$AGB, xsample=mysample[covars],
  xpop=gridAmazonia[covars], pi=rep(n/N,n),
  var_est=TRUE, var_method="LinHTSRS", model="linear",
  lambda="lambda.min", cvfolds=100)
signif(res$coefficients,4)
```

All five covariates are used in prediction, but the coefficients associated with these predictors are small except for lnSWIR2.

The estimated standard error is considerably larger than the standard error obtained with lnSWIR2, Terra_PP and Elevation as predictors, so in this case the elastic net regression estimator\index{Regression estimator!elastic net regression estimator} works not as well as the multiple regression estimator using the best subset of the covariates.

```{r}
sqrt(res$pop_mean_var)
```

#### Exercises {-}

1. The data for this Exercise are in `data/Amazonia_1km.RData`. Write an **R** script to
    + Compute the sampling variance of the simple regression estimator of the mean of AGB, using lnSWIR2 as a covariate, for simple random sampling and sample sizes of 10, 25 and 100, assuming that the population regression coefficients are perfectly known. Hint: fit a simple linear regression model on all data, and compute the population variance of the residuals.  
    + Select 10,000 times a simple random sample with replacement of size 10 (use a for-loop). Use each sample to estimate the population mean of AGB with the simple regression estimator (using sample estimates of the population regression coefficients), and estimate the approximate variance of the estimator of the mean.  Compute the variance of the 10,000 regression estimates and the average of the 10,000 approximate variance estimates. Repeat this for sample sizes 25, 100.   
    + Compute for each sample size the difference between the experimental variance (variance of the 10,000 regression estimates) and the variance obtained with the population fit of the regression model as a proportion of the experimental variance. Explain what you see.   
    + Compute for each sample size the difference between the average of the 10,000 approximated variances and the experimental variance, as a proportion of the experimental variance. Explain what you see.  

### Regression estimator with stratified simple random sampling {#RegressionEstimatorSTSI}

With stratified simple random sampling there are two regression estimators, the *separate* and the *combined* regression estimator. In the first estimator the regression estimator for simple random sampling is applied at the level of the strata\index{Regression estimator!separate regression estimator}. This implies that for each stratum separately a vector with population regression coefficients $\mathbf{b}_h$ is estimated. The regression estimates of the stratum means are then combined by computing the weighted average, using the relative sizes of the strata as weights:

\begin{equation}
\hat{\bar{z}}_{\mathrm{sregr}}=\sum_{h=1}^H w_h \hat{\bar{z}}_{\text{regr,}h} \;,
(\#eq:SeparateRegressionEstimator)
\end{equation}

with, for the simple linear estimator

\begin{equation}
\hat{\bar{z}}_{\text{regr,}h} = \bar{z}_{\mathcal{S}h}+\hat{b}_h\left( \bar{x}_h-\bar{x}_{\mathcal{S}h}\right) \;,
(\#eq:RegressionEstimatorStratumMean)
\end{equation}

with $\bar{z}_{\mathcal{S}h}$ and $\bar{x}_{\mathcal{S}h}$ the stratum sample means of the study variable and covariate, respectively, $\bar{x}_h$ the  mean of the covariate in stratum $h$, and $\hat{b}_h$ the estimated slope coefficient for stratum $h$.

The variance of this separate regression estimator of the population mean can be estimated by first estimating the variances of the regression estimators of the stratum means using Equation \@ref(eq:VarianceRegressionEstimatorSI), and then combining these variances using Equation \@ref(eq:EstVarMeanSTSI).

The separate regression estimator is illustrated with Eastern Amazonia. Biomes are used as strata. There are four biomes, the levels of which are given short names using function `levels`. 

```{r}
library(sampling)
gridAmazonia$Biome <- as.factor(gridAmazonia$Biome)
levels(gridAmazonia$Biome)
```

```{r}
biomes <- c("Mangrove", "Forest.dry","Grassland","Forest.moist")
levels(gridAmazonia$Biome) <- biomes
```

Moist forest is by far the largest stratum, it covers 92\% of the area. Mangrove, dry forest and grassland cover 0.4\%, 2.3\% and 5.5\% of the area, respectively.  A stratified simple random sample of size 100 is selected using function `strata` of package **sampling** [@Tille2016], see Chapter \@ref(STSI). I chose five units as a minimum sample size. Note that the stratum sample sizes are not proportional to their size.

```{r}
ord <- unique(gridAmazonia$Biome)
N_h <-  table(gridAmazonia$Biome)
n_h <- c(5,5,5,85)
set.seed(314)
units <- sampling::strata(
  gridAmazonia, stratanames="Biome", size=n_h[ord],
  method="srswor")
mysample <- getdata(gridAmazonia,units)
```

As a first step in estimation, for each stratum the mean of the covariate over all units in a stratum (population mean per stratum) and the sample means of the study variable and covariate are computed.

```{r}
mx_h_pop <- tapply(
  gridAmazonia$lnSWIR2, INDEX=gridAmazonia$Biome, FUN=mean)
mzh_sam <- tapply(
  mysample$AGB, INDEX=mysample$Biome, FUN=mean)
mx_h_sam <- tapply(
  mysample$lnSWIR2, INDEX=mysample$Biome, FUN=mean)
```

The next step is to estimate the regression coefficients per stratum. This is done in a for-loop. The estimated slope coefficient is used to compute the regression estimator per stratum. The residuals are extracted to approximate the variance of the regression estimator per stratum.

```{r}
b_h <- mz_h_regr <- v_mz_h_regr <- numeric(length=4)
for (i in 1:4) {
  subsam <- subset(
    mysample, mysample$Biome==levels(gridAmazonia$Biome)[i])
  lm_sample <- lm(AGB~lnSWIR2, data=subsam)
  b_h[i] <- coef(lm_sample)[2]
  mz_h_regr[i] <- mzh_sam[i]+b_h[i]*
    (mx_h_pop[i]-mx_h_sam[i])
  e <- residuals(lm_sample)
  S2e_h <- var(e)
  v_mz_h_regr[i] <- (1-n_h[i]/N_h[i])*S2e_h/n_h[i]
}
```

Finally, the separate regression estimate is computed as a weighted average of the regression estimates per stratum,

```{r}
w_h <- N_h/sum(N_h)
print(mz_sepreg <- sum(w_h*mz_h_regr))
```

and its standard error by the square root of the pooled variances of the regression estimator per stratum, using the squared relative size of the strata as weights. 

```{r}
sum(w_h^2*v_mz_h_regr) %>% sqrt(.)
```

The separate regression estimator can be computed with package **survey**. The computation of the population totals merits special attention. For the regression estimator with *simple* random sampling these totals are the total number of populations units and the population total of the covariate lnSWIR2. These are the population totals associated with the columns of the design matrix that is constructed with function `lm` to estimate the regression coefficients. The column with ones results in an estimated intercept, the column with lnSWIR2 values in an estimated slope.

The model that is fitted now is an ANCOVA model\index{ANCOVA model} with the factor Biome and covariate lnSWIR2.

```{r}
ancova <- lm(AGB~Biome*lnSWIR2, data=mysample)
```

**R** uses the so-called cornerstone representation of the ANCOVA model. The reference level is stratum Mangrove. The question is what population totals must be assigned to the function `calibrate` with this ANCOVA model. To make this clear, let us have a look at the columns of the design matrix, used to fit the ANCOVA model. Only the first five rows are printed.

```{r}
designmat <- model.matrix(ancova, mysample)
```

```{r, echo=FALSE}
rownames(designmat) <- NULL
designmat[c(1:5),]
```

With this model formulation the first population total is the total number of population units. The second, third and fourth population totals are the number of population units in stratum levels 2, 3 and 4. The fifth population total is the population total of covariate lnSWIR2, and the sixth, seventh and eighth population totals are the totals of covariate lnSWIR2 in stratum levels 2, 3 and 4. Note that the line `names(totals) <- names(coef(ancova))` is not strictly needed. This is just to suppress a warning that the names of the numeric with the population totals does not match the names of the columns of the design matrix. As a consequence we do not need to fit the ANCOVA model, as shown in the code chunk above, either. 

```{r}
N_h <- as.numeric(N_h)
lut <- data.frame(Biome=biomes,N_h)
mysample <- merge(x=mysample, y=lut)
design_stsi <- svydesign(id=~1, strata=~factor(Biome),
                         data=mysample, fpc=~N_h)
tx_pop <- sum(gridAmazonia$lnSWIR2)
tx_h_pop <- N_h*mx_h_pop
totals <- c(sum(N_h),N_h[c(2,3,4)],tx_pop,tx_h_pop[c(2,3,4)])
names(totals) <- names(coef(ancova))
mysample_cal <- calibrate(
  design_stsi, formula=~Biome*lnSWIR2, population=totals,
  calfun="linear")
svymean(~AGB, mysample_cal)
```

Alternatively, we may use the following formula in function `lm`.

```{r}
ancova2 <- lm(AGB~0+Biome/lnSWIR2, data=mysample)
designmat <- model.matrix(ancova, mysample)
```

```{r, echo=FALSE}
rownames(designmat) <- NULL
designmat[c(1:5),]
```

With this formula the population totals are the number of population units in stratum levels 1, 2, 3 and 4, and the population totals of covariate lnSWIR2 per stratum.

```{r}
totals <- c(N_h,tx_h_pop)
names(totals) <- names(coef(ancova2))
mysample_cal <- calibrate(
  design_stsi, formula=~0+Biome/lnSWIR2, population=totals,
  calfun="linear")
svymean(~AGB, mysample_cal)
```

Recall the alternative formulation of the regression estimator, Equation \@ref(eq:AlternativeRegressionEstimator), and that the sample sum of the $z$-expanded values multiplied by the calibrated weights $g_k$ are equal to the population totals. This explains why the population totals should match the columns of the design matrix.

#### Combined regression estimator

The alternative to the separate regression estimator is the combined regression estimator\index{Regression estimator!combined regression estimator}

\begin{equation}
\hat{\bar{z}}_{\mathrm{cregr}} = \hat{\bar{z}}_{\pi}+\hat{b}\left( \bar{x}-\hat{\bar{x}}_{\pi}\right) \;,
(\#eq:CombinedRegressionEstimator)
\end{equation}

with $\hat{b}$ the estimated slope coefficient, estimated by Equation \@ref(eq:EstimatorGREGCoefficients), discarding the variance of the residuals $\sigma^2(\epsilon_k)$ as they are assumed constant, and using the appropriate inclusion probabilities which differ among the strata, and $\hat{\bar{z}}_{\pi}$ and $\hat{\bar{x}}_{\pi}$ the $\pi$ estimators of the population mean of the study variable and the covariate with stratified simple random sampling, respectively.

In the combined regression estimator only one regression coefficient $b$ is estimated, the slope coefficient for the entire population. This combined regression estimator is recommended when the stratum sample sizes are small as in our case, so that the estimated regression coefficients per stratum, $\hat{b}_h$, become unreliable. The estimators above are for infinite populations and for stratified simple random sampling with replacement of finite populations. For sampling without replacement from finite populations, finite population corrections $1-n_h/N_h$ must be added to the numerator and denominator of $\hat{b}$.

The approximate variance of the combined regression estimator can be estimated as follows:  

1. Compute residuals: $e_k = z_k - (\hat{a}_{\pi} + \hat{b} x_k)$.  
2. Estimate for each stratum the variance of the estimator of the mean of the residuals: $\widehat{V}\!\left(\hat{\bar{e}}_h\right)=\widehat{S^{2}}_h(e)/n_h$, with $\widehat{S^{2}}_h(e)$ the estimated variance of the residuals in stratum $h$.    
3. Combine the estimated variances per stratum: $\widehat{V}\!\left(\hat{\bar{z}}_{\text{cregr}}\right)=\sum_{h=1}^Hw^2_h\widehat{V}\!\left(\hat{\bar{e}}_h\right)$.

The next code chunk shows the estimation procedure. First the population means of the study variable AGB and of the covariate lnSWIR2 are estimated by the $\pi$ estimator, see Chapter \@ref(STSI).

```{r}
mz_h_HT <- tapply(mysample$AGB, INDEX=mysample$Biome, FUN=mean)
mx_h_HT <- tapply(mysample$lnSWIR2, INDEX=mysample$Biome, FUN=mean)
mz_HT <- sum(w_h*mz_h_HT)
mx_HT <- sum(w_h*mx_h_HT)
```

The next step is to estimate the population regression coefficients, using Equation \@ref(eq:EstimatorGREGCoefficients) in which the variances $\sigma^2(\epsilon_k)$ can be dropped, as these are assumed constant. The inclusion probabilities are in the column `Prob` of `mysample`.  

```{r}
W <- diag(x=1/mysample$Prob,nrow=n,ncol=n)
X <- matrix(nrow=n,ncol=2,data=1)
X[,2] <- mysample$lnSWIR2
XW <- crossprod(X, W)
XWX <- XW %*% X
XWX_inv <- chol2inv(chol(XWX))
XWz <- XW %*% mysample$AGB
print(ab <- t(XWX_inv %*% XWz))
```

Note that the same estimates are obtained by model-based estimation, using weighted least squares\index{Weighted least squares}, based on the assumption of that the variances $\sigma^2(\epsilon_k)$ are proportional to the inclusion probabilities (which is a weird assumption).

```{r}
lm_wls <- lm(AGB~lnSWIR2, weights=1/Prob, data=mysample)
coef(lm_wls)
```

So in model-based estimation the weights differ among the units because of assumed differences in the variance of the residuals, whereas in design-based estimation we assign different weights because the units have different inclusion  probabilities [@loh99].

Finally the combined regression estimate is computed.

```{r}
print(mz_combreg <- mz_HT+ab[2]*(mx_pop-mx_HT))
```

To approximate the variance of the combined regression estimator first the residuals are computed. Then these residuals are used to estimate the spatial variance of the residuals within the strata, $\widehat{S^{2}}_h(e)$, and the variance of the estimator of the mean of the residuals, $\widehat{V}\!\left(\hat{\bar{e}}_h\right)$.

```{r}
mysample$e <- mysample$AGB-(ab[1]+ab[2]*mysample$lnSWIR2)
v_me_h <- numeric(length=4)
for (i in 1:4) {
  subsam <- subset(
    mysample, mysample$Biome==levels(gridAmazonia$Biome)[i])
  S2e_h <- var(subsam$e)
  v_me_h[i] <- (1-n_h[i]/N_h[i])*S2e_h/n_h[i]
}
print(sqrt(sum(w_h^2*v_me_h)))
```

Computing the combined regression estimator with package **survey** goes as follows.

```{r}
design_stsi <- svydesign(
  id=~1, strata=~factor(Biome), data=mysample, fpc=~N_h)
totals <- c(nrow(gridAmazonia),sum(gridAmazonia$lnSWIR2))
mysample_cal <- calibrate(
  design_stsi, formula=~lnSWIR2, population=totals,
  calfun="linear")
svymean(~AGB, mysample_cal)
```

Function `calibrate` computes the regression estimate and its standard error with the calibrated weights\index{Calibrated weights} $g_k$ (Equation 6.5.12 in @sar92). This explains the difference between the two standard errors. In the next code chunk the standard error of the regression estimator is computed with the calibrated weights $g_k$.

```{r}
lut <- data.frame(Biome=biomes,pi=n_h/N_h)
mysample <- merge(x=mysample, y=lut)
S2x <- sum(((mysample$lnSWIR2-mx_HT)^2)/mysample$pi)/
  sum(mysample$pi^-1)
g <- 1+(mx_pop-mx_HT)*(mysample$lnSWIR2-mx_HT)/S2x
lm_sample <- lm(AGB~lnSWIR2, weights=1/Prob, data=mysample)
e <- residuals(lm_sample)
ge <- g*e
S2geh <- tapply(ge,INDEX=mysample$Biome,FUN=var)
print(sqrt(sum(w_h^2*(1-n_h/N_h)*S2geh/n_h)))
```

## Ratio estimator {#RatioEstimator}

In some cases it is reasonable to assume that the fitted line passes through the origin. An example is the case study on poppy area in Kandahar (Chapter \@ref(pps)). The covariate is the agricultural area within the 5 km $\times$ 5 km squares that serve as sampling units. It is reasonable to assume that when the covariate equals zero, also the poppy area is zero. So, if we have an estimate of the ratio of the total poppy area in the population to the total agricultural area in the population, and besides know the total agricultural area in the population, the total poppy area in the population can be estimated by multiplying the estimated ratio with the known population total agricultural area:

\begin{equation}
\hat{t}_{\mathrm{ratio}}(z)=\frac{\hat{t}_{\pi}(z)}{\hat{t}_{\pi}(x)} \;t(x) =  \hat{b} \;t(x)\;,
(\#eq:RatioEstimator)
\end{equation}

with $\hat{t}_{\pi}(z)$ and $\hat{t}_{\pi}(x)$ the $\pi$ estimators of the total of the study variable (poppy area) and ancillary variable (agricultural area), respectively, and $t(x)$ the total of the ancillary variable, which must be known.

The working model\index{Working model} of the ratio estimator\index{Ratio estimator} is a heteroscedastic model, i.e. a model with non-constant variance (see Exercise 2, hereafter):

\begin{eqnarray}
Z(x_k) &=& \beta \;x_k  + \epsilon_k \notag \\
\sigma^2(\epsilon_k) &=& \sigma^2 x_k\;,
(\#eq:ratiomodel)
\end{eqnarray}

with $\beta$ the slope of the line, and $\sigma^2$ a constant (variance of residual for $x_k = 1$).

This is a general estimator that can be used for any sampling design, not only for simple random sampling. For simple random sampling the population means of $z$ and $x$ are estimated by the sample means.

For simple random sampling the sampling variance of the ratio estimator of the population total can be approximated by

\begin{equation}
\widehat{V}\!\left(\hat{t}_{\mathrm{ratio}}(z)\right)=N^2\frac{\widehat{S^{2}}(e)}{n} \;,
(\#eq:VarianceRatioEstimatorSI)
\end{equation}

with $\widehat{S^{2}}(e)$ the estimated variance of the residuals $e_k=z_k-\hat{b}x_k$:

\begin{equation}
\widehat{S^{2}}(e)=\frac{1}{n-1}\sum_{k \in \mathcal{S}}e_k^2 \;.
(\#eq:VarianceResidualsRatioEstimator)
\end{equation}

For simple random sampling without replacement from finite populations Equation \@ref(eq:VarianceRatioEstimatorSI) must be multiplied by $\left(1-\frac{n}{N}\right)$.

The ratio estimator for the total poppy area and the estimator of its variance for a simple random sample without replacement can be estimated as follows.

```{r}
load("data/Kandahar.RData")
n <- 50
N <- nrow(grdKandahar)
units <- sample.int(N, size=n, replace=FALSE)
mysample <- grdKandahar[units,]
b <- mean(mysample$poppy)/mean(mysample$agri)
tx_pop <- sum(grdKandahar$agri)
print(tz_ratio <- b*tx_pop)
e <- mysample$poppy-b*mysample$agri
print(se_tz_ratio <- sqrt(N^2*(1-(n/N))*var(e)/n))
```

A better variance approximation is obtained with Equation \@ref(eq:AlternativeVarianceRegressionEstimator). For the ratio model and simple random sampling the calibrated weights are equal to (@sar92, p. 248)

\begin{equation}
g = \frac{t(x)}{\hat{t}_{\pi}(x)} \;,
(\#eq:weightsratiomodel)
\end{equation}

with $t(x)$ the population total of the covariate, and $\hat{t}_{\pi}(x)$ the $\pi$ estimator of the population total of the covariate.

```{r}
pi <- n/N
tx_HT <- sum(mysample$agri/pi)
g <- tx_pop/tx_HT
S2ge <- sum(g^2*e^2)/(n-1)
print(se_tz_ratio <- sqrt(N^2*(1-n/N)*S2ge/n))
```

Note that to compute `S2ge` $n-1$ is used, as we have now one population regression coefficient only. The ratio  estimate and its standard error can be computed with package **survey** as follows.

```{r}
mysample$N <-N
design_si <- svydesign(id=~1, data=mysample, fpc=~N)
b <- svyratio(~poppy, ~agri, design=design_si)
predict(b, total=tx_pop)
```


```{r SamplingDistributionRatio, echo=FALSE, fig.asp=.8, fig.cap="Sampling distribution of ratio estimator and $\\pi$ estimator of total poppy area (ha) in Kandahar with simple random sampling of size 50."}
number_of_samples <- 10000
tz_ratio <- v_tz_ratio <- tz_HT <- numeric(length=number_of_samples)
set.seed(314)
for (i in 1:number_of_samples) {
  mysample <- sample.int(N,size=n,replace=FALSE)
  b <- mean(grdKandahar$poppy[mysample])/mean(grdKandahar$agri[mysample])
  tz_ratio[i] <- b*tx_pop
  e <- grdKandahar$poppy[mysample]-b*grdKandahar$agri[mysample]
  v_tz_ratio[i] <- N^2*(1-(n/N))*var(e)/n
  tz_HT[i] <- mean(grdKandahar$poppy[mysample])*N
}

estimates <- data.frame(tz_ratio,tz_HT)
names(estimates) <- c("Ratio","HT")
df <- estimates %>% pivot_longer(.,cols=c("Ratio","HT"))
df$name <- factor(df$name, levels=c("Ratio","HT"), ordered=TRUE)
ggplot(data=df) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=mean(grdKandahar$poppy)*N, colour="red")+
    scale_x_discrete(name="Estimator") +
    scale_y_continuous(name="Estimated total poppy area")

m_tz_ratio_sim <- mean(tz_ratio)
bias <- mean(tz_ratio)-sum(grdKandahar$poppy)
v_tz_ratio_sim <- var(tz_ratio)
m_v_tz_ratio_sim <- mean(v_tz_ratio)
gain <- var(tz_HT)/var(tz_ratio)
```

Figure \@ref(fig:SamplingDistributionRatio) shows the sampling distribution of the ratio estimator and $\pi$ estimator, obtained by repeating simple random sampling of size 50 and estimation 10,000 times. The average of the 10,000 ratio estimates of the total poppy area equals `r as.character(round(m_tz_ratio_sim,0))`. The population total of poppy equals `r as.character(round(sum(grdKandahar$poppy),0))`, so the estimated bias of the ratio estimator equals `r as.character(round(bias,0))`. The boxplots in Figure \@ref(fig:SamplingDistributionRatio) show that the ratio estimator has less extreme outliers. The standard deviation of the 10,000 ratio estimates equals `r as.character(round(sqrt(v_tz_ratio_sim),0))`. The gain in precision due to the ratio estimator, quantified by the ratio of the variance of the $\pi$ estimator to the variance of the ratio estimator equals `r as.character(round(gain,2))`.

#### Exercises {-}

2. Write an **R** script to compute the ratio of the population total poppy area and population total agricultural area ($t(z)/t(x)$). Then use all data to fit a linear model without intercept for the poppy area, using the agricultural area as a covariate, assuming that the variance of the residuals is proportional to the agricultural area (heteroscedastic model). Hint: use function `lm` with argument `formula = poppy \sim agri-1` and argument `weights=1/agri`. Also fit a model without intercept, assuming a constant variance of the residuals (homoscedastic model). Compare the estimated slopes of the two models with the ratio of the total poppy area and total agricultural area.  

### Ratio estimators with stratified simple random sampling {#RatioEstimatorSTSI}

With stratified simple random sampling, there are, similar to the regression estimator, two options: either estimate the ratios separately for the strata, or estimate a combined ratio. The separate ratio estimator\index{Ratio estimator!separate ratio estimator} of the population total is

\begin{equation}
\hat{t}_{\mathrm{sratio}}(z)=\sum_{h=1}^H \hat{t}_{\mathrm{ratio},h}(z) \;,
(\#eq:SeparateRatioEstimatorSTSI)
\end{equation}

with

\begin{equation}
\hat{t}_{\mathrm{ratio},h}(z)=\frac{\hat{t}_{\pi,h}(z)}{\hat{t}_{\pi,h}(x)} t_h(x) \;,
(\#eq:RatioEstimatorStratumTotal)
\end{equation}

in which $\hat{t}_{\pi,h}(z)$ and $\hat{t}_{\pi,h}(x)$ are the $\pi$ estimators of the population total of the study variable and the covariate for stratum $h$, respectively.

The combined ratio estimator\index{Ratio estimator!combined ratio estimator} is

\begin{equation}
\hat{t}_{\mathrm{cratio}}(z)=\frac{\sum_{h=1}^H\hat{t}_{\pi,h}(z)}{\sum_{h=1}^H\hat{t}_{\pi,h}(x)} t(x) \;.
(\#eq:CombinedRatioEstimatorSTSI)
\end{equation}

The code chunk below shows how the combined and separate regression estimator can be computed with package **survey**. First two equal-sized strata are computed using the median of the covariate `agri` as a stratum break. Stratum sample sizes are computed, and a stratified simple random sample without replacement is selected.

```{r}
breaks <- quantile(grdKandahar$agri,probs=0.5)
grdKandahar$stratum <- findInterval(grdKandahar$agri,breaks)+1
N_h <-  table(grdKandahar$stratum)
n_h <- round(n*N_h/sum(N_h))
set.seed(314)
units <- sampling::strata(
  grdKandahar, stratanames="stratum", size=n_h, method="srswor")
mysample <- getdata(grdKandahar,units)
```

The stratum sizes `N_h` are added to `mysample`, the function `svydesign` is to specify the sampling design, function `svyratio` is used to estimate the population ratio and its variance, and finally function `predict` is used to estimate the population total.

```{r}
lut <- data.frame(stratum=c(1,2),N_h)
mysample <- merge(x=mysample, y=lut)
design_stsi <- svydesign(
  id=~1,strata=~stratum, data=mysample, fpc=~Freq)
common <- svyratio(~poppy, ~agri, design_stsi, separate=FALSE)
predict(common, total=sum(grdKandahar$agri))
```

The same estimate is obtained with function `calibrate`.

```{r}
mysample_cal <- calibrate(
  design_stsi, ~agri-1, population=tx_pop, variance=1)
svytotal(~poppy, mysample_cal)
```

Computing the separate ratio estimator goes along the same lines. The output object of function `svyratio` contains the estimated ratio and its variance for each stratum separately. To predict the population total the stratum totals of the covariate must be assigned to argument `total` of function ` predict`.

```{r}
separate <- svyratio(~poppy, ~agri, design_stsi, separate=TRUE)
tx_h_pop <- tapply(
  grdKandahar$agri, INDEX=grdKandahar$stratum, FUN=sum)
predict(separate, total=tx_h_pop)
```

### Poststratified estimator {#PoststratifiedEstimator}

In stratified random sampling (Chapter \@ref(STSI)) the population is divided into several disjoint subpopulations, and from each subpopulation a probability sample is selected. The subpopulations then serve as strata. The larger the difference in the stratum means and the smaller the variance within the strata, the larger the gain in precision compared to simple random sampling, see Section \@ref(WhyStratify).

The alternative to using the subpopulations as strata when selecting the population units is to use them as poststrata in estimating the population mean. For instance, if we have selected a simple random sample from a spatial population, and we have a map of subpopulations possibly related to the study variable, then these subpopulations still can be used in the poststratified estimator\index{Poststratified estimator}. What only needs to be done is to classify the selected units. The subpopulations that serve as poststrata are referred to as groups hereafter.

For any probability sampling design the population mean can be estimated by

\begin{equation}
\hat{\bar{z}}_{\text{pos}}=
\sum_{g=1}^{G} w_{g}\frac{\hat{t}_g(z)}{\widehat{N}_{g}} =
\sum_{g=1}^{G} w_{g}\frac{\sum_{k \in \mathcal{S}_g}\frac{z_{k}}{\pi_k}}
{\sum_{k \in \mathcal{S}_g}\frac{1}{\pi_k}} \;,
(\#eq:PostStratifiedEstimator)
\end{equation}

where $\mathcal{S}_g$ is the sample from group $g$, $w_{g}=N_g/N$ is the relative size of group $g$, $\hat{t}_g(z)$ is the estimated total of the study variable for group $g$, $\widehat{N}_{g}$ is the estimated size of $N_g$, $n_{g}$ is the number of sampling units in group $g$ and $\pi_{k}$ is the inclusion probability of unit $k$. The estimated group means are weighted by their relative sizes $w_{g}$, which are assumed to be known. In spite of this, the group means are estimated by dividing the estimated group totals by their \emph{estimated} size, $\widehat{N}_{g}$, because this ratio estimator is more precise than the group sample mean.

This poststratified estimator is the natural estimator for the one-way ANOVA model\index{One-way ANOVA model}:

\begin{eqnarray}
Z_k &=& \mu_g  + \epsilon_k \notag \\
\sigma^2_k &=& \sigma^2_g\;,
(\#eq:ANOVAmodel)
\end{eqnarray}

with $\mu_g$ the mean for group (subpopulation) $g=1, \dots , G$, and $\sigma^2_g$ the variance of the study variable of group $g$.

For simple random sampling, the poststratified estimator reduces to

\begin{equation}
\hat{\bar{z}}_{\text{pos}}=\sum_{g=1}^{G}w_{g}\,\bar{z}_{\mathcal{S}_g} \;,
(\#eq:PostStratifiedEstimatorSI)
\end{equation}

where $\bar{z}_{\mathcal{S}_g}$ is the sample mean of group $g$. If for all groups we have at least two sampling units, $n_g \geq 2$, the variance of this poststratified estimator of the mean can be estimated by 

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\text{pos}}|\mathbf{n}_g\right)=
\sum_{g=1}^{G}w_{g}^{2}\frac{\widehat{S_{g}^{2}}}{n_{g}} \;,
(\#eq:CondVarPostStratifiedEstimator)
\end{equation}

where $\widehat{S_{g}^{2}}$ is the estimated spatial variance of $z$ in
group $g$, which for simple random sampling can be estimated by

\begin{equation}
\widehat{S_{g}^{2}}=\frac{1}{n_{g}-1}\sum_{k \in \mathcal{S}_g}(z_{k}-\bar{z}_{\mathcal{S}_g})^{2} \;.
(\#eq:S2g)
\end{equation}

This is an estimator of the *conditional* sampling variance, i.e. the variance of the poststratified estimator over all simple random samples with group sample sizes, collected in the vector $\mathbf{n}_g$, equal to the group sample sizes in the sample actually selected. The poststratified estimator requires that the sizes (area) of the strata are known. See Section \@ref(TwophaseStratification) for a sampling strategy that does not require known stratum sizes.

The poststratified estimator is illustrated with study area Voorst. We consider the situation that we do not have the map with the five combinations of soil type and land use that served as strata in Chapter \@ref(STSI). The soil type - land use classes (groups) used in the poststratified estimator are only observed at the selected sampling units. Only three poststrata are distinguished: the original strata BA, EA and PA are merged into one stratum SA with function `fct_collapse` of package **forcats** [@forcats].  The sizes of these poststrata must be known. 

```{r poststratification}
load("data/Voorst.RData")
library(forcats)
grdVoorst$poststratum <- 
  fct_collapse(grdVoorst$stratum, SA=c("BA","EA","PA"))
print(N_g <- tapply(
  grdVoorst$z, INDEX=grdVoorst$poststratum, FUN=length))
```

One hundred points are selected by simple random sampling with replacement. The expected sample sizes per group are proportional to the size of the groups, $E(n_g/n) = N_g/N$), but for a single sample the sample proportions may deviate considerably from the population proportions. 

```{r}
n <- 100
N <- nrow(grdVoorst)
set.seed(314)
units <- sample.int(N, size=n, replace=TRUE)
mysample <- grdVoorst[units,]
n_g <- tapply(mysample$z, INDEX=mysample$poststratum, FUN=length)
print(n_g)
```

The population mean is estimated by first computing the sample means per group, followed by computing the weighted average of the sample means, using the relative sizes of the groups as weights. 

```{r}
mz_g <- tapply(mysample$z, INDEX=mysample$poststratum, FUN=mean)
w_g <- N_g/N
print(mean.poststrat <- sum(w_g*mz_g))
```

```{r, echo=FALSE}
n_g <- as.numeric(n_g)
```

The variance of the estimator of the mean is estimated by computing the sample variances per group, dividing these by the sample sizes per group, and computing the weighted average, using as weights the squared relative group sizes. This estimated sampling variance is the variance of the estimator of the mean over all simple random samples with `r n_g[1]` units of group SA, `r n_g[2]` units of group RA and `r n_g[3]` units of XF.

```{r}
S2z_g <- tapply(mysample$z, INDEX=mysample$poststratum, FUN=var)
v_mz_g <- S2z_g/as.numeric(n_g)
print(condse_mz <- sqrt(sum(w_g^2*v_mz_g)))
```

Note that this variance estimator can only be computed with at least two units per group. For that reason, I recommend to use a limited number of groups, especially for small sample sizes.

Function `postStratify` of package **survey** can be used to compute the poststratified estimator, and its standard error.

```{r}
mysample$weights <- N/n
design_si <- svydesign(id=~1, weights=~weights, data=mysample)
pop <- data.frame(poststratum=c("SA","RA","XF"), Freq=N_g)
mysample_pst <- postStratify(
  design_si, strata=~poststratum, population=pop)
svymean(~z, mysample_pst)
```

@loh99 warns for data snooping\index{Data snooping}. By defining groups after analyzing the data, arbitrarily small sampling variances of the estimated mean can be obtained.

## Model-assisted estimation using machine learning techniques {#RandomForest}

@Breidt2017 review model-assisted estimators based on machine learning techniques\index{Machine learning technique}. Of special interest is the general approach proposed by @Wu2001 for incorporating non-linear predictions in the model-assisted estimator. They show how non-linear predictions of the study variable, for instance obtained by a regression tree or random forest, can be used in the model-calibration estimator:

\begin{equation}
\hat{\bar{z}}_{\mathrm{MC}}= \hat{\bar{z}}_{\pi} + \hat{a}\left(1-\frac{1}{N}\sum_{k \in \mathcal{S}}\frac{1}{\pi_k}\right)+ \hat{b}\left(\frac{1}{N}\sum_{k=1}^N \hat{m}(\mathbf{x}_k) - \frac{1}{N}\sum_{k \in \mathcal{S}} \frac{\hat{m}(\mathbf{x}_k)}{\pi_k} \right)
\;,
(\#eq:ModelCalibrationEstimator)
\end{equation}

with $\hat{b}$ a slope coefficient estimated by

\begin{equation}
\hat{b} = \frac{\sum_{k \in \mathcal{S}} 1/\pi_k \{\hat{m}(\mathbf{x}_k)-\hat{\bar{m}}_{\pi}\} \{z_k-\hat{\bar{z}}_{\pi}\}}{\sum_{k \in \mathcal{S}} 1/\pi_k \{\hat{m}(\mathbf{x}_k)-\hat{\bar{m}}_{\pi}\}^2}\;,
(\#eq:SlopeCalibrationEstimator)
\end{equation}

with $\hat{\bar{z}}_{\pi}$ the $\pi$ estimator of the population mean of the study variable, $\hat{\bar{m}}_{\pi}$ the $\pi$ estimator of the population mean of the predicted values, and $\hat{a}$ an intercept estimated by

\begin{equation}
\hat{a} = (1-\hat{b})\left(\frac{1}{N}\sum_{k \in \mathcal{S}}\frac{z_k}{\pi_k}\right)\;.
(\#eq:InterceptCalibrationEstimator)
\end{equation}

The second term in Equation \@ref(eq:ModelCalibrationEstimator) cancels for all sampling designs for which the sum of the design weights, i.e. the sum of the reciprocal of the inclusion probabilities, equals the population size: $\sum_{k \in \mathcal{S}} 1/\pi_k=N$. Only for some unequal probability sampling designs this may not be the case.

The alternative is to plug the fitted values $\hat{m}(\mathbf{x}_k)$ into the generalised difference estimator, Equation \@ref(eq:GeneralizedDifferenceEstimator). If we drop the second term, the model-calibration estimator\index{Model-calibration estimator} can be rewritten as

\begin{equation}
\hat{\bar{z}}_{\mathrm{MC}}=\frac{1}{N}\sum_{k=1}^N\hat{b}\;\hat{m}(\mathbf{x}_k)+\frac{1}{N}\sum_{k \in \mathcal{S}}\frac{z_k-\hat{b}\;\hat{m}(\mathbf{x}_k)}{\pi_k}
\;.
(\#eq:ModelCalibrationEstimator2)
\end{equation}

Comparison with the generalised difference estimator, Equation \@ref(eq:GeneralizedDifferenceEstimator), shows that these two estimators are equivalent when $\hat{b}=1$. For non-linear working models, generally $\hat{b} \neq 1$, so that these two estimators are not the same. @Wu2003 shows that the calibration estimator has a general optimality property.

In case you are confused by all these model-assisted estimators, let me clarify. The most general estimator is the model-calibration estimator. If we take for $\hat{b}$ the value 1, this estimator is equivalent to the generalised difference estimator (Equation \@ref(eq:GeneralizedDifferenceEstimator)). The predictions $\hat{m}(\mathbf{x}_k)$ in these estimators can be computed either by a linear model or a non-linear model. If a linear model is used in the generalised difference estimator, this estimator is equal to the generalised regression estimator. With linear models $\hat{b} = 1$, so that all three estimators are equal. 

For simple random sampling the inclusion probabilities of the units are the same for all points: $\pi_k = n/N$, reducing Equations \@ref(eq:ModelCalibrationEstimator) and \@ref(eq:SlopeCalibrationEstimator) to 

\begin{equation}
\hat{\bar{z}}_{\mathrm{MC}}= \frac{1}{n}\sum_{k \in \mathcal{S}} z_k + \hat{b}_{\mathrm{SI}}\left(\frac{1}{N}\sum_{k=1}^N \hat{m}(\mathbf{x}_k) - \frac{1}{n}\sum_{j \in \mathcal{S}} \hat{m}(\mathbf{x}_j) \right)\;,
(\#eq:ModelCalibrationEstimatorSI)
\end{equation}

with $\hat{b}_{\mathrm{SI}}$ equal to

\begin{equation}
\hat{b}_{\mathrm{SI}} = \frac{\sum_{k \in \mathcal{S}} \{\hat{m}(\mathbf{x}_k)-\bar{m}(\mathbf{x}_k)\}\{z_k-\bar{z}_{\mathcal{S}}\}}{\sum_{k \in \mathcal{S}} \{\hat{m}(\mathbf{x}_k)-\bar{m}(\mathbf{x}_k)\}^2}\;.
(\#eq:RegressionCoefficientCalibrationEstimatorSI)
\end{equation}

The variance of the model-assisted calibration estimator equals
\begin{equation}
V(\hat{\bar{z}}_{\mathrm{MC}})=V(\hat{\bar{\epsilon}}_{\pi})\;,
(\#eq:VarianceCalibrationestimator)
\end{equation}

with $\hat{\bar{\epsilon}}_{\pi}$ the $\pi$ estimator of the population mean of the residuals $\epsilon$. For sampling designs with fixed sample size these residuals are equal to $\epsilon_k=z_k-b\;m(\mathbf{x}_k)$, with $m(\mathbf{x}_k)$ the fitted values based on all population units, and $b$ the population fit of the (superpopulation) regression coefficient:

\begin{equation}
b = \frac{\sum_{k=1}^N \hat{m}(\mathbf{x}_k)z_k}{\sum_{k=1}^N \hat{m}(\mathbf{x}_k)^2}\;.
(\#eq:SlopeCalibrationEstimatorPopulationfit)
\end{equation}

An estimator of the variance is obtained by replacing the population fits $m(\mathbf{x}_k)$ by their sample estimates $\hat{m}(\mathbf{x}_k)$, and $b$ by its estimator, Equation \@ref(eq:SlopeCalibrationEstimator). For simple random sampling with replacement from finite populations and simple random sampling from infinite populations the variance equals

\begin{equation}
V(\hat{\bar{z}}_{\mathrm{MC}})=\frac{S^2(\epsilon)}{n}\;,
(\#eq:VarianceCalibrationestimatorSI)
\end{equation}

with $S^2(\epsilon)$ the population variance of the residuals $\epsilon$.

The variance of the generalised difference estimator equals

\begin{equation}
V(\hat{\bar{z}}_{\mathrm{dif}})=V(\hat{\bar{d}}_{\pi})\;,
(\#eq:VarianceDifferenceestimator)
\end{equation}

with $\hat{\bar{d}}_{\pi}$ the $\pi$ estimator of the population mean of the differences $d_k=z_k-m(\mathbf{x}_k)$. An estimator is obtained by substituting $\hat{m}(\mathbf{x}_k)$ for $m(\mathbf{x}_k)$ to compute the differences.

The data of Eastern Amazonia are used to illustrate model-assisted estimation of AGB, using five environmental covariates in predicting AGB. First a regression tree\index{Regression tree} is used as a machine learning technique for prediction, after that a random forest\index{Random forest}. For an introduction to regression trees and random forest modelling, see this [blog](https://victorzhou.com/blog/intro-to-random-forests/)^[https://victorzhou.com/blog/intro-to-random-forests/]. In this blog the study variable is a categorical variable, whereas in our example the study variable is quantitative (continuous). This is not essential. The only difference is the measure for quantifying how good a split is. With a quantitative study variable this is quantified by the following sum of squares:

\begin{equation}
SS=\sum_{k=1}^2\sum_{k=1}^{N_k}(z_{ki}-\bar{z}_k)^2 \;,
(\#eq:sumofsquaresbinarysplit)
\end{equation}

with $\bar{z}_k$ the sample mean of group $k$.

### Predicting with a regression tree

A simple random sample without replacement of size 100 is selected.

```{r}
N <- nrow(gridAmazonia)
n <- 100
set.seed(314)
units <- sample.int(N, size=n, replace=FALSE)
covs <- c("SWIR2","Terra_PP","Prec_dm","Elevation","Clay")
mysample <- gridAmazonia[units,c("AGB",covs)]
```

Package **rpms** [@rpms] is used to build a regression tree for AGB, using all five covariates as predictors. Note that I now use the original untransformed SWIR2 as a predictor. Transformation of predictors so that the relation with the study variable becomes linear is not needed when fitting a non-linear model such as a regression tree.  Using the default value of 0.05 for argument `pval` leads to the following tree.

```{r}
library(rpms)
tree <- rpms(
  AGB~SWIR2+Terra_PP+Prec_dm+Elevation+Clay, data=mysample,
  pval=0.05)
print(tree)
```

The regression tree is used to predict AGB for all population units.

```{r}
AGBpred <- predict(tree, newdata=gridAmazonia)
```

The population mean is then estimated by the generalised difference estimator.
 
```{r}
d <- gridAmazonia$AGB[units]-AGBpred[units]
mean(AGBpred) + mean(d)
```

Its standard error is estimated by the square root of the variance of the estimator of the mean differences.
 
```{r}
S2d <- var(d)
sqrt((1-n/N)*S2d/n)
```

This estimation procedure is implemented in function `gregTree` of package **mase** [@mase2018].

```{r}
library(mase)
pi <- rep(n/N,n)
res <- gregTree(
  mysample$AGB, xsample=mysample[,covs],
  xpop=gridAmazonia[,covs], pi=pi,
  var_est=TRUE, var_method="LinHTSRS")
res$pop_mean
sqrt(res$pop_mean_var)
```

The variance of the estimator of the mean can also be estimated by bootstrapping the sample (@loh99, Section 9.3.3).
 
```{r, eval=FALSE}
res <- gregTree(
  mysample$AGB, xsample=mysample[,covs],
  xpop=gridAmazonia[,covs], pi=pi,
  var_est=TRUE, var_method="bootstrapSRS", B=100)
```

```{r, echo=FALSE, eval=FALSE}
save(res,file="results/BootstrapVarianceRegressionTreeAGB_Amazonia.RData")
```

```{r, echo=FALSE}
load(file="results/BootstrapVarianceRegressionTreeAGB_Amazonia.RData")
```

```{r}
sqrt(res$pop_mean_var)
```

The standard error obtained by the bootstrap is considerably larger than the previous standard error based on a Taylor linearisation of the estimator of the mean. As we will see hereafter, the Taylor linearisation seriously underestimates the true standard error.

The simple random sampling of 100 units and the model-assisted estimation is repeated 500 times, using a regression tree for prediction. The variance is estimated by Taylor linearisation (`var_method=LinHTSRS`) and by bootstrapping (`var_method=bootstrapSRS`) using 100 bootstrap samples.

```{r, echo=FALSE, eval=FALSE}
mz_rtree <- v_mz_rtree_linHTSRS <- v_mz_rtree_btstrp <- numeric(length=500)
set.seed(314)
for (i in 1:500) {
  print(i)
  units <- sample.int(N, size=n)
  mysample <- gridAmazonia[units,c("AGB","SWIR2","Terra_PP","Prec_dm","Elevation","Clay")]
  res <- gregTree(mysample$AGB, xsample=mysample[,c("SWIR2","Terra_PP","Prec_dm","Elevation","Clay")],
                  xpop=gridAmazonia[,c("SWIR2","Terra_PP","Prec_dm","Elevation","Clay")],
                  pi=pi,
                  var_est=TRUE,
                  var_method="LinHTSRS")
  v_mz_rtree_linHTSRS[i] <- res$pop_mean_var


  res <- gregTree(mysample$AGB, xsample=mysample[,c("SWIR2","Terra_PP","Prec_dm","Elevation","Clay")],
                  xpop=gridAmazonia[,c("SWIR2","Terra_PP","Prec_dm","Elevation","Clay")],
                  pi=pi,
                  var_est=TRUE,
                  var_method="bootstrapSRS",
                  B=100)
  mz_rtree[i] <- res$pop_mean
  v_mz_rtree_btstrp[i] <- res$pop_mean_var
}
save(mz_rtree, v_mz_rtree_linHTSRS, v_mz_rtree_btstrp, file="results/RegressionTreeEstimates_Amazonia_100pnts.RData")
```

```{r, echo=FALSE}
load(file="results/RegressionTreeEstimates_Amazonia_100pnts.RData")
```

The variance of the 500 estimated population means of AGB is `r round(var(mz_rtree),1)`. Estimation of the variance through Taylor linearisation strongly underestimates the variance: the average of the 500 estimated variances equals `r round(mean(v_mz_rtree_linHTSRS),1)`. On the contrary, the bootstrap variance estimator overestimates the variance: the average of the 500 estimated variances equals `r round(mean(v_mz_rtree_btstrp),1)`. I prefer to overestimate my uncertainty about the mean instead of being overoptimistic, and so I would recommend to report the bootstrap variance.

### Predicting with a random forest

The package **ranger** [@Wright2017] is used to fit a random forest model for AGB using the five environmental covariates as predictors and the simple random sample of size 100 selected in the previous section. Function `importance` shows how often the covariates are used in a binary splitting. All five covariates are used, SWIR2 by far most often.

```{r}
library(ranger)
set.seed(314)
forest.sample <- ranger(
  AGB~., data=mysample, num.trees=1000, importance="impurity")
importance(forest.sample)
```

Out-of-bag predictions for the selected units are saved in the element `predictions` of the output-object of the function `ranger`. The fitted model is also used to predict AGB at all `r nrow(gridAmazonia)` units (raster cells), using function `predict`.

```{r, eval=FALSE}
AGBpred_OOB <- forest.sample$predictions 
res <- predict(
  forest.sample, data=gridAmazonia, type="response")
AGBpred <- res$predictions
```

```{r, echo=FALSE, eval=FALSE}
save(AGBpred_OOB, AGBpred, file="results/RandomForestSingleSample_Amazonia.RData")
```

Finally, the model-calibration estimate and the generalised difference estimate are computed. Both estimators and their variances are computed in two ways. They differ in how the study variable AGB is predicted for the sampling units:  

1. Using all trees of the forest (the predictions obtained with function `predict`).  
2. Using only the trees calibrated on bootstrap samples\index{Bootstrap sample} that do not include the sampling unit used as a prediction unit. These out-of-bag predictions are stored in the element `predictions` of the output object of function `ranger`.  

The next code chunk shows how the model-calibration estimate can be computed with the AGB data of the simple random sample and the random forest predictions of AGB. First use all trees.

```{r, echo=FALSE}
load(file="results/RandomForestSingleSample_Amazonia.RData")
```

```{r}
b <- sum((AGBpred[units]-mean(AGBpred[units]))*
           (mysample$AGB-mean(mysample$AGB)))/
        sum((AGBpred[units]-mean(AGBpred[units]))^2)
mz_MC <- mean(mysample$AGB)+
  b*(mean(AGBpred)-mean(AGBpred[units]))
u <- mysample$AGB-AGBpred[units]*b
v_mz_MC <- (1-n/N)*var(u)/n
```

Next, use the out-of-bag predictions\index{Out-of-bag predictions}.

```{r}
b_OOB <- sum((AGBpred_OOB-mean(AGBpred_OOB))*
                (mysample$AGB-mean(mysample$AGB)))/
            sum((AGBpred_OOB-mean(AGBpred_OOB))^2)
mz_MC_OOB <- mean(mysample$AGB)+
  b_OOB*(mean(AGBpred)-mean(AGBpred_OOB))
u_OOB <- mysample$AGB-AGBpred_OOB*b_OOB
v_mz_MC_OOB <- (1-n/N)*var(u_OOB)/n
```

The two calibration estimates are about equal: `r round(mz_MC,1)` using sample predictions obtained with function `predict`, and `r round(mz_MC_OOB,1)` with the out-of-bag sample predictions. However, their estimated variances are largely different: `r as.character(round(v_mz_MC,2))` and `r as.character(round(v_mz_MC_OOB,2))`, respectively. 

In the next code chunk the generalised difference estimate (Equation \@ref(eq:GeneralizedDifferenceEstimator)) is computed. Similar to the model-calibration estimate, this difference estimate is computed from predictions based on all trees, and from the out-of-bag predictions.

```{r}
d <- mysample$AGB-AGBpred[units]
mz_MD <- mean(AGBpred)+mean(d)
v_mz_MD <- (1-n/N)*var(d)/n
#using out-of-bag predictions
d_OOB <- mysample$AGB-AGBpred_OOB
mz_MD_OOB <- mean(AGBpred)+mean(d_OOB)
v_mz_MD_OOB <- (1-n/N)*var(d_OOB)/n
```

For the difference estimator the results are very similar. The two difference estimates are `r round(mz_MD,1)` and `r round(mz_MD_OOB,1)`, and their estimated variances are `r round(v_mz_MD,2)` and `r round(v_mz_MD_OOB,2)`. The model-calibration estimate and the generalised difference estimate are nearly equal.

The sampling and estimation is repeated 1,000 times: 1,000 times a simple random sample of size 100 is selected. Each sample is used to calibrate a random forest, each forest consisting of 1,000 trees. This resulted in 2 $\times$ 1,000 model-calibration estimates and their estimated variances, and 2 $\times$ 1,000 difference estimates and their estimated variances. To limit the computing time a 5 km $\times$ 5 km subgrid is used for selecting the simple random samples and for predicting AGB with the random forest.

```{r, eval=FALSE, echo=FALSE}
load(file="data/Amazonia_5km.RData")
set.seed(314)
mz_MC <- mz_MD <- v_mz_MC <- v_mz_MD <- numeric(length=1000)
mz_MC_OOB <- mz_MD_OOB <- v_mz_MC_OOB <- v_mz_MD_OOB <- numeric(length=1000)
for (i in 1:1000) {
  #select simple random sample
  units <- sample.int(N, size=n)
  mysample <- gridAmazonia[units,c("AGB","SWIR2","Terra_PP","Prec_dm","Elevation","Clay")]

  forest.sample <- ranger(
    AGB ~ .,
    data=mysample,
    num.trees=1000
  )
  AGBpred_OOB <- forest.sample$predictions
# predict for all population units
  res <- predict(forest.sample, data=gridAmazonia, type="response")
  AGBpred <- res$predictions
  
# Calibration estimator
  
# estimate population mean using predictions of RF model calibrated on sample, and sample based estimate of regression coefficient 
  b <- sum((AGBpred[units]-mean(AGBpred[units]))*(mysample$AGB-mean(mysample$AGB)))/sum((AGBpred[units]-mean(AGBpred[units]))^2)
#  b.star <- sum(AGBpred[units]*mysample$AGB)/sum(AGBpred[units]^2)
  mz_MC[i] <- mean(mysample$AGB) + b*(mean(AGBpred)-mean(AGBpred[units]))
  u <- mysample$AGB-AGBpred[units]*b
  v_mz_MC[i] <- (1-n/N)*var(u)/n
  
  b_OOB <- sum((AGBpred_OOB-mean(AGBpred_OOB))*(mysample$AGB-mean(mysample$AGB)))/sum((AGBpred_OOB-mean(AGBpred_OOB))^2)
#  b.star_OOB <- sum(AGBpred_OOB*mysample$AGB)/sum(AGBpred_OOB^2)
  mz_MC_OOB[i] <- mean(mysample$AGB) + b_OOB*(mean(AGBpred)-mean(AGBpred_OOB))
  u_OOB <- mysample$AGB-AGBpred_OOB*b_OOB
  v_mz_MC_OOB[i] <- (1-n/N)*var(u_OOB)/n

# Difference estimator
  d <- mysample$AGB-AGBpred[units]
  mz_MD[i] <- mean(AGBpred) + mean(d)
  v_mz_MD[i] <- (1-n/N)*var(d)/n
  
  d_OOB <- mysample$AGB-AGBpred_OOB
  mz_MD_OOB[i] <- mean(AGBpred) + mean(d_OOB)
  v_mz_MD_OOB[i] <- (1-n/N)*var(d_OOB)/n
}

save(mz_MC,mz_MD,v_mz_MC,v_mz_MD,mz_MC_OOB,mz_MD_OOB,v_mz_MC_OOB,v_mz_MD_OOB,file="results/RandomForestEstimates_Amazonia_250pnts.RData")
```

For each estimator the 1,000 estimated means are used to compute the relative bias\index{Relative bias}:

\begin{equation}
bias = \frac{\frac{1}{1000}\sum_{i=1}^{1000}\hat{\bar{z}}_i-\bar{z}}{\bar{z}}\;.
(\#eq:relativebias)
\end{equation}

Besides, for each estimator the variance of the 1,000 estimates is computed, which can be compared with the mean of the 1,000 estimated variances. The mean of the estimated variances is used to compute the variance to mean squared error ratio\index{Variance to mean squared error ratio}:

\begin{equation}
R = \frac{\frac{1}{1000}\sum_{i=1}^{1000}\hat{V}(\hat{\bar{z}}_i)}{MSE}\;,
(\#eq:VariancetoMSEratio)
\end{equation}

with

\begin{equation}
MSE= \frac{1}{1000}\sum_{i=1}^{1000}(\hat{\bar{z}}_i-\bar{z})^2\;.
(\#eq:MSE)
\end{equation}

Ideally this ratio equals 1. If it is smaller than 1, the variance estimator underestimates the mean squared error.

Finally, the relative efficiency\index{Relative efficiency} is computed as the ratio of the MSE of the $\pi$ estimator and the MSE of a model-assisted estimator. The $\pi$ estimator is unbiased, so the MSE equals the variance, which can be computed without error by the population variance divided by the sample size. If the relative efficiency is larger than 1, the model-assisted estimator is more accurate than the $\pi$ estimator.

```{r, echo=FALSE}
load(file="results/RandomForestEstimates_Amazonia_100pnts.RData")
load(file="data/Amazonia_5km.RData")
#compute mean across all population units (population mean)
mz_pop <- mean(gridAmazonia$AGB)
#compute relative bias
relbias_MC <- (mean(mz_MC)-mz_pop)/mz_pop
relbias_MC_OOB <- (mean(mz_MC_OOB)-mz_pop)/mz_pop
#compute variance of 1000 estimates
v_mz_MC_sim <- var(mz_MC)
v_mz_MC_OOB_sim <- var(mz_MC_OOB)
#compute variance to MSE ratio
m_v_mz_MC_sim <- mean(v_mz_MC)
MSE_MC <- mean((mz_MC-mz_pop)^2)
R_MC <- m_v_mz_MC_sim/MSE_MC
m_v_mz_MC_sim_OOB <- mean(v_mz_MC_OOB)
MSE_MC_OOB <- mean((mz_MC_OOB-mz_pop)^2)
R_MC_OOB <- m_v_mz_MC_sim_OOB/MSE_MC_OOB
#compute relative efficiency
MSE_HT <- var(gridAmazonia$AGB)/n
RE_MC <- MSE_HT/MSE_MC
RE_MC_OOB <- MSE_HT/MSE_MC_OOB
```

The variance of the 1,000 model-calibration estimates, using all trees to predict AGB for the sample units, equals `r round(v_mz_MC_sim,4)`. This is `r round(v_mz_MC_sim/m_v_mz_MC_sim,1)` times larger than the average of the 1,000 estimated variances, which equals `r as.character(round(m_v_mz_MC_sim,4))`. When using the out-of-bag sample predictions, the experimental variance is about equal to the average of the 1,000 variance estimates: `r round(v_mz_MC_OOB_sim,4)` versus `r round(m_v_mz_MC_sim_OOB,4)`.

The reason of underestimation of the variance when predicting AGB at sample units with function `predict` is that all 1,000 trees are used in prediction, including the trees calibrated on bootstrap samples that contain the unit in the sample to be predicted. On the contrary, the out-of-bag predicted values are computed as the average of predictions from the trees calibrated on bootstrap samples that do not contain the sample unit to be predicted. The default sample fraction is 0.632, see argument `sample.fraction` of function `ranger`, so with 1,000 trees these predictions are the average of, on average, 368 tree predictions. This explains why the out-of-bag prediction errors are larger than the prediction errors obtained with function `predict`. In other words, the variance of the out-of-bag differences $d$ and of the out-of-bag residuals $u$ are larger than those obtained with predicting using all trees.

Hereafter I report the results obtained with the out-of-bag samples only.

```{r, echo=FALSE}
load(file="results/RandomForestEstimates_Amazonia_50pnts.RData")

mz_pop <- mean(gridAmazonia$AGB)
MSE_HT_50 <- var(gridAmazonia$AGB)/50

#calibration estimator
relbias_MC_50_OOB <- (mean(mz_MC_OOB)-mz_pop)/mz_pop

v_mz_MC_50_OOB <- var(mz_MC_OOB)
m_v_mz_MC_50_OOB <- mean(v_mz_MC_OOB)

MSE_MC_50_OOB <- mean((mz_MC_OOB-mz_pop)^2)
R_MC_50_OOB <- m_v_mz_MC_50_OOB/MSE_MC_50_OOB

RE_MC_50_OOB <- MSE_HT_50/MSE_MC_50_OOB

#difference estimator
relbias_MD_50_OOB <- (mean(mz_MD_OOB)-mz_pop)/mz_pop

v_mz_MD_50_OOB <- var(mz_MD_OOB)
m_v_mz_MD_50_OOB <- mean(v_mz_MD_OOB)

MSE_MD_50_OOB <- mean((mz_MD_OOB-mz_pop)^2)
R_MD_50_OOB <- m_v_mz_MD_50_OOB/MSE_MD_50_OOB

RE_MD_50_OOB <- MSE_HT_50/MSE_MD_50_OOB

load(file="results/RandomForestEstimates_Amazonia_100pnts.RData")
MSE_HT_100 <- var(gridAmazonia$AGB)/100

#calibration estimator
relbias_MC_100_OOB <- (mean(mz_MC_OOB)-mz_pop)/mz_pop

v_mz_MC_100_OOB <- var(mz_MC_OOB)
m_v_mz_MC_100_OOB <- mean(v_mz_MC_OOB)

MSE_MC_100_OOB <- mean((mz_MC_OOB-mz_pop)^2)
R_MC_100_OOB <- m_v_mz_MC_100_OOB/MSE_MC_100_OOB

RE_MC_100_OOB <- MSE_HT_100/MSE_MC_100_OOB

#difference estimator
relbias_MD_100_OOB <- (mean(mz_MD_OOB)-mz_pop)/mz_pop

v_mz_MD_100_OOB <- var(mz_MD_OOB)
m_v_mz_MD_100_OOB <- mean(v_mz_MD_OOB)

MSE_MD_100_OOB <- mean((mz_MD_OOB-mz_pop)^2)
R_MD_100_OOB <- m_v_mz_MD_100_OOB/MSE_MD_100_OOB

RE_MD_100_OOB <- MSE_HT_100/MSE_MD_100_OOB

load(file="results/RandomForestEstimates_Amazonia_250pnts.RData")
MSE_HT_250 <- var(gridAmazonia$AGB)/250

#calibration estimator
relbias_MC_250_OOB <- (mean(mz_MC_OOB)-mz_pop)/mz_pop

v_mz_MC_250_OOB <- var(mz_MC_OOB)
m_v_mz_MC_250_OOB <- mean(v_mz_MC_OOB)

MSE_MC_250_OOB <- mean((mz_MC_OOB-mz_pop)^2)
R_MC_250_OOB <- m_v_mz_MC_250_OOB/MSE_MC_250_OOB

RE_MC_250_OOB <- MSE_HT_250/MSE_MC_250_OOB

#difference estimator
relbias_MD_250_OOB <- (mean(mz_MD_OOB)-mz_pop)/mz_pop

v_mz_MD_250_OOB <- var(mz_MD_OOB)
m_v_mz_MD_250_OOB <- mean(v_mz_MD_OOB)

MSE_MD_250_OOB <- mean((mz_MD_OOB-mz_pop)^2)
R_MD_250_OOB <- m_v_mz_MD_250_OOB/MSE_MD_250_OOB

RE_MD_250_OOB <- MSE_HT_250/MSE_MD_250_OOB
```

The relative bias is negligibly small for all sample sizes (Table \@ref(tab:CalibrationEstimatesAmazoniaOOB)). Besides, for $n=100$ and 250 the average of the 1,000 variance estimates is close to the variance of the 1,000 estimates; for $n=50$ the experimental variance is overestimated by the variance estimator. The variance to MSE ratio is smaller than 1 for $n=100$ and 250, but larger than 1 for $n=50$. The model-calibration estimator is much more accurate than the $\pi$ estimator for all three sample sizes. The relative efficiency increases with the sample size.

```{r CalibrationEstimatesAmazoniaOOB, tidy=FALSE, echo=FALSE}
estimates <- data.frame(c("Relative bias","Experimental variance","Mean variance estimates","Variance to MSE ratio","Relative efficiency"),c(round(relbias_MC_50_OOB,4),round(v_mz_MC_50_OOB,4),round(m_v_mz_MC_50_OOB,4),round(R_MC_50_OOB,4),round(RE_MC_50_OOB,4)),c(round(relbias_MC_100_OOB,4),round(v_mz_MC_100_OOB,4),round(m_v_mz_MC_100_OOB,4),round(R_MC_100_OOB,4),round(RE_MC_100_OOB,4)),c(round(relbias_MC_250_OOB,4),round(v_mz_MC_250_OOB,4),round(m_v_mz_MC_250_OOB,4),round(R_MC_250_OOB,4),round(RE_MC_250_OOB,4)))

knitr::kable(
  estimates, caption = 'Summary statistics of 1,000 repeated calibration estimates of mean of aboveground biomass in Eastern Amazonia and their variance, using random forest model with five covariates as a working model and out-of-bag sample predictions, for simple random sampling without replacement.',
  col.names = c("Sample size:","50","100","250"),
  booktabs = TRUE
) %>%
  kable_classic()
```

The performance statistics of the generalised difference estimator are very similar to those of the model-calibration estimator (Table \@ref(tab:DifferenceEstimatesAmazoniaOOB)).

```{r DifferenceEstimatesAmazoniaOOB, tidy=FALSE, echo=FALSE}
estimates <- data.frame(c("Relative bias","Experimental variance","Mean variance estimates","Variance to MSE ratio","Relative efficiency"),c(round(relbias_MD_50_OOB,4),round(v_mz_MD_50_OOB,4),round(m_v_mz_MD_50_OOB,4),round(R_MD_50_OOB,4),round(RE_MD_50_OOB,4)),c(round(relbias_MD_100_OOB,4),round(v_mz_MD_100_OOB,4),round(m_v_mz_MD_100_OOB,4),round(R_MD_100_OOB,4),round(RE_MD_100_OOB,4)),c(round(relbias_MD_250_OOB,4),round(v_mz_MD_250_OOB,4),round(m_v_mz_MD_250_OOB,4),round(R_MD_250_OOB,4),round(RE_MD_250_OOB,4)))

knitr::kable(
  estimates, caption = 'Summary statistics of 1,000 repeated generalised difference estimates of aboveground biomass in Eastern Amazonia and their variance, using random forest model with five covariates as a working model and out-of-bag sample predictions, for simple random sampling without replacement.',
  col.names = c("Sample size:","50","100","250"),
  booktabs = TRUE
) %>%
  kable_classic()
```
## Big data and volunteer data

In the past decades numerous large data sets became available, and this number will further increase in the future, think of data sets collected by the numerous satellites. These data sets may contain valuable information about the study variables, so that they can be used in model-assisted estimation of global (this chapter) or local means and totals (Chapter \@ref(SmallAreaEstimation)).

Another interesting source of information are the geographic data collected by volunteers. These data typically are from non-probability samples\index{Non-probability sampling}. Despite this, there can be valuable information in these data about the global or local means of the study variable.

When the volunteer data\index{Volunteer data} are supplemented by a probability sample with observations on the study variable, the volunteer data can be used at the design stage and/or at the estimation stage. As an example of the first approach, the volunteer data are used to predict the study variable at a fine discretisation grid. These predictions are then used to construct strata for supplemental sampling, for instance by the *cum-root-f* method (Section \@ref(cumrootf)), or using the approach described in Section \@ref(Ospats).

At the estimation stage the volunteer data are used to predict the study variable at points of the supplemental probability sample and at the nodes of a discretisation grid. These predictions are then used in model-assisted estimation, using the generalised difference or regression estimator, as explained in this chapter and in @bru03a.

@Stehman2018 compared this model-assisted estimation approach with a certainty stratum approach\index{Certainty stratum approach} for estimating the area covered by land cover classes and the accuracy of land cover maps. The volunteer data are treated as the data of a stratum of which all units are observed. A probability sample is selected from the remaining units not observed by the volunteers. The total (area of a land cover class) of the certainty stratum is added to the estimated total of the subpopulation not observed by the volunteers. 

The model-assisted approach requires a supplemental sample with observations of the study variable. @Kim2019 described an approach in which the big data\index{Big data} sample is combined with a probability sample with observations of one or more ancillary variables.

@Kim2019 also describe an alternative approach that does not require a probability sample at all. In this approach the big data sample is subsampled to correct the selection bias in the big data sample. The subsample is selected by inverse sampling, using data on an ancillary variable $x$, either from a census or a probability sample. The subsample is selected with conditional inclusion probabilities equal to the subsample size multiplied by an importance weight (Equation 4, @Kim2019).

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:10-ModelAssisted.Rmd-->

# Two-phase random sampling {#Twophase}

The regression and ratio estimators of Chapter \@ref(Modelassisted) require that the means of the ancillary variables are known. If these are unknown, but the ancillary variable can be measured cheaply, one may decide to estimate the population means of the ancillary variables from a large sample. The study variable is measured in a random subsample of this large sample only. This technique is known in the sampling literature as two-phase random sampling\index{Two-phase random sampling} or double sampling\index{Double sampling}. Another application of two-phase sampling is two-phase sampling for stratification. Stratified random sampling (Chapter \@ref(STSI)) requires a map with the strata. The poststratified estimator of Section \@ref(PoststratifiedEstimator) requires that the sizes of the strata are known. With two-phase sampling for stratification neither a map of the strata, nor knowledge of the stratum sizes is required. Note that the term `phase' does not refer to a period of time; all data can be collected in one sampling campaign. Let me also explain the difference with two-stage cluster sampling (Chapter \@ref(Twostage)). In two-stage cluster random sampling we have two types of sampling units, clusters of population units and individual population units. In two-phase sampling we have one type of sampling units only, the population units. 

In two-phase sampling for regression and two-phase sampling for stratification the two phases have the same aim, i.e. to estimate the population mean of the study variable. The observations of the covariate(s) and/or strata in the first phase are merely done to increase the precision of the estimated mean of the study variable. Another application of two-phase sampling is subsampling an existing probability sample designed for a different aim. So in this case the observations in the first phase sample may not be related to the study variable observed in the second-phase sample. An example is LUCAS-Topsoil [@Ballabio2019]. LUCAS-Topsoil is a subsample of approximately 22,000 units sampled from a much larger sample, the LUCAS sample, designed for estimating totals of land cover and land use classes across the European Union. It was not feasible to observe the soil properties at all sites of the LUCAS sample, and for that reason a subsample was selected. Regrettably, this subsample is not a probability sample from the LUCAS sample: the inclusion probabilities are either zero or unknown, both are not allowed. Design-based or model-assisted estimation of means of soil properties for domains of interest is not feasible. The only option is model-based prediction.

In case the subsample is a probability subsample from the first-phase sample, and no variable observed in the first-phase sample\index{First-phase sample} is of use for estimating the total or mean of the study variable observed in the subsample, the population total can be estimated by the $\pi$ estimator:

\begin{equation}
\hat{t}(z)=\sum_{k \in \mathcal{S}_2}\frac{z_k}{\pi_{1k}\pi_{k|\mathcal{S}_1}} = \sum_{k \in \mathcal{S}_2}\frac{z_k}{\pi^*_{k}}\;,
(\#eq:HTestimatorTotalDoubleSampling)
\end{equation}

with $n_2$ the size of the second-phase sample\index{Second-phase sample} (subsample size), $\pi_{1k}$ the probability that unit $k$ is selected in the first phase, and $\pi_{k|\mathcal{S}_1}$ the probability that unit $k$ is selected in the second phase, given the first-phase sample $\mathcal{S}_1$. This general $\pi$ estimator for two-phase sampling, referred to as the $\pi^*$-estimator\index{$\pi^*$-estimator} by @sar92, can be used for any combination of probability sampling designs in the first and second phase.

To derive the variance it is convenient to write the total estimation error as the sum of two errors:

\begin{equation}
\hat{t}(z)-t(z)=\left(\sum_{k \in \mathcal{S}_1}\frac{z_k}{\pi_{1k}}-t(z)\right)+\left(\sum_{k \in \mathcal{S}_2}\frac{z_k}{\pi^*_{k}}-\sum_{k \in \mathcal{S}_1}\frac{z_k}{\pi_{1k}}\right)
=\epsilon_1+\epsilon_2
(\#eq:DecomposeErrorsDoubleSampling)\;.
\end{equation}

The first error $\epsilon_1$ is the error in the estimated population total, as estimated by the usual $\pi$ estimator using the study variable values for the units in the first-phase sample. This estimator cannot be computed in practice as the study variable values are only known for a subset of the units in the first-phase sample. The second error $\epsilon_2$ is the difference between the $\pi^*$-estimator using the study variable values for the units in the subsample only, and the $\pi$ estimator using the study variable values for all units in the first-phase sample.

The variance of the $\pi^*$-estimator can be decomposed into the variance of these two errors as follows:

\begin{equation}
V_{p_1,p_2}(\hat{t})=V_{p_1}E_{p_2}(\hat{t}|\mathcal{S}_1)+E_{p_1}V_{p_2}(\hat{t}|\mathcal{S}_1)=V_{p_1}(\epsilon_1)+E_{p_1}V_{p_2}(\epsilon_2|\mathcal{S}_1)\;,
(\#eq:VarHTestimatorDoubleSampling)
\end{equation}

with $V_{p_1}$ and $E_{p_1}$ the variance of the estimator for the population total over repeated sampling with the design of the first phase, and $V_{p_2}$ and $E_{p_2}$ the variance and expectation of the estimator for the population total over repeated sampling with the design of the second phase. The population mean can be estimated by the estimated total divided by the population size $N$ (or $A$ for infinite populations). 

## Two-phase random sampling for stratification {#TwophaseStratification}

In two-phase sampling for stratification\index{Two-phase sampling!for stratification} a large sample is taken, and the selected sampling units are all classified. The classes thus formed are then used as strata in the second sampling phase. A stratified subsample is selected, and the study variable is observed on the units in the subsample only.

This sampling design is applied, for instance, to monitor land use and land cover in the European Union. In the first phase a systematic random sample of points is selected consisting of a 2 km $\times$ 2 km grid. Land use and land cover (LULC) is then determined at the selected grid nodes, using orthophotographs, satellite imagery and fieldwork. The idea is that this procedure results in a more accurate classification of LULC at the selected points than by overlaying the points with an existing LULC map such as the Corine Land Cover map. The site-specific determinations of LULC classes are then used to select a stratified random subsample.

Two-phase sampling for stratification is illustrated with study area Voorst. A map with five combinations of soil type and land use is available of this study area. These combinations were used as strata in Chapter \@ref(STSI), and in the poststratified estimator of Section \@ref(PoststratifiedEstimator) the strata sizes were used. Here we consider the situation that we do not have this map, and that we do not know the sizes of these strata either. In the first phase a simple random sample of size 100 is selected. In the field the soil type - land use class is determined for the selected units, see Figure \@ref(fig:DoubleSampleVoorst). Here we assume that the field determinations are equal to the classes as shown on the map.

```{r}
load("data/Voorst.RData")
n1 <- 100
set.seed(123)
N <- nrow(grdVoorst)
units <- sample.int(N, size=n1, replace=FALSE)
mysample <- grdVoorst[units,]
```

The simple random sample is subsampled by stratified simple random sampling, using the soil type - land use classes as strata. The total sample size of the second phase is set to 40. The number of units in the simple random sample per stratum is determined. Then the subsample size per stratum is computed for proportional allocation, and it is checked whether the sum of the stratum sample sizes equals 40. Finally function `strata` of package **sampling** [@Tille2016] is used to select a stratified simple random sample without replacement, see Chapter \@ref(STSI) for details.

```{r}
library(sampling)
n2 <- 40
n1_h <- tapply(mysample$z, INDEX=mysample$stratum, FUN=length)
n2_h <- round(n1_h/n1*n2, 0)
n2_h_ord <- n2_h[unique(mysample$stratum)]
units <- sampling::strata(mysample, stratanames="stratum",
                          size=n2_h_ord, method="srswor")
mysubsample <- getdata(mysample, units)
table(mysubsample$stratum)
```

```{r DoubleSampleVoorst, echo=FALSE, out.width='100%', fig.cap="Two-phase sample for stratification from Voorst. Coloured dots: simple random sample of 100 points classified into five soil type - land use classes (first-phase sample). Triangles: stratified simple random sample of 40 points with measurements of SOM (second-phase sample)."}
ggplot() +
  geom_raster(data=grdVoorst,mapping = aes(x = s1/1000, y = s2/1000), fill="grey") +
  geom_point(data=mysample,mapping = aes(x = s1/1000,y = s2/1000, colour=stratum), size = 1.5) +
  scale_fill_manual(name = "", values = c(BA="darkgreen", EA="brown", PA="orange", RA="green", XF="grey")) +  
  geom_point(data=mysubsample,mapping=aes(x = s1/1000, y = s2/1000), size=2.5, shape=2)+
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  coord_fixed()
```

With simple random sampling in the first phase and stratified simple random sampling in the second phase, the population mean can be estimated by

\begin{equation}
\hat{\bar{z}}=
\sum_{h=1}^{H_{\mathcal{S}_1}}\frac{n_{1h}}{n_{1}}\,\bar{z}_{\mathcal{S}_{2h}} 
\;,
(\#eq:EstimatedMeanDoubleStratification)
\end{equation}

where $H_{\mathcal{S}_1}$ is the number of strata used for stratification of the first-phase sample, $n_{1h}$ is the number of units in the first-phase sample that form stratum $h$ in the second phase, $n_{1}$ is the total number of units of the first phase sample and $\bar{z}_{\mathcal{S}_{2h}}$ is the mean of the subsample from stratum $h$.

```{r}
mz_h_subsam <- tapply(
  mysubsample$z, INDEX=mysubsample$stratum, FUN=mean)
mz <- sum(n1_h/n1*mz_h_subsam, na.rm=TRUE)
```

The estimated population mean equals `r round(mz,2)`. The sampling variance over repeated sampling with both designs can be approximated^[In the approximation it is assumed that $N$ is much larger than $n_1$, and $(n_{1h}-1)/(n_1-1)$ is replaced by $n_{1h}/n_1$.] by (see Equation at bottom of p. 353 in @sar92)

\begin{eqnarray}
\widehat{V}\!(\hat{\bar{z}}) &=& \sum_{h=1}^{H_{\mathcal{S}_1}}\left( \frac{n_{1h}}{n_1}\right)^2
\frac{\widehat{S^2}_{\mathcal{S}_{2h}}}{n_{2h}} \notag \\ 
&+&\frac{1}{n_1}\sum_{h=1}^{H_{\mathcal{S}_1}} \frac{n_{1h}}{n_1}\left( \bar{z}_{\mathcal{S}_{2h}}-\hat{\bar{z}}\right)^2 
\;.
(\#eq:VarMeanDoubleStratification)
\end{eqnarray}

```{r}
S2z_h_subsam <- tapply(
  mysubsample$z, INDEX=mysubsample$stratum, FUN=var)
w1_h <- n1_h/n1
v_mz_1 <- sum(w1_h^2*S2z_h_subsam/n2_h)
v_mz_2 <- 1/n1*sum(w1_h*(mz_h_subsam-mz)^2)
se_mz <- sqrt(v_mz_1+v_mz_2)
```

The estimated standard error equals `r round(se_mz,3)`.

The mean and its standard error can be estimated with functions `twophase` and `svymean` of package **survey** [@Lumley2020]. A `data.frame` with the first phase sample is assigned to the argument `data` of function `twophase`. A column in this `data.frame`, assigned to the argument `subset`, is an indicator with value `TRUE` if this unit is selected in the second phase and `FALSE` otherwise. 

```{r}
library(survey)
mysample$ind <- FALSE
mysample$ind[units$ID_unit] <- TRUE
mysample$fpc1 <- N
labels <- sort(unique(mysample$stratum))
fpc2 <- n1_h
lut <- data.frame(stratum=labels, fpc2)
mysample <- merge(x=mysample, y=lut)
mysample$stratum <- as.factor(mysample$stratum)
design_2phase <- survey::twophase(
  id=list(~1,~1), strata=list(NULL,~stratum),
  data=mysample, subset=~ind, fpc=list(~fpc1,~fpc2))
svymean(~z, design_2phase)
```

As shown in the next code chunk, the standard error is computed with the original variance estimator, without approximation (see Equation (9.4.14) in @sar92).

```{r}
v_mz_1 <- 1/N^2*N*(N-1)*
  sum((((n1_h-1)/(n1-1))-((n2_h-1)/(N-1)))*w1_h*S2z_h_subsam/n2_h)
v_mz_2 <- 1/N^2*(N*(N-n1))/(n1-1)*sum(w1_h*(mz_h_subsam-mz)^2)
sqrt(v_mz_1+v_mz_2)
```

## Two-phase random sampling for regression  {#TwophaseRegression}

The simple regression estimator of Equation \@ref(eq:SimpleRegressionEstimatorSI) requires that the population mean of the ancillary variable $x$ is known. This section is about applying the regression estimator in situations where this mean of $x$ is unknown\index{Two-phase sampling!for regression}. A possible application is estimating the soil carbon stock (until a given depth) in an area. To estimate this carbon stock soil samples are collected and analyzed in a laboratory. These laboratory measurements can be very accurate, but also expensive. Proximal sensors can be used to derive soil carbon concentrations from the spectra. Compared to laboratory measurements of soil these proximal sensor determinations are much cheaper, but also less accurate. If there is a relation between the laboratory and proximal sensing determinations of SOC, then we expect that the regression estimator of the carbon stock will be more accurate than the $\pi$ estimator which does not exploit the proximal sensing measurements. However, the population mean of the proximal sensing determinations is unknown. What we can do is to estimate this mean from a large sample. For a subsample of this large sample, SOC concentration is also measured in the laboratory. This is another example of two-phase sampling. Intuitively, with two-phase sampling the variance of the regression estimator of the total carbon stock will be larger than when the population mean of the proximal sensing determinations would be known. We are more uncertain about the total carbon stock, because we are uncertain about the population mean of the proximal sensing determinations.

Figure \@ref(fig:twophaseAmazonia) shows a two-phase sample from Eastern Amazonia (Brazil). In the first phase 250 points (the dots in the plot) are selected by simple random sampling. In the second phase a subsample of 100 points (the triangles in the plot) are selected from the 250 points by simple random sampling without replacement. At all 250 points of the first-phase sample the covariate lnSWIR2 is measured, whereas the study variable (AGB) is measured at the 100 subsample points only. This sampling design does not require a full-coverage map of the covariate. In this case we do have a full coverage map of lnSWIR2, so a two-phase sample is not needed. I chose the same case study to show the effect of ignorance of the population mean of the covariate on the variance of the regression estimator. 

```{r twophasesample}
load("data/Amazonia_1km.RData")
n1 <- 250; n2 <- 100
set.seed(314)
units_1 <- sample.int(nrow(gridAmazonia), size=n1, replace=FALSE)
mysample <- gridAmazonia[units_1,]
units_2 <- sample.int(n1, size=n2, replace=FALSE)
mysubsample <- mysample[units_2,]
```

```{r twophaseAmazonia, echo=FALSE, out.width='100%', fig.cap="Two-phase sample for the regression estimator of the population mean of aboveground biomass (AGB) in Eastern Amazonia. Coloured dots: simple random sample of 250 units with measurements of covariate lnSWIR2 (first-phase sample). Triangles: simple random subsample of 100 units with measurements of AGB (second-phase sample)."}
ggplot(data = gridAmazonia) +
  geom_raster(mapping = aes(x = x1/1000, y = x2/1000), fill="grey") +
  geom_point(data=mysample, mapping = aes(x=x1/1000, y = x2/1000, colour=lnSWIR2), size=1) +
  geom_point(data=mysubsample, mapping = aes(x=x1/1000, y = x2/1000), shape=2, size=3) +
  scale_fill_continuous(name="lnSWIR2", type = "viridis") +
  scale_x_continuous(name="Easting (km)")+
  scale_y_continuous(name="Northing (km)")+
  coord_fixed()
```

Estimation of the population mean or total by the regression estimator from a two-phase sample is very similar to estimation when the covariate mean is known, as described in Section \@ref(RegressionEstimator) (Equation \@ref(eq:SimpleRegressionEstimatorSI)\index{Regression estimator!for two-phase sampling}. The observations on the *subsample* can be used to estimate the regression coefficient $b$. The true population mean of the ancillary variable, ($\bar{x}$ in Equation \@ref(eq:SimpleRegressionEstimatorSI)), is unknown now. This true mean is replaced by the mean as estimated from the relatively large first-phase sample, $\bar{x}_{\mathcal{S}_1}$. The estimated mean of the covariate, $\hat{\bar{x}}_{\mathcal{S}}$ in Equation \@ref(eq:SimpleRegressionEstimatorSI), is estimated from the subsample, $\bar{x}_{\mathcal{S}_2}$. This leads to the following estimator:

\begin{equation}
\hat{\bar{z}}= \bar{z}_{\mathcal{S}_2}+\hat{b}\left( \bar{x}_{\mathcal{S}_1}-\bar{x}_{\mathcal{S}_2}\right) \;,
(\#eq:RegressionEstimatorTwoPhase)
\end{equation}

where $\bar{z}_{\mathcal{S}_2}$ is the subsample mean of the study variable, and $\bar{x}_{\mathcal{S}_1}$ and $\bar{x}_{\mathcal{S}_2}$ are the means of the covariate in the first-phase sample and subsample (second-phase sample), respectively.

The sampling variance is larger than that of the regression estimator with known mean of $x$. The variance can be decomposed into a component equal to the sampling variance of the estimator of the mean of $z$ with the sampling design of the first phase (in this case simple random sampling without replacement), supposing that the study variable would be observed on all units of the first-phase sample, and a component equal to the sampling variance of the regression estimator of the sample mean of $z$ in the first-phase sample with the design of the second phase sample (again simple random sampling without replacement in this case):

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}\right)=(1-\frac{n_1}{N})\frac{\widehat{S^{2}}(z)}{n_1} + (1-\frac{n_2}{n_1}) \frac{\widehat{S^{2}}(\epsilon)}{n_2} \;,
(\#eq:VarianceRegressionEstimatorTwoPhase)
\end{equation}

with $\widehat{S^{2}}(\epsilon)$ the variance of the regression residuals as estimated from the subsample:

\begin{equation}
\widehat{S^{2}}(\epsilon)=\frac{1}{(n_2-1)}\sum_{k \in \mathcal{S}}\epsilon_{k}^2 \;.
(\#eq:VarianceResidualsTwoPhase)
\end{equation}

Note the finite population corrections (fpc), $(1-n_1/N)$ and $(1-n_2/n_1)$, in the variance estimator. These fpc's account for the reduced variance due to sampling the finite population and subsampling the first-phase sample without replacement.

```{r}
lm_subsample <- lm(AGB~lnSWIR2, data=mysubsample)
ab <- coef(lm_subsample)
mx_sam <- mean(mysample$lnSWIR2)
mx_subsam <- mean(mysubsample$lnSWIR2)
mz_subsam <- mean(mysubsample$AGB)
mz_reg2ph <- mz_subsam+ab[2]*(mx_sam-mx_subsam)
```

The estimated population mean equals `r round(mz_reg2ph,1)`. The standard error can be approximated as follows.

```{r}
e <- residuals(lm_subsample)
S2e <- sum(e^2)/(n2-1)
S2z <- var(mysubsample$AGB)
N <- nrow(gridAmazonia)
se_mz_reg2ph <- sqrt((1-n1/N)*S2z/n1 + (1-n2/n1)*S2e/n2)
```

The estimated standard error equals `r round(se_mz_reg2ph,3)`.

The regression estimator for two-phase sampling and its standard error can also be computed with package **survey**, as shown below. The standard error slightly differs from the standard error computed above because it is computed with the g-weights, see Section \@ref(RegressionEstimator). Note the argument `fpc=list(~N,NULL)`. There is no need to add the first phase sample size as a second element of the list, because this sample size is simply the number of rows of the data frame. Setting the second element of the list to `NULL` does not mean that the standard error is computed for with replacement sampling in the second phase. Function `twophase` assumes that the second phase units are always selected without replacement.

```{r}
mysample$id <- 1:n1
mysample$ind <- ifelse(mysample$id %in% units_2, TRUE, FALSE)
mysample$N <- rep(N, n1)
design_2phase <- survey::twophase(
  id=list(~1,~1), data=mysample, subset=~ind, fpc=list(~N,NULL))
mysample_cal <- calibrate(
  design_2phase, formula=~lnSWIR2, calfun="linear", phase=2)
svymean(~AGB, mysample_cal)
```

#### Exercises {-}

1. Write an **R** script to select a simple random sample without replacement of 250 units from Eastern Amazonia (`data/Amazonia_1km.RData`) and a subsample of 100 units by simple random sampling without replacement. Repeat this 1,000 times in a for-loop. 
    +  Use each one-phase sample (sample of 250 units) to estimate the population mean of AGB by the regression estimator (Equation \@ref(eq:SimpleRegressionEstimatorSI) in Chapter \@ref(Modelassisted)), using lnSWIR2 as a covariate.  
    +  Use each two-phase sample to estimate the regression estimator for two-phase sampling (Equation \@ref(eq:RegressionEstimatorTwoPhase)). Estimate the population mean of lnSWIR2 from the first-phase sample of 250 points. The study variable AGB is observed at the subsample only. Approximate the variance of the regression estimator for two-phase sampling (Equation \@ref(eq:VarianceRegressionEstimatorTwoPhase)).  
    +  Compute the variance of the 10,000 regression estimates of the mean of AGB.  
    +  Compute the variance of the regression estimator for this two-phase sampling design.   
    +  Compare the two variances, and explain the difference.  
    +  Compute the average of the 10,000 approximate variances, and compare with the variance of the 10,000 estimated means, as estimated by the regression estimator for two-phase sampling. 
  
```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:11-Twophase.Rmd-->

# Computing the required sample size {#RequiredSampleSize}

An important decision in designing sampling schemes is the number of units to select. In other words, what should the sample size be? If a certain budget is available for sampling, we can determine the affordable sample size from this budget. A cost model is then needed. For simple random sampling the affordable sample size can then simply be computed by the available budget divided by the average cost per unit.

The alternative to deriving the affordable sample size from the budget is to start from a requirement on the quality of the survey result obtained by statistical inference. Two types of inference are distinguished, estimation and testing. The required sample size\index{Required sample size} depends on the type of sampling design. With stratified random sampling we expect that we need fewer sampling units compared to simple random sampling to estimate the population mean with the same precision, whereas with cluster random sampling and two-stage cluster random sampling in general we need more sampling units. To compute the sample size given some quality requirement we may start with computing this required sample size for simple random sampling, and then correct this sample size to account for the design effect. Therefore I start with presenting formulas for computing the required sample size for simple random sampling. Section \@ref(DesignEffect) describes how required sample sizes for other types of sampling designs can be derived.

Hereafter formulas for computing the required sample size are presented for simple random sampling  *with replacement* (SIR) of finite populations and simple random sampling of infinite populations. For SI *without replacement* (SI) of finite populations these sample sizes can be corrected by [@loh99]

\begin{equation}
n_{\mathrm{SI}} = \frac{n}{1+\frac{n_{\mathrm{SIR}}}{N}} \;,
(\#eq:nreqSIR)
\end{equation}

with $n$ the required sample size for simple random sampling with replacement.

## Standard error of estimator

A first option is to set a limit on the variance  of the estimated mean, see Equation \@ref(eq:VarMean), or on the square root of this variance, the standard error of the estimated mean. Given a chosen limit for the standard error $se_{\mathrm{max}}$, the required sample size for simple random sampling with replacement can be computed by

\begin{equation}
n = \left(\frac{S^*(z)}{se_{\mathrm{max}}}\right)^2 \;,
(\#eq:nreqse)
\end{equation}

with $S^*(z)$ a prior estimate of the population standard deviation\index{Prior estimate!of population standard deviation}. The required sample size $n$ should be rounded to the nearest integer greater than the right-hand side of Equation \@ref(eq:nreqse). This also applies to the following equations.

For the population proportion (areal fraction) as the parameter of interest, the required sample size can be computed by (see Equation \@ref(eq:EstVarProportionSI))

\begin{equation}
n = \left(\frac{\sqrt{p^*(1-p^*)}}{se_{\mathrm{max}}}\right)^2+1 \;,
(\#eq:nreqseproportion)
\end{equation}

with $p^*$ a prior estimate of the population proportion\index{Prior estimate!of population proportion}. Note that in this case we need a prior estimate of the population parameter of interest itself, whereas for the population mean a prior estimate is needed of the population standard deviations and therefore differs from the parameter of interest. The parameter of which a prior estimate is needed is referred to as the design parameter\index{Design parameter}.

Alternatively, we may require that with a large probability $1-\alpha$ the *relative* standard error, i.e. the standard error divided by the population mean^[The relative standard error is also referred to as the coefficient of variation. Note that this coefficient of variation is also used for the standard deviation of the study variable in the population divided by the population mean.], may not exceed a given limit $rse_{\mathrm{max}}$. In this case the required sample size can be computed by

\begin{equation}
n = \left(\frac{S^*(z)}{rse_{\mathrm{max}}\;\tilde{\bar{z}}}\right)^2=\left(\frac{cv^*}{rse_{\mathrm{max}}}\right)^2 \;,
(\#eq:nreqrse)
\end{equation}

with $cv^*$ a prior estimate of the coefficient of variation\index{Prior estimate!of population coefficient of variation} $S(z)/\bar{z}$. For a requirement on the relative standard error of the population proportion estimator we obtain

\begin{equation}
n = \left(\frac{p^*(1-p^*)}{rse_{\mathrm{max}}\;p^*}\right)^2+1=\left(\frac{1-p^*}{rse_{\mathrm{max}}}\right)^2+1 \;.
(\#eq:nreqrse2)
\end{equation}

## Length of confidence interval {#ReqSampleSizeLengthCI}

Another option is to require that the length of the confidence interval of the mean may not exceed a given limit $l_{\mathrm{max}}$:

\begin{equation}
2 \; t_{\alpha/2,n-1}\frac{S(z)}{\sqrt{n}} \leq l_{\mathrm{max}} \;,
(\#eq:widthCI)
\end{equation}

with $t_{\alpha/2,n-1}$ the $(1-(\alpha/2))$ quantile of the $t$ distribution with $n-1$ degrees of freedom, $S(z)$ the population standard deviation of the study variable, and $n$ the sample size.  The problem is that we do not know the degrees of freedom (we want to determine the sample size $n$). Therefore $t_{\alpha/2,n-1}$ is replaced by $u_{\alpha/2}$, the $(1-(\alpha/2))$ quantile of the standard normal distribution. Rearranging gives

\begin{equation}
n = \left(u_{\alpha/2}\frac{S^*(z)}{l_{\mathrm{max}}/2}\right)^2 \;.
(\#eq:nreqwidthCI)
\end{equation}

The requirement can also be formulated as

\begin{equation}
P(|\hat{\bar{z}}-\bar{z}| \leq d_{\mathrm{max}}) \leq 1-\alpha \;,
(\#eq:nreqwidthCIalt)
\end{equation}

with $d_{\mathrm{max}}$ the margin of error\index{Margin of error}: $d_{\mathrm{max}}=l_{\mathrm{max}}/2$.

An alternative is to require that with a large probability $(1-\alpha)$ the absolute value of the *relative*  error of the estimated mean may not exceed a given limit $r_{\mathrm{max}}$. In formula:

\begin{equation}
P\left(\frac{\lvert\hat{\bar{z}}-\bar{z}\rvert}{\bar{z}} \leq r_{\mathrm{max}}\right) \leq 1-\alpha \;.
(\#eq:nreqPrRelError)
\end{equation}

Noting that the absolute error equals $r_{\mathrm{max}} \cdot \bar{z}$, and inserting this in Equation \@ref(eq:nreqwidthCI) gives

\begin{equation}
n = \left(u_{\alpha/2}\frac{cv^*}{r_{\mathrm{max}}}\right)^2 \;.
(\#eq:nreqPrRelError2)
\end{equation}

As an example the required sample size is computed for estimating the population mean of the soil organic matter concentration in Voorst. The requirement is that with a probability of 95\% the absolute value of the *relative* error does not exceed 10\%. A prior estimate of 0.5 for the population coefficient of variation is used.

```{r}
cv <- 0.5
rmax <- 0.1
u <- qnorm(p=1-0.05/2, mean=0, sd=1)
n <- ceiling((u*cv/rmax)^2)
```

The same result is obtained with function `nContMoe` of package **PracTools** (@PracTools, @Vaillant2018).

```{r}
library(PracTools)
print(nContMoe(moe.sw=2, e=rmax, alpha=0.05, CVpop=cv))
```

### Length of confidence interval for a proportion

Each of the methods for computing a confidence interval of a proportion described in Section \@ref(ConfidenceIntervalProportion) can be used to compute the required sample size given a limit for the length of the confidence interval of a proportion. The most simple option is to base the required sample size on the Wald interval\index{Wald interval} (Equation \@ref(eq:Waldinterval)), so that the required sample size can be computed with

\begin{equation}
n = \left(u_{\alpha/2}\frac{\sqrt{p^*(1-p^*)}}{l_{\mathrm{max}}/2}\right)^2 +1\;.
(\#eq:nreqwidthCIprop)
\end{equation}

The Wald interval approximates the discrete binomial distribution by a normal distribution. See the rule of thumb in Section \@ref(ConfidenceIntervalProportion) for when this approximation is reasonable.

Package **binomSamSize** [@Hohle2017] has quite a few functions for computing the required sample size. The function `ciss.wald` uses the normal approximation. Argument `d` in the functions below is *half* the length of the confidence interval. Required sample sizes are computed for a prior estimate of the population proportion $p^*$ of 0.2.  

```{r}
library(binomSamSize)
p_prior <- 0.2
n_prop_wald <- ciss.wald(p0=p_prior, d=0.1, alpha=0.05)
n_prop_agrcll <- ciss.agresticoull(p0=p_prior, d=0.1, alpha=0.05)
n_prop_wilson <- ciss.wilson(p0=p_prior, d=0.1, alpha=0.05)
```

The required sample sizes are `r n_prop_wald`, `r n_prop_agrcll` and `r n_prop_wilson`, for the Wald,  Agresti-Coull and Wilson approximation of the binomial proportion confidence interval, respectively. The required sample size with function `ciss.wald` is one unit smaller than as computed with Equation \@ref(eq:nreqwidthCIprop), as shown in the code chunk below.

```{r}
ceiling((qnorm(0.975)*sqrt(p_prior*(1-p_prior))/0.1)^2+1)
```

## Statistical testing of hypothesis

The required sample size for testing a population mean with a two-sided alternative hypothesis can be computed with [@Ott2015]

\begin{equation}
n = \frac{S^2(z)}{\Delta^2}\;(u_{\alpha/2}+u_{\beta})^2
(\#eq:reqsamplesizetestingmean)
\end{equation}

with $\Delta$ the smallest relevant difference\index{Smallest relevant difference} of the population mean from the test value\index{Test value}, $\alpha$ the tolerable probability of a type I error\index{Probability of a type II error}, i.e. the probability of rejecting the null hypothesis when the population mean is equal to the test value, $\beta$ the tolerable probability of a type II error\index{Probability of a type II error}, i.e. the probability of not rejecting the null hypothesis when the population mean is not equal to the test value, $u_{\alpha/2}$ as before, and $u_{\beta}$ the $(1-\beta)$ quantile of the standard normal distribution. The quantity $1-\beta$ is the power of a test\index{Power of a test}: the probability of correctly rejecting the null hypothesis. For a one-sided test, $u_{\alpha/2}$ must be replaced by $u_{\alpha}$.

In the next code chunk the sample size required for a given target power is computed with the standard normal distribution (Equation \@ref(eq:reqsamplesizetestingmean)), as well as with the $t$ distribution using function `pwr.t.test` of package **pwr** [@pwr]^[The same result is obtained with function  `power.t.test` of the **stats** package [@R2020].] This requires some iterative algorithm, as the degrees of freedom of the $t$ distribution are a function of the sample size(s). The required sample size is computed for a one-sample test and a one-sided alternative hypothesis.

```{r}
library(pwr)
sd <- 4; delta <- 1; alpha <- 0.05; beta <- 0.2
n_norm <- (sd/delta)^2*(qnorm(1-alpha)+qnorm(1-beta))^2
n_t <- pwr.t.test(
  d=delta/sd, sig.level=alpha, power=(1-beta), type="one.sample",
  alternative="greater")
```

In this example the required sample size computed with the $t$ distribution is two units larger than that obtained with the standard normal distribution: `r ceiling(n_t$n)` versus `r (ceiling(n_norm))`. Package **pwr** has various functions for computing the power of a test given the sample size, or reversely, the sample size for a given power, such as for the two independent samples $t$ test, binomial test (for one proportion), test for two proportions, etc. 

### Sample size for testing a proportion

For testing a proportion a graph is computed with the power of a binomial test\index{Binomial test} against the sample size. This is illustrated with a one-sided alternative $H_a: p > 0.20$ and a smallest relevant difference of 0.10. 

```{r}
p_test <- 0.20; alpha <- 0.10; delta <- 0.10
n <- 1:150
power <- k_min <- numeric(length=length(n))
for (i in 1:length(n)) {
  k_min[i] <- qbinom(p=1-alpha, size=n[i], prob=p_test)
  power[i] <- pbinom(
    q=k_min[i], size=n[i], prob=p_test+delta, lower.tail=FALSE)
}
```

As can be seen in the **R** code, as a first step for each total sample size the smallest number of successes $k_{\mathrm{min}}$ is computed at which the null-hypothesis is rejected. Then the binomial probability is computed of $k_{\mathrm{min}}+1$ or more successes for a probability of success equal to $p_{\mathrm{test}}+\Delta$. Note that there is no need to add 1 to `k_min` as with argument `lower.tail=FALSE` the value specified with argument `q` is not included.

```{r powerbinomialtest, echo=FALSE, fig.asp=0.7, fig.cap="Power of right-tail binomial test (test-proportion: 0.2; significance level: 0.10)."}
beta <- 0.20 
df <- data.frame(n=n, dmin=k_min, power=power)
ggplot(df)+
  geom_point(mapping=aes(x=n, y=power))+
  geom_line(mapping=aes(x=n, y=power))+
  geom_hline(mapping=aes(yintercept=1-beta), lty=2) +
  scale_x_continuous(name="Sample size") +
  scale_y_continuous(name="Power")
```

Figure \@ref(fig:powerbinomialtest) shows that the power does not increase monotonically with the sample size. The graph shows a saw-toothed behaviour. This is caused by the step-wise increase of the critical number of successes ($k_{min}$) with the total sample size.

The required sample size can be computed in two ways. The first option is to compute the smallest sample size for which the power is larger than or equal to the required power $1-\beta$. The alternative is to compute the smallest sample size for which the power is larger than or equal to $1-\beta$ *for all sample sizes larger than this*.

```{r}
n1 <- min(n[which(power > 1-beta)])
ind <- (power > 1-beta)
for(i in 1:length(n)) {
  if(ind[length(n)-i]==FALSE)
    break
}
n2 <- n[length(n)-i+1]
```

The smallest sample size at which the desired level of 0.8 is reached is `r n1`. However, as can be seen in Figure \@ref(fig:powerbinomialtest) for sample sizes 89, 90, 93, 94 and 97 the power drops below the desired level of  0.80. The smallest sample size at which the power stays above the level of 0.8 is `r n2`.

Alternatively, we may use function `pwr.p.test` of package **pwr**. This is an approximation, using an arcsine transformation of proportions. The first step is to compute Cohens's $h$\index{Cohens's $h$}, which is a measure of the distance between two proportions: $h = 2\;arcsin(\sqrt{p_1})-2\;arcsin(\sqrt{p_2})$. This can be done with function `ES.h`. The value of $h$ must be positive, which is achieved when the proportion assigned to argument `p1` is larger than the proportion assigned to argument `p2`.

```{r}
h <- ES.h(p1=0.30,p2=0.20)
n_approx <- pwr.p.test(
  h, power=(1-beta), sig.level=alpha, alternative="greater")
```

The approximated sample size equals `r ceiling(n_approx$n)`, which is somewhat smaller than the required sample sizes computed above.

#### Exercises {-}

1. Write an **R** script to compute the required sample size, given a requirement in terms of half the length of the confidence interval of a proportion. Use a normal approximation for computing the confidence interval. Use a range of values for half the length of the interval: $d = (0.05, 0.1, \dots , 0.45)$. Use a prior (anticipated) proportion of 0.2, and a significance level\index{Significance level} of 0.95. Plot the required sample size against $d$. Explain what you see. Why is it needed to provide a value for the prior proportion?   
2. Do the same for a single value for half the width of the interval of 0.2, and a range of values for the prior proportion $p^* = (0.05,0.10, \dots ,0.50)$. Explain what you see. Why is it not needed to compute the required sample size for prior proportions $> 0.5$?  
    
## Accounting for design effect {#DesignEffect}

The required sample sizes computed in the previous sections are all for simple random sampling in combination with the $\pi$ estimator  of the population mean. But what is the required sample size for other types of sampling design, such as stratified (simple) random sampling, systematic random sampling, two-stage cluster random sampling and cluster random sampling? Broadly speaking we expect that with stratified random sampling and systematic random sampling the sampling variance of the estimator of the mean will be smaller than with simple random sampling of the same number of units, whereas with two-stage cluster random sampling and cluster random sampling we expect larger sampling variances. Therefore, reversely, for the first two types of sampling design we expect that the sample size required to achieve the same level of accuracy or confidence will be smaller than with simple random sampling, and for the latter two design types this sample size will be larger. The design effect\index{Design effect} is commonly quantified by the ratio of two sampling variances of the estimated mean [@loh99]^[It can also be quantified by the ratio of two standard errors. Then there is no need to take the square root of the design effect, as done in Equation \@ref(eq:nreqdesigneffect), to compute the required sample size for a more complex design, given a constraint on the standard error or the half-length of a confidence interval.]:

\begin{equation}
de(p,\hat{\bar{z}}) = \frac{V_p(\hat{\bar{z}})}{V_{\mathrm{SI}}(\hat{\bar{z}}_{\pi})}= \frac{V_p(\hat{\bar{z}})}{S^2(z)/n}\;,
(\#eq:designeffect)
\end{equation}

with $V_p(\hat{\bar{z}})$ the sampling variance of an estimator ($\pi$ estimator, regression estimator) of the population mean with sampling design $p$ and $V_{\mathrm{SI}}(\hat{\bar{z}}_{\pi})$ the sampling variance of the $\pi$ estimator of the population mean with simple random sampling. Given an estimate of this design effect, the required sample size for a more complex sampling strategy (combination of sampling design and estimator), given a constraint on the standard error or the half-length of a confidence interval, can be computed by

\begin{equation}
n_{\mathrm{req}}(p,\hat{\bar{z}}) = \sqrt{de(p,\hat{\bar{z}})} \; n_{\mathrm{req}}(\mathrm{SI,HT}) \;.
(\#eq:nreqdesigneffect)
\end{equation}

## Bayesian sample size determination {#BayesianSampleSize}

A serious drawback of the classical frequentist approach of computing the required sample size explained in the previous sections is that the required sample sizes are sensitive to the design parameters\index{Design parameter} $S^*$, $p^*$ and $cv^*$. We are rather uncertain about these parameters, and therefore it is attractive to replace a single value for these parameters by a probability distribution. This leads to a different statistical approach of computing the required sample size, the Bayesian approach\index{Bayesian approach!to sample size determination}. This Bayesian approach also offers the possibility of accommodating existing information about the population mean or proportion. In this section I show how this approach can be used to compute the required sample size for estimating a population mean or proportion.

But before going into details, let me explain the basics of the Bayesian approach of statistical inference. In the previous sections the statistical inference was from the frequentist perspective. How does the frequency distribution of the estimator of the population mean look like if we repeat the selection of a sample with a given sampling design over and over? Is the mean of this frequency distribution, referred to as the sampling distribution, equal to the population mean, and what is the variance of this sampling distribution?

The Bayesian approach is fundamentally different. The frequency distribution of the frequentist approach is replaced by a probability distribution of the population mean reflecting our *belief* about the population mean. Note that expressing our belief in terms of a probability distribution implies that in the Bayesian approach, contrary to the frequentist approach, the population mean is a random variable. Whereas in the frequentist approach it is incorrect to say that the probability that the population mean is inside the 95\% confidence interval equals 95% (see Section \@ref(ConfidenceInterval)), this is perfectly fine in the Bayesian approach. The term confidence interval is replaced by the term *credible interval*\index{Credible interval} to underline the fundamental different meaning of the interval.

The first step in the Bayesian approach of statistical inference is to postulate a *prior distribution*\index{Prior distribution} for the population parameter of interest. This prior distribution expresses our belief and uncertainty about the parameter before the sample data are taken into account.

The next step is to formalize a theory about the data. This boils down to making an assumption about the type of distribution function of the data. Can we safely assume that the data follow a normal or a binomial distribution? Once the type of distribution has been specified, we can write an equation for the probability of the data *as a function of the parameter*. This function is referred to as the *likelihood function*\index{Likelihood function}.

The final step is to revise our prior belief about the population parameter of interest, using the data and our theory about the data as expressed in the likelihood function. This results in the *posterior distribution*\index{Posterior distribution} of the parameter. Our revised or updated belief is computed with Bayes' rule\index{Bayes' rule}:

\begin{equation}
f(\theta|\mathbf{z}) = \frac{f(\theta) f(\mathbf{z}|\theta)} {f(\mathbf{z})}\;,
(\#eq:BayesTheorem)
\end{equation}

with $f(\theta|\mathbf{z})$ the posterior distribution, i.e. the probability density^[I assume here that the parameter of interest $\theta$ is a continuous random variable.] of the parameter given the sample data, $f(\theta)$ our prior belief in the parameters specified by a probability distribution (prior distribution), $f(\mathbf{z}|\theta)$ the likelihood of the data, and $f(\mathbf{z})$ the probability distribution of the data.

### Bayesian criteria for sample size computation

Equation \@ref(eq:BayesTheorem) shows that the posterior distribution of the population parameter of interest depends on the probability distribution of the new data $f(\mathbf{z})$. The problem is that these new data are not yet known. We are designing a sample, and the data yet are to be collected, so at first glance this might seem an unsolvable problem. However, what we could do is to simulate with the prior probability density function a large number of possible vectors with $n$ data. Each data vector is then used to update the prior to the posterior, using Bayes' rule (Equation \@ref(eq:BayesTheorem)). For each posterior either the length of the highest posterior density (HPD) interval \index{Highest posterior density interval} with a coverage probability\index{Coverage probability} of $1-\alpha$ is computed, or reversely, the coverage probability of the HPD interval of length $l_{\mathrm{max}}$. Finally the average of the lengths of the HPD intervals, or the average of the coverage probabilities is computed, and these averages are compared with our precision requirement. If the average length is larger than $l_{\mathrm{max}}$, or the coverage probability of intervals of length $l_{\mathrm{max}}$ is smaller than $1-\alpha$, then we must increase $n$ and repeat the whole procedure until our precision requirement is met. Simulation is one option to compute the sample size, (partly) analytical approaches are also available.

More formally, the procedure is as follows. The prior probability density function on the population parameter(s) $\theta$ is used to compute for a given sample size $n$ the *predictive* distribution of the data:

\begin{equation}
f(\mathbf{z}|n) = \int_{\Theta} f(\mathbf{z}|\theta,n)f(\theta)\mathrm{d}\theta
(\#eq:predictivedistribution)
\end{equation}

with $\Theta$ the parameter space for $\theta$ containing all possible values of $\theta$. This predictive distribution\index{Predictive distribution} is also named the *preposterior* distribution\index{Preposterior distribution}, stressing that the data are not yet accounted for in the distribution.

Even if $\theta$ would be fixed, we do not have only one vector $\mathbf{z}$ with $n$ data values but a probability distribution, from which we can simulate possible data vectors, referred to as the data space $\mathcal{Z}$. In case of a binomial probability and sample size $n$, the data space $\mathcal{Z}$ (in the form of the number of observed successes given sample size $n$) can be written as the set $\{0,1,\dots,n\}$, i.e. one vector of length $n$ with all failures, $n$ vectors of length $n$ with one success, ${n \choose 2}$  vectors with two successes, etc. Each data vector is associated with a probability density (for continuous data) or probability mass (for discrete data). As a consequence, we do not have only one posterior distribution function $f(\theta|\mathbf{z})$, but as many as we have data vectors in the data space. For each posterior distribution function the coverage of the HPD interval of a given length can be computed, or reversely, the length of the HPD interval for a given coverage. This leads to various criteria for computing the required sample size, among which are the average length criterion\index{Average length criterion}, the average coverage criterion\index{Average coverage criterion} and the worst outcome criterion\index{Worst outcome criterion} (@Joseph1995, @Joseph1997).

#### Average length criterion

For a fixed posterior HPD interval coverage of $100(1-\alpha)$\% the smallest sample size $n$ is determined such that

\begin{equation}
\int_{\mathcal{Z}} l(\mathbf{z},n) f(\mathbf{z}|n)\mathrm{d}\mathbf{z} \leq l_{\mathrm{max}}\;,
(\#eq:ALC)
\end{equation}

where $f(\mathbf{z}|n)$ is the predictive distribution of the data (Equation \@ref(eq:predictivedistribution)), and $l(\mathbf{z},n)$ is the length of the $100(1-\alpha)$\% HPD interval for data $\mathbf{z}$ and sample size $n$, obtained by solving

\begin{equation}
\int_v^{v+l(\mathbf{z},n)}f(\theta|\mathbf{z},n)\mathrm{d}\theta= 1-\alpha\;,
(\#eq:solveALC)
\end{equation}

for $l(\mathbf{z},n)$, for each possible data set $\mathbf{z} \in \mathcal{Z}$. $f(\theta|\mathbf{z},n)$ is the posterior density of the population parameter of interest given the data $\mathbf{z}$ and sample size $n$. ALC ensures that the average length of $100(1-\alpha)$\% posterior HPD intervals, weighted by $f(\mathbf{z}|n)$, is at most $l_{\mathrm{max}}$.

#### Average coverage criterion

For a fixed posterior HPD interval of length $l_\mathrm{max}$ the smallest sample size $n$ is determined such that

\begin{equation}
\int_{\mathcal{Z}} \left\{ \int_v^{v+l_\mathrm{max}}f(\theta|\mathbf{z},n)\mathrm{d}\theta \right\} f(\mathbf{z}|n)\mathrm{d}\mathbf{z} \geq 1-\alpha \;.
(\#eq:ACC)
\end{equation}

The average coverage criterion (ACC) ensures that the average coverage of HPD intervals of length $l_\mathrm{max}$ is at least 1-$\alpha$. The integral inside the curly brackets is the integral of the posterior density of the population parameter of interest over the HPD interval $(v,v+l_\mathrm{max})$, given a data vector $\mathbf{z}$ of size $n$. The mean of this integrated posterior density of the parameter of interest $\theta$ is obtained by multiplying the integrated density with the predictive  probability of the data, and integrating over all possible data sets in $\mathcal{Z}$.

#### Worst outcome criterion

Neither ALC nor ACC guarantee that for a particular data set $\mathbf{z}$ the criterion is met, as these two criteria are defined as averages over all possible data sets in $\mathcal{Z}$. A more conservative sample size can be computed by requiring that for all data sets $\mathcal{Z}$  both criteria are met. @Joseph1997 modified this criterion by restricting the data sets to a subset $\mathcal{W}$ of most likely data sets. The criterion thus obtained is referred to as the modified worst outcome criterion, but I refer to it shortly as the worst outcome criterion (WOC). So the criterion is

\begin{equation}
\mathrm{inf}_{\mathbf{z} \in \mathcal{W}} \left\{\int_v^{v+l(\mathbf{z},n)}f(\theta|\mathbf{z},n)\mathrm{d}\theta\right\} \geq 1- \alpha \;.
(\#eq:worst)
\end{equation}

The smallest sample size satisfying this condition is used as the sample size. For instance, if the 95\% most likely data sets are chosen as subspace $\mathcal{W}$, WOC guarantees that there is 95\% assurance that the length of the $100(1-\alpha)$\% posterior HPD intervals will be at most $l_{\mathrm{max}}$. The fraction of most likely data sets in subspace $\mathcal{W}$ is referred to as the worst level.

### Mixed Bayesian-likelihood approach

Besides the fully Bayesian approach, @Joseph1997 describe a mixed Bayesian-likelihood approach\index{Mixed Bayesian-likelihood approach} for determining the sample size. In the mixed Bayesian-likelihood approach of sample size determination the prior distribution of the parameter(s) is only used to derive the predictive distribution of the data (Equation \@ref(eq:predictivedistribution)), not for deriving the posterior distributions of the parameter of interest for each data vector. For analysis of the posterior distribution, an uninformative prior\index{Uninformative prior} is therefore used.

This mixed approach is of interest when, after the data have been collected, we prefer to estimate the population mean from these data only, using the frequentist approach described in the previous sections. For instance, consider the situation where we have legacy data, but we would like to collect more data so that we will be more confident about the (current) population mean once these new are collected. The legacy data are to construct a prior distribution. If we have doubts about the quality of the legacy data, this mixed Bayesian-likelihood approach can be a good option -- we are willing to use these legacy data to plan the sampling, but not to make statements about the population. 

No closed formula for computing the required sample size exists for this approach because the posterior density function $f(\theta|z,n)$ is not a well-defined distribution as before. However, the required sample size still can be approximated by simulation.

### Estimation of population mean

The three criteria (ALC, ACC and WOC) described above are now used to compute the required sample size for estimating the population mean, assuming that the data come from a normal distribution. As we are uncertain about the population standard deviation $\sigma$ in Equation \@ref(eq:nreqwidthCI), a prior distribution is assigned to this parameter. It is convenient to assign a gamma distribution as a prior distribution to the *reciprocal* of the population variance, referred to as the precision parameter\index{Precision parameter} $\lambda = 1/\sigma^2$. More precisely, a prior *bivariate* normal-gamma distribution\index{Bivariate normal-gamma distribution} is assigned to the population mean and the precision parameter^[This is equal to a normal-inverse gamma distribution to the population mean and population variance.]. With this prior distribution, the *posterior* distribution of the population mean is fully defined, i.e. both the type of distribution and its parameters are known. The prior distribution is so-called *conjugate* with the normal distribution.

The gamma distribution\index{Gamma distribution} has two parameters $a$ and $b$. Figure \@ref(fig:gammaprior) shows the gamma distribution for $a=5$ and $b=100$.

```{r gammaprior, fig.asp=0.7,  fig.cap="Prior gamma distribution for the precision parameter for a shape parameter $a=5$ and a scale parameter $1/b=1/100$."}
a <- 5; b <- 100
x <- seq(from=0, to=0.5, length=1000)
dg <- dgamma(x=x, shape=a, scale=1/b)
plot(x=x, y=dg, type="l", ylab="Density", xlab="Precision")
```

The mean of the precision parameter $\lambda$ is given by $a/b$, and its standard deviation by $\sqrt{a/b^2}$

The normal-gamma prior is used to compute the predictive distribution for the data. For ACC the required sample size can then be computed with [@Adcock1988]

\begin{equation}
n = \frac{4b}{a\; l_{\mathrm{max}}^2}t^2_{2a;1-\alpha/2} - n_0 \;,
(\#eq:nreqACC)
\end{equation}

with $t^2_{2a}$ the squared $(1-\alpha/2)$ quantile of the (usual, i.e. neither shifted, nor scaled) $t$ distribution with $2a$ degrees of freedom, and $n_0$ the number of prior points. The prior sample size $n_0$ is only relevant if we have prior information about the population mean and an informative prior is used for this population mean. If we have no information about the population mean a non-informative prior is used, and $n_0$ equals 0. Note that as $a/b$ is the prior mean of the inverse of the population variance, Equation \@ref(eq:nreqACC) is similar to Equation \@ref(eq:nreqwidthCI). The only difference is that a quantile from the standard normal distribution is replaced by a quantile from a $t$ distribution with $2a$ degrees of freedom.

No closed-form formula exists for computing the smallest $n$ satisfying ALC, but the solution can easily be found by a bisectional search algorithm [@Joseph1997].

Package **SampleSizeMeans** [@Joseph2012] is used to compute Bayesian required sample sizes, using both criteria (ACC and ALC), for the fully Bayesian and the mixed Bayesian-likelihood approach. The gamma distribution plotted in Figure \@ref(fig:gammaprior) is used as a prior distribution for the precision parameter $\lambda$. As a reference, also the frequentist required sample size is computed.

```{r}
library(SampleSizeMeans)
lmax <- 2
n_freq <- mu.freq(len=lmax, lambda=a/b, level=0.95)
n_alc <- mu.alc(len=lmax, alpha=a, beta=b, n0=0, level=0.95)
n_alcmbl <- mu.mblalc(len=lmax, alpha=a, beta=b, level=0.95)
n_acc <- mu.acc(len=lmax, alpha=a, beta=b, n0=0, level=0.95)
n_accmbl <- mu.mblacc(len=lmax, alpha=a, beta=b, level=0.95)
n_woc <- mu.modwoc(
  len=lmax, alpha=a, beta=b, n0=0, level=0.95, worst.level=0.95)
n_wocmbl <- mu.mblmodwoc(
  len=lmax, alpha=a, beta=b, level=0.95, worst.level=0.95)
```

```{r requiredsamplesizesnormalmean, tidy=FALSE, echo=FALSE}
df <- data.frame(n_freq, n_alc, n_alcmbl, n_acc, n_accmbl, n_woc, n_wocmbl)
knitr::kable(
  df, caption = 'Required sample sizes for estimating a normal mean computed with three criteria for fully Bayesian and mixed Bayesian-likelihood (MBL) approach. Freq is required sample size computed with frequentist approach.',
  col.names = c("Freq","ALC","ALC-MBL","ACC","ACC-MBL","WOC","WOC-MBL"),
  booktabs = TRUE
) %>%
  kable_classic()
```

Table \@ref(tab:requiredsamplesizesnormalmean) shows that all six required sample sizes are larger than the frequentist required sample size. This makes sense as the frequentist approach does not account for uncertainty in the population variance parameter. The mixed approach leads to slightly larger required sample sizes than the fully Bayesian approach. This is because in the mixed approach the prior distribution of the precision parameter is not used. Apparently, we do not lose much information by ignoring this prior. With WOC the required sample sizes are about twice the sample sizes obtained with the other two criteria, but this depends of course on the size of the subspace $\mathcal{W}$. If, for instance the 80\% most likely data sets are chosen as subspace $\mathcal{W}$, the required sample sizes are much smaller.

```{r}
n_woc80 <- mu.modwoc(
  len=lmax, alpha=a, beta=b, n0=0, level=0.95, worst.level=0.80)
n_wocmbl80 <- mu.mblmodwoc(
  len=lmax, alpha=a, beta=b, level=0.95, worst.level=0.80)
```

The required sample sizes with this criterion are `r n_woc80` and `r n_wocmbl80` using the fully Bayesian and mixed Bayesian-likelihood approach, respectively.

### Estimation of a population proportion

The same criteria can be used to estimate the proportion of a population, or in case of an infinite population the areal fraction, satisfying some condition [@Joseph1995]. With simple random sampling this boils down to estimating the probability-of-success parameter $p$ of a binomial distribution. In this case the space of possible outcomes $\mathcal{Z}$ is the number of successes, which is discrete: $\mathcal{Z} = \{0,1,\dots ,n\}$ with $n$ the sample size.

The conjugate prior\index{Conjugate prior} for the binomial likelihood is the beta distribution\index{Beta distribution}.
\begin{equation}
p \sim \frac{1}{B(c,d)} \pi^{c-1} (1-\pi)^{d-1} \;,
(\#eq:priorBetadistribution)
\end{equation}
where $B(c,d)$ is the beta function. The two parameters $c$ and $d$ correspond to the number of "successes" and "failures" in the problem context. The larger these numbers, the more the prior information, and the more sharply defined the probability distribution. The plot below shows this distribution for $c=0.6$ and $d=2.4$.

```{r betaprior, fig.asp=0.7,  fig.cap="Prior beta distribution for the binomial proportion, for a beta function $B(0.6,2.4)$."}
c <- 0.6; d <- 2.4
x <- seq(from=0, to=1, length=1000)
dbt <- dbeta(x=x, shape1=c, shape2=d)
plot(x=x, y=dbt, type="l", ylab="Density", xlab="Proportion")
```

The mean of the binomial proportion equals $c/(c+d)$, and its standard deviation $\sqrt{cd/\{(c+d+1)(c+d)^2\}}$.

The preposterior marginal distribution of the data is the beta-binomial distribution

\begin{equation}
f(z|n) = \binom{n}{z}\frac{B(z+c,n-z+d)}{B(c,d)}\;,
(\#eq:preposteriorbinomialdata)
\end{equation}

and for a given number of successes $z$ out of $n$ trials the posterior distribution of $p$ equals

\begin{equation}
f(p|z,n,c,d)=\frac{1}{B(z+c,n-z+d)} p^{z+c-1} (1-p)^{n-z+d-1} \;.  
(\#eq:posteriorbinomialdata)
\end{equation}

For the binomial parameter, criterion ALC (Equation \@ref(eq:ALC)) can be written as
\begin{equation}
\sum_{z=0}^n l(z,n)f(z,n) \leq l_{\mathrm{max}} \;.
(\#eq:ALCbinomial)
\end{equation}

To compute the smallest $n$ satisfying this condition, for each value of $z$ and each $n$, $l(z,n)$ must be computed so that \begin{equation}
\int_v^{v+l(z,n)}f(p|z,n,c,d) \mathrm{d}p = 1-\alpha \;.
\end{equation}

with $v$ the lower bound of the HPD credible set given the sample size and observed number of successes $z$.

For the binomial parameter, criterion ACC (Equation \@ref(eq:ACC)) can be written as

\begin{equation}
\sum_{z=0}^n \mathrm{Pr}\{p \in (v,v+l_{\mathrm{max}})\}  f(z,n) \geq 1-\alpha \;,
(\#eq:ACCbinomial)
\end{equation}

with 

\begin{equation}
\mathrm{Pr}\{p \in (v,v+l_{\mathrm{max}})\}  \propto \int_{v}^{v+l_{\mathrm{max}}}p^z(1-p)^{n-z} f(p) \mathrm{d}p\;,
(\#eq:Binomialprob)
\end{equation}

with $f(p)$ the prior density of the binomial parameter.

For more details about ACC and ALC, and about how the required sample size can be computed with WOC in case of the binomial parameter $p$, I refer to @Joseph1995.

Required sample sizes for the average length criterion (ALC), the average coverage criterion (ACC) and worst outcome criterion (WOC) described in the previous section, using the fully Bayesian approach or the mixed Bayesian-likelihood approach can be computed with package **SampleSizeBinomial**, available at  http://www.medicine.mcgill.ca/epidemiology/Joseph/software/Bayesian-Sample-Size.html. This package is used to compute the required sample sizes using the beta distribution shown in Figure \@ref(fig:betaprior) as a prior for the population proportion. Note that argument `len` of the various functions of package **SampleSizeBinomial** specify the total length of the confidence interval, not *half* the length as used in function `ciss.wald`. 

```{r}
library(SampleSizeBinomial)
n_alc <- prop.alc(
  len=0.2, alpha=c, beta=d, level=0.95, exact=TRUE)$n
n_alcmbl <- prop.mblalc(
  len=0.2, alpha=c, beta=d, level=0.95, exact=TRUE)$n
n_acc <- prop.acc(
  len=0.2, alpha=c, beta=d, level=0.95, exact=TRUE)$n
n_accmbl <- prop.mblacc(
  len=0.2, alpha=c, beta=d, level=0.95, exact=TRUE)$n
n_woc <- prop.modwoc(
  len=0.2, alpha=c, beta=d, level=0.95, exact=TRUE,
  worst.level=0.80)$n
n_wocmbl <- prop.mblmodwoc(
  len=0.2, alpha=c, beta=d, level=0.95, exact=TRUE,
  worst.level=0.80)$n
library(binomSamSize)
n_freq <- ciss.wald(p0=c/(c+d), d=0.1, alpha=0.05)
```

```{r requiredsamplesizesbinomialproportion, echo=FALSE}
df <- data.frame(n_freq,n_alc,n_alcmbl,n_acc,n_accmbl,n_woc,n_wocmbl)
knitr::kable(
  df, caption = 'Required sample sizes for estimating a binomial proportion, computed with three criteria for fully Bayesian and mixed Bayesian-likelihood (MBL) approach. Freq is the required sample size computed with frequentist approach.',
  col.names = c("Freq","ALC","ALC-MBL","ACC","ACC-MBL","WOC","WOC-MBL"),
  booktabs = TRUE
) %>%
  kable_classic()
```

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:12-RequiredSampleSize.Rmd-->

# Model-based optimisation of probability sampling designs {#MBpredictionofDesignVariance}

In Chapter \@ref(Modelassisted) on model-assisted estimation I explained how a linear regression model or a non-linear model obtained with a  machine learning algorithm, can be used to increase the precision of design-based estimates of the population mean or total using the data collected by a given probability sampling design. In this chapter I explain how a model of the study variable can be used at an earlier stage, to optimise probability sampling designs. I show how a model can be used to choose between alternative sampling design types, for instance between systematic random sampling and two-stage cluster random sampling, as well as how a model can be used to optimise the sample size of a given sampling design type, for instance, the number of primary and secondary units with two-stage cluster random sampling. In the final section of this chapter I explain how a model can be used to optimise spatial strata for stratified simple random sampling.

The models used in this chapter are all geostatistical models of the spatial variation. Chapter \@ref(Introkriging) is an introduction to geostatistical modelling. Several geostatistical concepts explained in that chapter are needed here to predict the sampling variance. For an explanation of these concepts, I refer to that chapter.

A general geostatistical model of the spatial variation is

\begin{eqnarray}
Z(\mathbf{s}) &=& \mu(\mathbf{s}) + \epsilon(\mathbf{s}) \notag \\
\epsilon(\mathbf{s}) &\sim& \mathcal{N}(0,\sigma^2)\\
\mathrm{Cov}(\epsilon(\mathbf{s}),\epsilon(\mathbf{s}^{\prime})) &=& C(\mathbf{h}) \notag \;,
(\#eq:geostatmodel)
\end{eqnarray}

with $Z(\mathbf{s})$ the study variable at point $\mathbf{s}$, $\mu(\mathbf{s})$ the mean at point $\mathbf{s}$, $\epsilon(\mathbf{s})$ the residual at point $\mathbf{s}$, and $C(\mathbf{h})$ the covariance of the residuals at two points separated by vector $\mathbf{h} = \mathbf{s}-\mathbf{s}^{\prime}$. Note that contrary to the mean $\mu$ the variance of the residuals $\sigma^2$ is assumed to be constant.

The model of the spatial variation has several parameters. In case of a model in which the mean is a linear combination of covariates, these are the regression coefficients associated with the covariates, and the parameters of a semivariogram describing the spatial dependence of the residuals. A semivariogram is a plot of half the expectation of the squared difference of the study variable (in this case the residuals), referred to as the semivariance, against the distance between two points (Chapter \@ref(Introkriging)). Use of the model for prediction of the sampling variance of a design-based estimator of the population mean requires knowledge of these parameters. When data are available collected from the study area of interest, these data can be used to estimate these parameters. If no such data are available, we must make a best guess, based on data collected in other areas. In all cases I recommend to keep the model as simple as possible.

## Model-based optimisation of sampling design type and sample size

In Chapter \@ref(RequiredSampleSize) I presented methods and formulas for computing the required sample size given various constraints on the quality of the result. These required sample sizes are for simple random sampling. For other types of sampling design, the required sample size can be approximated by multiplying the required sample size for simple random sampling with the design effect, see Section \@ref(DesignEffect). An alternative is to use a model of the spatial variation to predict the sampling variance of the estimator of the mean for the type of sampling design under study and a range of sample sizes, plotting the predicted variance (or standard error) against the sample size, and using this plot inversely to derive the required sample size given a constraint on the sampling variance (standard error).

The computed sample size applies to a given sampling design type. So, for instance, for stratified random sampling the sample size is computed for a given stratification and sample size allocation scheme, for cluster random sampling for given clusters and number of cluster draws, and for two-stage cluster random sampling for given primary sampling units (psu's), number of psu draws and number of secondary sampling units (ssu's) selected per psu draw. However, the model can also be used to optimise these sampling design parameters. For stratified random sampling the optimal allocation can be computed by predicting the population variances within strata and using the predicted population variances per stratum in Equation \@ref(eq:optallocation), and even the stratification can be optimised (Section \@ref(Ospats))). If we have a cost model, for cluster random sampling the size and shape of the clusters, and the number of cluster draws can be optimised, and for two-stage cluster random sampling the size and shape of the primary sampling units, the number of psu draws and number of ssu's per psu draw can be optimised.  

Model-based prediction of the sampling variance can also be useful to compare alternative types of sampling design at equal total costs or equal variances of the estimated population mean or total. For instance, to compare systematic random sampling, leading to good spatial coverage, and two-stage cluster random sampling, resulting in spatial clusters of observations.

Three approaches for model-based prediction of the sampling variance of a design-based estimator of the population mean (or total) are described, the analytical approach (Section \@ref(AnalyticalApproach)), the geostatistical simulation approach (Section \@ref(GeostatisticalSimulationApproach)) and the Bayesian approach (Section \@ref(MBpredSamplingVarBayes)). In the analytical approach we assume that the mean, $\mu(\mathbf{s})$ in Equation \@ref(eq:geostatmodel), is everywhere the same, so we assume no spatial trend. This assumption is relaxed in the geostatistical simulation approach. This approach can also be used to predict the sampling variance using a model in which the mean is a linear combination of covariates, and to predict the sampling variance of the estimator of the mean of trans-Gaussian variables, i.e. random variables that can be transformed to a Gaussian variable. 

The predicted sampling variances of the estimated population mean obtained with the analytical and geostatistical simulation approach are conditional on the model of the spatial variation. Uncertainty about this model is not accounted for. On the contrary, in the Bayesian approach we do account for our uncertainty about the assumed model, and we analyze how this uncertainty propagates to the sampling variance of the estimator of the mean. 

### Analytical approach {#AnalyticalApproach}

In the analytical approach the sampling variance of the estimator of the mean is derived from mean semivariances within the study area\index{Mean semivariance!within a study area}  and mean semivariances within the sample\index{Mean semivariance!within a sample}. These mean semivariances are a function of the separation distance between the points, see Chapter \@ref(Introkriging) for a definition of the semivariance of two random variables. 

The sampling variance of a design-based estimator of the population mean can be predicted by (@dom94, @gru06)

\begin{equation}
E_{\xi}\{V_p(\hat{\bar{z}})\}=\bar{\gamma}-E_p(\boldsymbol{\lambda}^{\prime}\boldsymbol{\Gamma}_{\mathcal{S}}\boldsymbol{\lambda}) \;,
(\#eq:MBdesignvarAnydesign)
\end{equation}

where $E_{\xi}(\cdot)$ is the statistical expectation over realisations from the model $\xi$, $E_{p}(\cdot)$ is the statistical expectation over repeated sampling with sampling design $p$, $V_{p}(\hat{\bar{z}})$ is the variance of the estimator of the mean over repeated sampling with sampling design $p$, $\bar{\gamma}$ is the mean semivariance of the random variable at two randomly selected points in the area, $\boldsymbol{\lambda}$ is the vector of design-based weights of the units of a sample selected with design $p$, and $\boldsymbol{\Gamma}_{\mathcal{S}}$ is the matrix of semivariances between the units of a sample $\mathcal{S}$ selected with design $p$.

The mean semivariance $\bar{\gamma}$ is a model-based prediction of the population variance (spatial variance):

\begin{equation}
\bar{\gamma} = E_{\xi}\{\sigma^2(z)\}\:.
(\#eq:meansemivariance)
\end{equation}

The mean semivariance $\bar{\gamma}$ can be calculated by discretising the area by a fine square grid, and computing the matrix with geographical distances between the discretisation nodes, transforming this into a semivariance matrix, and computing the average of all elements of the semivariance matrix. The second term $E_p(\boldsymbol{\lambda}^{\prime}\boldsymbol{\Gamma}_{\mathcal{S}}\boldsymbol{\lambda})$ can be evaluated by Monte-Carlo simulation, repeatedly selecting a sample according to design $p$, calculating $\boldsymbol{\lambda}^{\prime}\boldsymbol{\Gamma}_{\mathcal{S}}\boldsymbol{\lambda}$, and averaging.

The semivariance at zero distance (same point) is 0, so on the diagonal of a semivariance matrix we have zeroes. If a semivariogram with nugget is assumed, these zeroes on the diagonal must be replaced by the nugget to compute $\bar{\gamma}$. The same holds for the diagonal zeroes in  $\boldsymbol{\Gamma}_{\mathcal{S}}$.  

This generic procedure is still computationally demanding, but it is the only option for complex spatial sampling designs. For basic sampling designs the general formula can be worked out. For simple random sampling, the sampling variance can be predicted by

\begin{equation}
E_{\xi}\{V_\mathrm{SI}(\hat{\bar{z}})\}=\bar{\gamma }/n \;,
(\#eq:MBdesignvarSI)
\end{equation}

and for stratified simple random sampling by

\begin{equation}
E_{\xi}\{V_\mathrm{STSI}(\hat{\bar{z}})\}=\sum_{h=1}^H w^2_h \bar{\gamma_h}/n_h \;,
(\#eq:MBdesignvarSTSI)
\end{equation}

with $H$ the number of strata, $w_h$ the stratum weight (relative size), $\bar{\gamma}_h$ is the mean semivariance of stratum $h$, and $n_h$ the number of sampling points of stratum $h$. For systematic random sampling (sampling on a randomly placed grid), the variance can be predicted by

\begin{equation}
E_{\xi}\{V_\mathrm{SY}(\hat{\bar{z}})\}=\bar{\gamma} - E_{\mathrm{SY}}(\bar{\gamma}_{\mathrm{SY}}) \;,
(\#eq:MBdesignvarSY)
\end{equation}

with $E_{\mathrm{SY}}(\bar{\gamma}_{\mathrm{SY}})$ the expectation over repeated systematic sampling of the mean semivariance within the systematic sample (grid). With systematic random sampling the number of grid points within the study area can vary among samples, as well as the spatial configuration of the points (Chapter \@ref(SY)). Therefore multiple systematic random samples must be selected, and the average of the mean semivariance within the systematic sample must be computed.

The analytical approach is illustrated with the data of agricultural field Leest [@HofmanBrus2021]. Nitrate-N (NO3-N) in kg/ha in the layer 0 - 90 cm below surface, using a standard soil density of 1500 kg/m$^3$, is measured at 30 points. These data are used to compute a sample semivariogram using the method-of-moments, see Chapter \@ref(Introkriging). A spherical model without nugget is fitted to the sample semivariogram using function `fit.variogram`. The numbers in this plot are the numbers of pairs of points used to compute the semivariances.

```{r VariogramLeest, fig.asp=0.7, fig.cap="Sample semivariogram and fitted spherical model for NO3-N in agricultural field Leest. Numbers are numbers of pairs used in computing semivariances."}
library(gstat)
mydata <- read.csv("data/Leest05.csv")
coordinates(mydata) <- ~Easting+Northing
vg <- variogram(N~1, data=mydata)
vgm_MoM <- fit.variogram(
  vg, model=vgm(model="Sph", psill=2000, range=20))
plot(vg, vgm_MoM, plot.numbers=TRUE)
```

The few data makes that the sample semivariogram is very noisy. For the moment I ignore my uncertainty about the semivariogram parameters. In Section \@ref(MBpredSamplingVarBayes) I show how we can account for our uncertainty about the semivariogram parameters in model-based prediction of the sampling variance. A spherical semivariogram model\index{Semivariogram model} without nugget is fitted to the sample semivariogram, i.e. the intercept is 0. The fitted range of the model is `r round(vgm_MoM$range,0)` m, and the fitted sill equals `r round(vgm_MoM$psill,0)`. The fitted semivariogram is used to predict the sampling variance for three sampling designs: simple random sampling, stratified simple random sampling, and systematic random sampling. The sample size is 25 points. For systematic random sampling the number of points varies among the samples. For this sampling design the *expected* sample size is 25 points.

For simple random sampling we must compute the mean semivariance within the field (Equation \@ref(eq:MBdesignvarSI)). This mean semivariance is approximated by discretising the field by a square grid of 2000 points, computing the 2000 $\times$ 2000 matrix with distances between all pairs of discretisation nodes, transforming this distance matrix into a semivariance matrix using function `variogramLine` of package **gstat** [@peb04] , and finally averaging the semivariances. Note that in this case we do not need to replace the zeroes on the diagonal of the semivariance matrix by the nugget, as a model without nugget is fitted. The shape file is read with function `readOGR` of package **rgdal** [@rgdal], resulting in an object of class `SpatialPolygonsDataFrame`. The projection attributes of this object are removed with function `proj4string` to avoid an error message when running function `spsample`.

```{r ExiVarSILeest}
library(rgdal)
shpField <- readOGR(dsn="data", layer="Leest5", verbose=FALSE)
proj4string(shpField) <- NA_character_
mygrid <- spsample(
  shpField, type="regular", n=2000, offset=c(0.5, 0.5)) %>%
  as(., "data.frame")
H <- as.matrix(dist(mygrid))
G <- variogramLine(vgm_MoM, dist_vector=H)
m_semivar_field <- mean(G)
n <- 25
Exi_V_SI <- m_semivar_field/n
```

The model-based prediction of the sampling variance of the estimator of the mean with this design equals `r round(Exi_V_SI,1)`.

The strata of the stratified simple random sampling design are compact geographical strata\index{Compact geographical strata} of equal size (Section \@ref(geostrata)). The number of geostrata is equal to the sample size, 25 points, so that we have one point per stratum. To predict the sampling variance we must compute the mean semivariances within the geostrata, see Equation \@ref(eq:MBdesignvarSTSI). Note that the stratum weights are constant as the strata have equal size: $w_h = 1/25$.

```{r ExiVarSTSILeest}
library(spcosa)
gridded(mygrid) <- ~x1+x2
mygeostrata <- stratify(
  mygrid, nStrata=n, equalArea=TRUE, nTry=10) %>%
  as(., "data.frame")
m_semivar_geostrata <- numeric(length=n)
for (i in 1:n) {
 ids <- which(mygeostrata$stratumId==(i-1))
 mysubgrd <- mygeostrata[ids,]
 H_geostratum <- as.matrix(dist(mysubgrd[,c(2,3)]))
 G_geostratum <- variogramLine(vgm_MoM, dist_vector=H_geostratum)
 m_semivar_geostrata[i] <- mean(G_geostratum)
}
Exi_V_STSI <- sum(m_semivar_geostrata)/n^2
```

The model-based prediction of the sampling variance of the estimator of the mean with this design equals `r round(Exi_V_STSI,1)`, which is much smaller than with simple random sampling. The large stratification effect\index{Stratification effect} can be explained by the assumed strong spatial structure of NO3-N in the agricultural field and the improved geographical spreading of the sampling points.

To predict the  sampling variance for systematic random sampling with an expected sample size of 25 points, we must compute the expectation of the mean semivariance within the systematic sample (Equation \@ref(eq:MBdesignvarSY)). This expectation is approximated by selecting a large number of systematic random samples, computing the mean semivariance for each sample, and averaging. This average of mean semivariances within a systematic sample is subtracted from the mean semivariance within the field.

```{r}
set.seed(314)
m_semivar_SY <- numeric(length=100)
for (i in 1:100) {
  mySYsample <- spsample(x=mygrid, n=n, type="regular") %>%
    as(., "data.frame")
  H_SY <- as.matrix(dist(mySYsample))
  G_SY <- variogramLine(vgm_MoM, dist_vector=H_SY)
  m_semivar_SY[i] <- mean(G_SY)
}
Exi_V_SY <- m_semivar_field-mean(m_semivar_SY)
```

The model-based prediction of the sampling variance of the estimator of the mean with this design equals `r as.character(round(Exi_V_SY,1))`, which is smaller than that of stratified simple random sampling, which can be explained by the improved geographical spreading of the sampling points with systematic random sampling as compared to stratified simple random sampling with compact geographical strata.

#### Bulking soil aliquots into a composite sample

If the soil aliqouts collected at the points of the stratified random sample are bulked into a composite, as is usually done in soil testing of agricultural fields, the procedure for predicting the variance of the estimator of the mean is slightly different. Only the composite sample\index{Composite sampling} is analyzed in a laboratory on NO3-N, not the individual soil aliquots\index{soil aliquot}. This implies that the contribution of the measurement error\index{Measurement error} to the total uncertainty about the population mean is larger. To predict the sampling variance in this situation, we need the semivariogram of errorless measurements of NO3-N, i.e. of the true NO3-N contents of soil aliquots collected at points. The sill of this semivariogram  will be smaller than the sill of the semivariogram of measured NO3-N data. A simple option is to subtract an estimate of the measurement error variance from the semivariogram of measured NO3-N data that contain a measurement error. So the measurement error variance is subtracted from the nugget. This may lead to negative nuggets, which is not allowed (a variance cannot be negative). The preferable alternative is to fit the model with maximum likelihood, and adding the measurement error variance to the diagonal of the covariance matrix of the data, see function `ll` in Section \@ref(MBpredSamplingVarBayes). 

#### Exercises {-}

1. Write an **R** script to predict the sampling variance of the estimator of the mean of NO3-N of agricultural field Leest, estimated by simple random random sampling and a sample size of 25 points. Use in prediction a spherical semivariogram with a nugget of 483, a partial sill of 483 and a range of 44.6 m. The sum of the nugget and partial sill (966) is equal to the sill of the semivariogram used above in predicting sampling variances. Compare the predicted sampling variance with the predicted sampling variance for the same sampling design, obtained with the semivariogram without nugget. Explain the difference.  
2. Write an **R** script to compute the required sample size for simple random random sampling of agricultural field Leest, for a maximum length of a 95\% confidence interval of 20. Use the semivariogram without nugget in predicting the sampling variance. See Section \@ref(ReqSampleSizeLengthCI) (Equation \@ref(eq:nreqwidthCI)) for how to compute this required sample size given a prior estimate of the standard deviation of the study variable in the population.  
3. Do the same for systematic random sampling. Note that for this sampling design no such formula is available. Predict for a series of *expected* sample sizes, $n = 5,6,\dots , 40$, the sampling variance of the estimator of the mean, using Equation \@ref(eq:MBdesignvarSY). Approximate $E_{\mathrm{SY}}(\bar{\gamma}_{\mathrm{SY}})$ from ten repeated selections. Compute the length of the confidence interval from the predicted sampling variances, and plot the interval length against the sample size. Finally determine the required sample size for a maximum length of 20. What is the design effect for an expected sample size of 34 points (the required sample size for simple random sampling), see Equation \@ref(eq:designeffect)? Also compute the design effect for expected sample sizes of $5,6,\dots , 40$. Explain why the design effect is not constant.  

### Geostatistical simulation approach {#GeostatisticalSimulationApproach}

In the analytical approach no values of the study variable are simulated, neither at the nodes of a discretisation grid to predict the population variance, nor at the points of random samples to predict the variance within samples. Mean semivariances, $\bar{\gamma}$, $\bar{\gamma}_h$, $\bar{\gamma}_\mathrm{SY}$, are computed from matrices with distances between pairs of points that are transformed into matrices with semivariances. It is true that for systematic random sampling in cases where the sample size is and/or the spatial pattern of the sampling points is random, simulation is needed. A large number of systematic samples is selected to approximate the design-expectation of the mean semivariance within a systematic sample (Equation \@ref(eq:MBdesignvarSY)). However, only the spatial coordinates of these samples are used. No values of the study variable at the sampling points are simulated.

The alternative is to use a geostatistical simulation\index{Geostatistical simulation} approach. It is computationally more demanding, but an advantage of this approach is its flexibility. It can also be used to predict the sampling variance of the estimator of the mean using a geostatistical model with a non-constant mean. And besides, this approach can also handle trans-Gaussian variables\index{Trans-Gaussian variable}, i.e. of variables whose distribution can be transformed into a normal distribution. In Section \@ref(MBpredSamplingVarBayes) on the Bayesian approach geostatistical simulation is used to predict the variance of the estimator of the mean of a lognormal variable. 

The geostatistical  simulation approach for predicting the sampling variance of a design-based estimator of the population mean involves the following steps:  

1. Select a large number $S$ of random samples with sampling design $p$.  
2. Use the model to simulate values of the study variable for all sampling points.  
3. Estimate for each sample the population mean, using the design-based estimator of the population mean for sampling design $p$. This results in $S$ estimated population means.  
4. Compute the variance of the $S$ estimated means.  
5. Repeat steps 1 to 4 $R$ times, and compute the mean of the $R$ variances.  

This approach is illustrated with the three administrative regions (woredas) in Ethiopia where a large sample is available with organic matter data in the topsoil (SOM) in mass percentages (wt\%) of dry soil. The soil samples are collected along roads (see Figure \@ref(fig:spatialinfillEthiopia)). It is a convenience sample\index{Convenience sample}, not a probability sample, so these sample data cannot be used in design-based or model-assisted estimation of the mean or total soil carbon stock in the study area. However, the data can be used to model the spatial variation of SOM, and this geostatistical model\index{Geostatistical model} can then be used to design a probability sample for design-based estimation of the total SOM stock. Apart from the point data of SOM, maps of covariates are available, such as a digital elevation model and remote sensing reflectance data. I selected four covariates to model the mean of SOM: elevation (dem), average near infrared reflectance (rfl-NIR), average red reflectance (rfl-red) and average land surface temperature (lst). I assume a normal distribution for the residuals of the linear model.  The model parameters are estimated by restricted maximum likelihood\index{Restricted maximum likelihood estimation} (REML), using package **geoR** [@geoR], see Section \@ref(REML) for details on REML estimation of a geostatistical model.

```{r}
library(geoR)
load(file="data/ThreeWoredasEthiopia.RData")
priordata <- as(priordataEthiopia, "data.frame")
dGeoR <- as.geodata(
  obj=priordata, header=TRUE,
  coords.col=13:14, data.col=1, covar.col=c(3,9,10,11))
vgm_REML <- likfit(
  geodata=dGeoR, 
  trend=~dem+rfl_NIR+rfl_red+lst, 
  cov.model="spherical", ini.cov.pars=c(1,5),nugget=0.2,
  lik.method="REML", messages=FALSE)
```

The estimated parameters of the residual semivariogram of SOM are shown in Table \@ref(tab:VariogramREMLEthiopia). The estimated regression coefficients are `r round(vgm_REML$beta[1],1)` for the intercept, `r round(vgm_REML$beta[2],3)` for elevation (dem), `r round(vgm_REML$beta[3],2)` for NIR reflectance, `r round(vgm_REML$beta[4],2)` for red reflectance and `r round(vgm_REML$beta[5],3)` for land surface temperature. 

Package **gstat** [@peb04] is used for geostatistical simulation, and therefore first the REML estimates of the semivariogram parameters are assigned to the arguments `nugget`, `psill` and `range` of the function `vgm` of this package. 

```{r}
vgm_REML_gstat <- vgm(
  model="Sph",
  nugget=vgm_REML$tausq,
  psill=vgm_REML$sigmasq,
  range=vgm_REML$phi)
```

The fitted model of the spatial variation of SOM is used to compare systematic random sampling and two-stage cluster random sampling at equal variances of the estimated mean. First the sampling variance with systematic random sampling is predicted. One hundred systematic random samples ($S=100$) with an expected sample size of 50 points ($E[n]=50$) are selected. The four covariates at the selected sampling points are extracted by overlaying the `SpatialPointsDataFrame`  `mySYsamples` and the `SpatialPixelsDataFrame` `grd` with function `over` of package **sp** [@Pebesma2005]. Values at the sampling points are simulated by sequential Gaussian simulation\index{Sequential Gaussian simulation} [@goo97], using function `krige`  with argument `nsim = 1` of package **gstat**. The argument `dummy` is set to `TRUE` to enforce unconditional simulation\index{Geostatistical simulation!unconditional}. The alternative is conditional simulation\index{Geostatistical simulation!conditional}, using the data of the convenience sample as a conditioning data. Conditional simulation is only recommended if the quality of these legacy data is sufficient, and we may trust that the study variable at the legacy points is not changed since these legacy data are collected.

Note that by first drawing 100 samples, followed by simulating values of $z$ at the selected sampling points, instead of first simulating values of $z$ at the nodes of a discretisation  grid, followed by selecting samples and overlaying with the simulated field, the simulated values of points in the same discretisation cell differ, so that we account for the infinite number of points in the population.

With systematic random sampling the sample mean is an approximately unbiased estimator of the population mean (Chapter \@ref(SY)). Therefore, of each sample the mean of the simulated values is computed, using the function `tapply`. Finally, the variance of the 100 sample means is computed. This is a conditional variance, conditional on the simulated values. The whole procedure is repeated 100 times ($R=100$), leading to 100 conditional variances of sample means.

```{r MonteCarloEthiopia, eval=FALSE}
load(file="data/CovariatesThreeWoredasEthiopia.RData")
grd <- grdEthiopia
gridded(grd) <- ~s1+s2
S <- R <- 100
v_mzsim_SY <- numeric(length=R)
set.seed(314)
for (i in 1:R) {
  mySYsamples <- NULL
  for (j in 1:S) {
    xy <- spsample(x=grd, n=50, type="regular")
    mySY <- data.frame(
      s1=xy$x1, s2=xy$x2, sample=rep(j, length(xy)))
    mySYsamples <- rbind(mySYsamples, mySY)
  }
  coordinates(mySYsamples) <- ~s1+s2
  res <- over(mySYsamples, grd)
  mySYs <- data.frame(mySYsamples, res[,c(1,3,4,5)])
  coordinates(mySYs) <- ~s1+s2
  zsim <- krige(
    dummy~dem+rfl_NIR+rfl_red+lst, 
    locations=mySYs, newdata=mySYs, 
    model=vgm_REML_gstat, beta=vgm_REML$beta,
    nmax=20, nsim=1,
    dummy=TRUE,
    debug.level=0) %>% as(.,"data.frame")
  m_zsim <- tapply(zsim$sim1, INDEX=mySYs$sample, FUN=mean)
  v_mzsim_SY[i] <- var(m_zsim)
}
```

```{r, eval=FALSE, echo=FALSE}
save(v_mzsim_SY,file="results/MBpredictionDesignVariance_SY.RData")
```

```{r, echo=FALSE}
load(file="results/MBpredictionDesignVariance_SY.RData")
```

```{r, echo=FALSE}
Exi_vmz_SY <- mean(v_mzsim_SY)
```

The mean of the 100 conditional variances equals `r round(Exi_vmz_SY,3)`. This is a Monte Carlo approximation of the model-based prediction of the sampling variance of the ratio estimator of the mean for systematic random sampling with an expected sample size of 50.

Due to the geographical spreading of the sampling points with systematic random sampling, the accuracy of the estimated mean is expected to be high compared to that of other sampling designs of the same size. However, with large areas the time needed for travelling to the sampling points can become substantial, lowering the sampling efficiency. With large areas, sampling designs leading to spatial clusters of sampling points can be an attractive alternative. One option then is two-stage cluster random sampling, see Chapter \@ref(Twostage). The question is whether this alternative design is more efficient than systematic random sampling.

For the three woredas in Ethiopia 100 compact geostrata (see Section \@ref(geostrata)) are computed. Here these geostrata are not used as strata in stratified random sampling, but as primary sampling units (psu's) in two-stage cluster random sampling. The difference is that in stratified random sampling from each geostratum at least one sampling unit is selected, whereas in two-stage cluster random sampling only a randomly selected subset of the geostrata is sampled. The compact geostrata, used as psu's, are computed with function `kmeans`, and as a consequence the psu's do not have equal size. This is not needed in two-stage cluster random sampling, see Chapter \@ref(Twostage). If psu's of equal size are preferred, then these can be computed with function `stratify` of package **spcosa** with argument `equalArea=TRUE`, see Section \@ref(geostrata).

```{r}
load(file="data/CovariatesThreeWoredasEthiopia.RData")
grd <- grdEthiopia
set.seed(314)
res <- kmeans(
  grd[,c("s1","s2")], iter.max=1000, centers=100, nstart=100)
mypsus <- res$cluster
psusize <- as.numeric(table(mypsus))
summary(psusize)
```

To keep the estimation of the population mean simple, the psu's are selected with probabilities proportional to their size and with replacement (ppswr sampling), see Chapter \@ref(Twostage).

#### Optimisation of sample sizes for two-stage cluster random sampling

In Section \@ref(twostagesamplingestimators) formulas are presented for computing the optimal number of psu draws and ssu draws per psu draw. The optimal sample sizes are a function of the pooled variance of primary unit means, $S^2_{\mathrm{b}}$, and the pooled variance of secondary units (points) within the primary units, $S^2_{\mathrm{b}}$. In this section these variance components are predicted with the geostatistical model.

As a first step a large number of fields is simulated.

```{r}
grd$psu <- mypsus
coordinates(grd) <- ~s1+s2
set.seed(314)
zsim <- krige(
  dummy~dem+rfl_NIR+rfl_red+lst, 
  locations=grd, newdata=grd, 
  model=vgm_REML_gstat, beta=vgm_REML$beta, 
  nmax=20, nsim=1000, 
  dummy=TRUE,
  debug.level=0) %>% as(.,"data.frame")
zsim <- zsim[,-c(1,2)]
```

For each simulated field the means of the psu's and the variances within the psu's are computed using function `tapply` in function `apply`.

```{r}
m_zsim_psu <- apply(zsim, MARGIN=2, FUN=function(x) 
  tapply(x, INDEX=grd$psu, FUN=mean))
v_zsim_psu <- apply(zsim, MARGIN=2, FUN=function(x)
  tapply(x, INDEX=grd$psu, FUN=var))
```

Next for each simulated field the pooled variance of psu means and pooled variance within psu's is computed, and finally these pooled variances are averaged over all simulated fields. These averages are approximations of the model-expectations of the pooled between unit and within unit variances, $E_{\xi}[S^2_{\mathrm{b}}]$ and $E_{\xi}[S^2_{\mathrm{w}}]$.

```{r}
p_psu <- psusize/sum(psusize)
S2b <- apply(m_zsim_psu, MARGIN=2, FUN=function(x)
  sum(p_psu*(x-sum(p_psu*x))^2))
S2w <- apply(v_zsim_psu, MARGIN=2, FUN=function(x)
  sum(p_psu*x))
Exi_S2b <- mean(S2b)
Exi_S2w <- mean(S2w)
```

The optimal sample sizes are computed for a simple linear costs model: $C = c_1\;n + c_2n\;m$, with $c_1$ the access costs per primary unit, including the access costs of the ssu's (points) with a given psu, and $c_2$ the observation costs per ssu. Note that for the optimal sample sizes only the ratio of $c_1$ and $c_2$ is important, not their absolute values. Given values for $c_1$ and $c_2$, the optimal number of psu draws $n$, and optimal number of ssu draws per psu draw $m$ is computed, required for a sampling variance of the estimator of the mean equal to the sampling variance with systematic random sampling of 50 points, see Equations \@ref(eq:nopt) and \@ref(eq:mopt). 

```{r}
c1 <- 2; c2 <- 1
nopt <- 1/Exi_vmz_SY*(sqrt(Exi_S2w*Exi_S2b)*sqrt(c2/c1)+Exi_S2b)
mopt <- sqrt(Exi_S2w/Exi_S2b)*sqrt(c1/c2)
```

The optimised number of psu draws is `r ceiling(nopt)`, and the optimal number of points per psu draw equals `r ceiling(mopt)`. The total number of sampling points is `r ceiling(nopt)` $\times$ `r ceiling(mopt)` $=96$. This is much larger than the sample size of 50 obtained with systematic random sampling. The total observation costs therefore are substantially larger. However, the access time can be substantially smaller due to the spatial clustering of sampling points. To answer the question whether the costs saved by this reduced access time outweighs the extra costs of observation, the model for the access costs and observation costs must be further developed.

### Bayesian approach {#MBpredSamplingVarBayes}

The model-based prediction of the variance of the design-based estimate of the population mean for a given sampling design is conditional on the model. If we change the model type or the model parameters, the predicted sampling variance also changes. In most situations we are quite uncertain about the model, even in situations where we have data that can be used to estimate the model parameters, as in the Ethiopia case study. Instead of using the best estimated model to predict the sampling variance as done in the previous sections, we may prefer to account for the uncertainty about the model parameters. This can be done through a Bayesian approach\index{Bayesian approach!to prediction of sampling variance}, in which the legacy data are used to update a prior distribution of the model parameters to a posterior distribution. For details about a Bayesian approach for estimating model parameters, see Section \@ref(BayesianGridSpacing). A sample from the posterior distribution of model parameters is used one-by-one to predict the sampling variance. This can be done either analytically, as described in Section \@ref(AnalyticalApproach), or through geostatistical simulation. Both approaches result in a *distribution* of sampling variances, reflecting our uncertainty about the sampling variance of the estimator of the population mean due to uncertainty about the semivariogram. The mean or median of the distribution of sampling variances can be used as the predicted sampling variance. 

The Bayesian approach is illustrated with a case study on predicting the sampling variance of NO3-N in an agricultural field in Belgium [@HofmanBrus2021]. Data of NO3-N are available at 30 points, forming approximately a square grid with a spacing of about 4.5 m. As a first step, I check whether we can safely assume that the data come from a normal distribution.

```{r qqplotMelle, fig.asp=0.7, out.width="70%", fig.cap="Q-Q plot of Nitrate-N of field Melle."}
mydata <- read.csv("data/Melle17.csv", header=TRUE)
ggplot(mydata, aes(sample=N)) +
  geom_qq() +
  geom_qq_line()
pvalue <- shapiro.test(mydata$N)$p.value
```

The Q-Qplot\index{Q-Q plot} shows that a normal distribution is not very likely: there are too many large values, the distribution is skewed to the right. Also the $p$-value\index{Level of significance of a test}\index{\emph{p}-value of a test} of the Shapiro-Wilk test\index{Shapiro-Wilk test} shows that we should reject the null-hypothesis of a normal distribution for the data: *p*=`r as.character(round(pvalue,4))`. I therefore proceed with the natural logarithm of NO3-N, in short lnN.

```{r, echo=FALSE}
mydata$lnN <- log(mydata$N)
```

```{r, echo=FALSE}
min_Easting <- min(mydata$Easting)
min_Northing <- min(mydata$Northing)
mydata$Easting <- mydata$Easting - min_Easting
mydata$Northing <- mydata$Northing - min_Northing 
```

As a first step the semivariogram of lnN is estimated by maximum likelihood\index{Maximum likelihood estimation} (Section \@ref(MLestimationVariogram)). An exponential semivariogram model is assumed. Note that the parameters that are estimated are the reciprocal of the sill $\lambda$, the ratio of spatial dependence\index{Ratio of spatial dependence} $\xi$, defined as the partial sill divided by the sill, and the distance parameter $\phi$. This parameterisation of the semivariogram is chosen because hereafter in the Bayesian approach prior distributions are chosen for these parameters.

The likelihood function is defined, using a somewhat unusual parameterisation, tailored at the Markov chain Monte Carlo (MCMC) sampling\index{Markov chain Monte Carlo sampling} from the posterior distribution of the semivariogram parameters. In MCMC a Markov chain of sampling units (vectors with semivariogram parameters) is generated by using the previous sampling unit to randomly generate the next sampling unit (@Gelman2013, chapter 11]. In MCMC sampling the probability of accepting a proposed sampling unit $\boldsymbol{\theta}^*$  is a function of the ratio of the posterior density of the proposed sampling unit and that of the current sampling unit, $f(\boldsymbol{\theta}^*|\mathbf{z})/f(\boldsymbol{\theta}_{t-1}|\mathbf{z})$, so that the normalizing constant, the denominator of Equation \@ref(eq:BayesTheorem), cancels. For a nice introduction to MCMC I refer to these [lecture notes](http://nitro.biosci.arizona.edu/courses/EEB596/handouts/Gibbs.pdf).

```{r}
library(mvtnorm)
ll <-function(thetas) {
  sill <- 1/thetas[1]
  psill <- thetas[2]*sill
  nugget <- sill-psill
  vgmodel <- vgm(
    model=model, psill=psill, range=thetas[3], nugget=nugget)
  C <- variogramLine(vgmodel, dist_vector=D, covariance=TRUE)
  Cinv <- chol2inv(chol(C))
  XC <- crossprod(X, Cinv)
  XCz <- XC%*%z
  XCX <- XC%*%X
  beta <- solve(XCX, XCz)
  mu <- as.numeric(X%*%beta)
  logLik <- dmvnorm(x=z, mean=mu, sigma=C, log=TRUE)
  logLik
}
```

Next, initial estimates of the semivariogram parameters are estimated by maximising the likelihood, using function `optim`. 

```{r}
lambda.ini <- 1/var(mydata$lnN)
xi.ini <- 0.5
phi.ini <- 20
pars <- c(lambda.ini, xi.ini, phi.ini)
D <- as.matrix(dist(mydata[,c(1,2)]))
X <- matrix(1, nrow(mydata), 1)
z <- mydata$lnN
model <- "Exp"
vgML <- optim(
  pars, ll, control=list(fnscale = -1),
  lower=c(1e-6,0,1e-6), upper=c(1000,1,150),
  method="L-BFGS-B")
```

The maximum likelihood (ML) estimates of the semivariogram parameters are used as initial values in MCMC sampling. In the Bayesian approach, I use a uniform prior for the inverse of the sill parameter, $\lambda=1/\sigma^2$, with a lower bound of $10^{-6}$ and an upper bound of 1. For the distance parameter $\phi$ of the exponential semivariogram a uniform prior is assumed, with a lower bound of $10^{-6}$ m. and an upper bound of 150 m. For the relative nugget, $\tau^2/\sigma^2$, a uniform prior is assumed with a lower bound of 0 and an upper bound of 1.

These priors can be defined by function `createUniformPrior` of package **BayesianTools** [@Hartig2018]. The function `createBayesianSetup` is then used to define the setup of the MCMC sampling, specifying the likelihood function, the prior, and the vector with best prior estimates of the model parameters, specified with argument `best`. Argument `sampler` of function `runMCMC` specifies the type of MCMC sampler. I used the differential evolution algorithm\index{Differential evolution algorithm} of @terBraak2008. Argument `start` of function `getSample` specifies the burn-in period\index{Burn-in period}, i.e. the number of first samples that are discarded to diminish the influence of the initial semivariogram parameter values. Argument `numSamples` specifies the sample size, i.e. the number of saved vectors with semivariogram parameter values, drawn from the posterior distribution.

```{r MCMCMelles, eval=FALSE}
library(BayesianTools)
priors <- createUniformPrior(lower=c(1e-6, 0, 1e-6),
                             upper=c(1000,1,150))
bestML <- c(vgML$par[1], vgML$par[2], vgML$par[3])
setup <- createBayesianSetup(
  likelihood=ll, prior=priors,
  best=bestML, names=c("lambda","xi","phi"))
set.seed(314)
res <- runMCMC(setup, sampler="DEzs")
MCMCsample <- getSample(
  res, start=1000, numSamples=1000) %>% data.frame(.)
```

```{r, eval=FALSE, echo=FALSE}
write.csv(file="results/MCMC_Melle17_logN.csv", MCMCsample, row.names=FALSE)
```

Figure \@ref(fig:MCMCsampleVariogramlnN) shows several semivariograms, sampled by MCMC from the posterior distribution of the estimated semivariogram parameters.

```{r, echo=FALSE}
MCMCsample <- read.csv(file="results/MCMC_Melle17_logN.csv",header=TRUE)
```

```{r MCMCsampleVariogramlnN, echo=FALSE, fig.asp=0.7, fig.cap="Semivariograms of lnN, obtained by MCMC sampling from posterior distribution of the estimated semivariogram parameters for field Melle." }
d <- 1:150
semivar <- matrix(nrow=length(d),ncol=20)
for (i in 1:20) {
  sill <- 1/MCMCsample$lambda[i]
  psill <- MCMCsample$xi[i]*sill
  nugget <- sill-psill
  phi <- MCMCsample$phi[i]
  g <- variogramLine(vgm(model="Exp",psill=psill,range=phi,nugget=nugget),dist_vector=d)
  semivar[,i] <- g$gamma
}
dfsemi <- data.frame(d=d,semivar)
df_lf <- dfsemi %>%
  pivot_longer(cols=names(dfsemi)[-1])

ggplot(df_lf, mapping=aes(x=d,y=value, group=name))+
  geom_line()+
  scale_x_continuous(name="Distance (m)",) +
  scale_y_continuous(name="Semivariance",limits=c(0,NA))
```

The evaluated sampling design is the same as used in Section \@ref(AnalyticalApproach) above for field Leest: stratified simple random sampling, using compact geographical strata of equal size, a total sample size of 25 points, and one point per stratum. 

```{r, echo=FALSE}
shpField <- readOGR(dsn="data", layer="Melle17", verbose=FALSE)
proj4string(shpField) <- NA_character_
mygrid <- spsample(shpField,type="regular",n=2000,offset=c(0.5,0.5)) %>% as(.,"data.frame")
mygrid$x1 <- mygrid$x1-min_Easting
mygrid$x2 <- mygrid$x2-min_Northing
gridded(mygrid) <- ~x1+x2
n <- 25
mygeostrata <- stratify(mygrid,nStrata=n,equalArea=TRUE,nTry=10)
```

The next step is to simulate with each of the sampled semivariograms a large number of maps of lnN. This is done by sequential Gaussian simulation, conditional on the available data. The simulated values are backtransformed. Each simulated map is then used to compute the variance of the simulated values within the geostrata $S^2_h$. These stratum variances are used to compute the sampling variance of the estimator of the mean:

\begin{equation}
    V(\hat{\bar{z}}) = \frac{1}{H^2}\sum_{h=1}^H S^2_h \;.
    (\#eq:VarSTSIMelles)
\end{equation}

This variance estimator follows from Equation \@ref(eq:EstVarMeanSTSI). Plugging $w_h = 1/H$ (all strata have equal size) and $n_h=1$ into this variance estimator yields Equation \@ref(eq:VarSTSIMelles).

I used the first 100 sampled semivariograms, and with each semivariogram I simulated 100 maps.

```{r, echo=FALSE}
mygeostrata <- as(mygeostrata, "data.frame")
```


```{r simulatevariances, eval=FALSE}
V <- matrix(data=NA, nrow=100, ncol=100)
coordinates(mydata) <- ~Easting+Northing
set.seed(314)
for (i in 1:100) {
  sill <- 1/MCMCsample$lambda[i]
  psill <- MCMCsample$xi[i]*sill
  nug <- sill - psill
  range <- MCMCsample$phi[i]
  vgmdl <- vgm(model="Exp", nugget=nug, psill=psill, range=range)
  ysim <- krige(
    lnN~1, locations=mydata, newdata=mygrid, 
    model=vgmdl, 
    nmax=20, nsim=100,
    debug.level=0) %>% as(., "data.frame")
  zsim <- exp(ysim[,-c(1,2)])
  S2h <- apply(zsim, MARGIN=2, FUN=function(x)
    tapply(x, INDEX=as.factor(mygeostrata$stratumId), FUN=var))
  V[i,] <- 1/n^2*apply(S2h, MARGIN=2, FUN=sum)
}
```

```{r, eval=FALSE, echo=FALSE}
save(V, file="results/SimulatedSamplingVariances_Melle17.RData")
```

Figure \@ref(fig:plotsimulatedmapsMelle) shows sixteen simulated maps, simulated with the first four semivariograms. The four maps in a row (a to d) are simulated with the same semivariogram. All maps show that the simulated data have positive skew, which is in agreement with the prior data. The data obtained by simulating from a lognormal distribution are always strictly positive. This is not guaranteed when simulating from a normal distribution.

```{r, echo=FALSE, eval=FALSE}
#coordinates(mydata) <- ~Easting+Northing
v <- matrix(data=NA, nrow=4, ncol=4)
Zsim <- NULL
set.seed(314)
for (i in 1:4) {
  sill <- 1/MCMCsample$lambda[i]
  psill <- MCMCsample$xi[i]*sill
  nugget <- sill - psill
  range <- MCMCsample$phi[i]
  for (j in 1:4) {
    ysim <- krige(
      lnN~1,
      locations=mydata,
      newdata=mygrid,
      model=vgm(model="Exp", nugget=nugget, psill=psill, range=range),
      nmax=20,
      nsim=1,
      debug.level=0) %>% as(.,"data.frame")
    zsim <- exp(ysim$sim1)
    S2h <- tapply(zsim, INDEX=as.factor(mygeostrata$stratumId), FUN=var)
    v[i,j] <- 1/n^2*sum(S2h)
    fld <- paste0(i,letters[j])
    zsimdf <- data.frame(coordinates(mygrid),zsim=zsim,fld=fld)
    Zsim <- rbind(Zsim,zsimdf)
  }
}
save(Zsim, v, file="results/SimulatedMaps_Melle17.RData")
```

```{r, plotsimulatedmapsMelle, echo=FALSE, out.width="100%", fig.cap="Maps of NO3-N simulated with four semivariograms (rows). Each semivariogram is used to simulate four maps (columns a-d)."}
load(file="results/SimulatedMaps_Melle17.RData")
ggplot(data=Zsim) +
  geom_raster(mapping=aes(x=x1, y=x2, fill=zsim)) +
  scale_x_continuous(name="") +
  scale_y_continuous(name="") +
  coord_fixed(ratio=1) +
  scale_fill_continuous(name="Nsim",type="viridis",limits=c(0,100)) +
  facet_wrap(~ fld,nrow=4,ncol=4)
```

The sampling variances of the estimated mean of NO3-N obtained with these sixteen maps are shown below. 

```{r, echo=FALSE}
colnames(v) <- c("a","b","c","d")
rownames(v) <- 1:4
round(v,3)
```

The sampling variance shows quite strong variation among the maps. The histogram shows the uncertainty distribution of the sampling variance, due to uncertainty about the semivariogram, as well as due to uncertainty about the spatial distribution of NO3-N within the agricultural field given the semivariogram and the available data from that field.

```{r, echo=FALSE}
load(file="results/SimulatedSamplingVariances_Melle17.RData")
```

```{r histogramNMelle, echo=FALSE, fig.asp=0.7, fig.cap="Histogram of simulated sampling variances of the estimator of the mean of NO3-N for stratified simple random sampling of field Melle."}
ggplot() +
  geom_histogram(aes(x=V), binwidth=0.2, fill="black", alpha=0.5, colour="black") +
  scale_y_continuous(name="Frequency") +
  scale_x_continuous(name="Variance of estimator of mean")
```

```{r, echo=FALSE}
Exi_V_STSI <- mean(V)
P50_V_STSI <- quantile(V, 0.5)
P90_V_STSI <- quantile(V, 0.9)
```

As a model-based prediction of the sampling variance we can take the average or the median of the sampling variances over all $100 \times 100$ simulated maps, which are equal to `r round(Exi_V_STSI,3)` and `r round(P50_V_STSI,3)`, respectively.  If we want to be more safe, we can take a high quantile, e.g. the P90 of this distribution as the predicted sampling variance, which is equal to `r round(P90_V_STSI,3)`

Above I used the 30 data as conditioning data in geostatistical simulation, Unconditional simulation is recommended if we cannot rely on the quality of the legacy data, for instance due to a temporal change in lnN since the time the legacy data were observed. For NO3-N this might well be the case. I believe that, although the effect of 30 observations on the simulated fields and on the uncertainty distribution of the sampling variance will be very small, one still may prefer unconditional simulation. With unconditional simulation we must assign the model mean $\mu$ to the argument `beta` of function `krige`. The estimated model mean depends on the semivariogram parameters. The next code chunk shows how this model mean can be estimated(see also function `ll` above).

```{r, eval=FALSE}
C <- variogramLine(vgmodel, dist_vector=D, covariance=TRUE)
Cinv <- chol2inv(chol(C))
XC <- crossprod(X, Cinv)
XCz <- XC%*%z
XCX <- XC%*%X
beta <- solve(XCX, XCz)
```

## Model-based optimisation of spatial strata {#Ospats}

@deGruijter2015 described a novel spatial stratification method that uses model predictions of the study variable as a stratification variable while accounting for errors in the predictions, as well as spatial correlation of the prediction errors.

The **Julia** package **Ospats** is an implementation of the stratification method. In **Ospats**\index{Optimal spatial stratification} the stratification is optimised through iterative reallocation of the raster cells to the strata. Recently, this stratification method was implemented in the package **SamplingStrata** (@Barcaroli2014, @Barcaroli2020). However, the algorithm used to optimise the strata differs from that in **Ospats**.  In `SamplingStrata` the stratification is optimised by optimising the breaks\index{Stratum breaks} (splitting points) on the stratification variable with a genetic algorithm\index{Genetic algorithm}. Optimisation of the strata through optimisation of the breaks on the stratification variable necessarily leads to non-overlapping strata, while with iterative reallocation\index{Iterative reallocation} the strata may overlap, i.e. when the strata are sorted on the mean of the stratification variable, the upper bound of a stratum can be larger than the lower bound of the next stratum. As argued by @deGruijter2015 optimisation of strata through optimisation of the stratum breaks can be suboptimal. On the other hand, optimisation through optimisation of the breaks needs fewer computations, and therefore is quicker.

The situation considered in this section is that prior data are available, either from the study area itself or from another similar area, that can be used to fit a statistical model for the study variable, using one or more quantitative covariates and/or factors as predictors. We wish to collect (more) data by stratified simple random sampling, to be used in design-based estimation of the population mean or total of the study variable. The central research question then is how to construct these strata.

Recall the formula for the variance of the estimator of the mean for stratified simple random sampling (see Equations \@ref(eq:EstVarMeanSTSI) and \@ref(eq:EstVarstratummean)):

\begin{equation}
V\!\left(\hat{\bar{z}}\right)=\sum\limits_{h=1}^{H}w_{h}^{2} \frac{S^2_h(z)}{n_h}\;.
(\#eq:VarMeanSTSI2)
\end{equation}

Plugging the stratum sample sizes under optimal allocation (Equation \@ref(eq:optallocation)) into Equation \@ref(eq:VarMeanSTSI2), gives for the variance of the estimator of the mean:

\begin{equation}
V\!\left(\hat{\bar{z}}\right)=\frac{1}{n}\left(\sum\limits_{h=1}^{H}w_h S_h(z) \sqrt{c_h} \sum_{h=1}^H \frac{w_h S_h(z)}{\sqrt{c_h}}\right)\;.
(\#eq:VSTSINeyman)
\end{equation}

So given the total sample size $n$ the variance of the estimator of the mean is minimal when the criterion 

\begin{equation}
O = \sum\limits_{h=1}^{H}w_h S_h(z) \sqrt{c_h} \sum_{h=1}^H \frac{w_h S_h(z)}{\sqrt{c_h}}
(\#eq:minicritospats)
\end{equation}

is minimised. 

@deGruijter2015 assume that the costs are equal for all population units, so that the mean costs are the same for all strata. In this case the minimisation criterion reduces to
\begin{equation}
O = \left(\sum\limits_{h=1}^H w_h S_h(z)\right)^2\;.
(\#eq:EOconstantch)
\end{equation}

In practice we do not know the values of the study variable $z$. @deGruijter2015 consider the situation where we have predictions of the study variable from a statistical model: $\hat{z} = z + \epsilon$, with $\epsilon$ the prediction error. So this implies that we do not know the stratum standard deviations $S_h(z)$ of Equation \@ref(eq:VSTSINeyman). What we do have are the stratum standard deviations of the predictions of $z$: $S_h(\hat{z})$. With many statistical models, such as regression and kriging models, the standard deviation of the predictions are smaller than that of the study variable: $S_h(\hat{z}) < S_h(z)$. This is known as the smoothing or leveling effect. 

@deGruijter2015 replaced the stratum standard deviations in the minimisation criterion by model-expectations of these stratum standard deviations, i.e. by model-based predictions of the stratum standard deviations), $E[S_h(z)]$. This leads to the following minimisation criterion:

\begin{equation}
E_{\xi}[O] = \left(\sum\limits_{h=1}^H w_h E_{\xi}[S_h(z)]\right)^2\;.
(\#eq:EOconstantch2)
\end{equation}

@deGruijter2015 predicted the stratum variances by

\begin{equation}
E_{\xi}[S^2_h(z)]=\frac{1}{N^2_h}\sum_{i=1}^{N_h-1}\sum_{j=i+1}^{N_h}E_{\xi}[d^2_{ij}]\;,
\end{equation}

with $d^2_{ij} = (z_i-z_j)^2$ the squared difference of the study variable values at two nodes of a discretisation grid. The model-expectation of the squared differences are equal to

\begin{equation}
E_{\xi}[d^2_{ij}] = (\hat{z}_i-\hat{z}_j)^2+S^2(\epsilon_i)+S^2(\epsilon_j)-2S^2(\epsilon_i,\epsilon_j)
(\#eq:Exid2ij)
\;, 
\end{equation}

with $S^2(\epsilon_i)$ the variance of the prediction error at node $i$, and $S^2(\epsilon_i,\epsilon_j)$ the covariance of the prediction errors at nodes $i$ and $j$. The authors then argue that for smoothers, such as kriging and regression, the first term must be divided by the squared correlation coefficient $R^2$:

\begin{equation}
E_{\xi}[d^2_{ij}] = \frac{(\hat{z}_i-\hat{z}_j)^2}{R^2}+S^2(\epsilon_i)+S^2(\epsilon_j)-2S^2(\epsilon_i,\epsilon_j) \;.
(\#eq:Exid2ij2)
\end{equation}

The predicted stratum standard deviations are approximated by the square root of Equation \@ref(eq:Exid2ij2). Plugging these model-based predictions of the stratum standard deviations into the minimisation criterion, Equation \@ref(eq:EOconstantch), yields

\begin{equation}
E_{\xi}[O] = \frac{1}{N} \sum\limits_{h=1}^H \left( \sum_{i=1}^{N_h-1}\sum_{j=i+1}^{N_h}\frac{(\hat{z}_i-\hat{z}_j)^2}{R^2}+S^2(\epsilon_i)+S^2(\epsilon_j)-2S^2(\epsilon_i,\epsilon_j) \right)^{1/2}\;.
(\#eq:minicritospatsDeGruijter)
\end{equation}

Optimal spatial stratification with package **SamplingStrata** is illustrated with a survey of the soil organic matter (SOM) concentration (g/kg) in the topsoil (A horizon) of Xuancheng (China). Three samples are available. These three samples are merged. The total number of sampling points is 183. This sample is used to fit a simple linear regression model for SOM, using the elevation of the surface (dem) as a predictor. The function `lm` of the **stats** package is used to fit the simple linear regression model.

```{r}
sample_grid <- read.csv("data/Xuancheng_gridsample.csv")
sample_iPSM <- read.csv("data/Xuancheng_iPSMsample.csv")
sample_test <- read.csv("data/Xuancheng_Stratifiedrandomsample.csv")
mysample <- rbind(sample_grid, sample_iPSM, 
                  sample_test[,-c(13,14,15)])
lm_SOM <- lm(SOM_A_hori~dem, data=mysample)
```

In fitting a linear regression model we assume that:  

1. the relation is linear.  
2. the residual variance is constant (independent of the fitted value).  
3. the residuals have a normal distribution.  

These assumptions are checked with a scatter plot of the residuals against the fitted value and a Q-Q plot\index{Q-Q plot}, respectively.

```{r checkassumptions, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap = "Scatter plot of residuals against fitted value, and Q-Q plot of residuals, for a simple linear regression model of soil organic matter concentration in Xuancheng, with elevation as a predictor."}
fit <- fitted(lm_SOM)
e <- residuals(lm_SOM)
df <- data.frame(fit=fit, resid=e)
plt1 <- ggplot(df) +
  geom_point(mapping=aes(x=fit, y=e)) +
  geom_hline(yintercept=0) +
  scale_x_continuous(name="Fitted value") +
  scale_y_continuous(name="Residuals")

plt2 <- ggplot(df, aes(sample=e)) +
  geom_qq() +
  geom_qq_line()

grid.arrange(plt1, plt2, nrow=1)
```

The scatter plot shows that the first assumption is realistic. No pattern can be seen, at all fitted values the residuals are scattered around the horizontal line. However, the second and third assumptions are questionable: the residual variance clearly increases with the fitted value, and the distribution of the residuals has positive skew, i.e. it has a long upper tail. There clearly is some evidence that these two assumptions are violated. Possibly these problems can be solved by fitting a model for the natural logarithm of SOM.

```{r checkassumptions2, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap = "Scatter plot of residuals against fitted value, and Q-Q plot of residuals, for a simple linear regression model of natural logarithm of soil organic matter concentration in Xuancheng, with elevation as a predictor."}
mysample$lnSOM <- log(mysample$SOM_A_hori)
lm_lnSOM <- lm(lnSOM~dem, data=mysample)
e <- residuals(lm_lnSOM)
fit <- fitted(lm_lnSOM)
df <- data.frame(fit, e)
plt1 <- ggplot(df) +
  geom_point(mapping=aes(x=fit, y=e)) +
  geom_hline(yintercept=0) +
  scale_x_continuous(name="Fitted value") +
  scale_y_continuous(name="Residuals")

plt2 <- ggplot(df, aes(sample=e)) +
  geom_qq() +
  geom_qq_line()

grid.arrange(plt1, plt2, nrow=1)
```

The variance of the residuals is more constant, and the Q-Q plot is improved, although we now have too many strong negative residuals for a normal distribution. I proceed with the model for natural log-transformed SOM (lnSOM).

Another assumption in linear regression is that the residuals are independent. This assumption can be checked by computing a semivariogram. If the residual semivariance is not constant with the distance but increases, the assumption is violated. For details I refer to Chapter \@ref(Introkriging). Figure \@ref(fig:residualvariogramSOM) shows the semivariogram of the residuals computed with function `variogram` of package **gstat** [@peb04].

```{r residualvariogramSOM, echo=FALSE, fig.asp=0.7, fig.cap="Sample semivariogram of residuals of simple linear regression model for natural logarithm of soil organic matter concentration in Xuancheng."}
library(gstat)
mysample$X <- mysample$X/1000
mysample$Y <- mysample$Y/1000
coordinates(mysample) <- ~X+Y
vg <- variogram(lnSOM~dem, data=mysample)
plot(vg, plot.numbers=TRUE)
```

The first two points in the semivariogram have somewhat smaller values. This indicates that the residuals at two close points, say $< \pm 5$ km are not independent, whereas if the distance between the two points $> \pm 5$ km, they are independent. This spatial dependency of the residuals can be modelled, e.g. by an exponential function:

\begin{equation}
\gamma(h)=\left \{
\begin{array}{ll}
0      &\,\,\,\text{if}\,\,\, h=0 \\
c_0+c_1\; \mathrm{exp}(-h/\phi) &\,\,\,\text{if}\,\,\, h > 0 \\
\end{array}
\right.
(\#eq:ExponVariogram)
\end{equation}

This exponential semivariogram has three parameters, the nugget\index{Nugget} variance $c_0$, the partial sill\index{Partial sill} variance $c_1$ and the distance parameter\index{Distance parameter} $\phi$. The total number of model parameters now is five: two regression coefficients (intercept and slope for elevation), and three semivariogram parameters. All five parameters can best be estimated by restricted maximum likelihood\index{Restricted maximum likelihood estimation}, see Section \@ref(REML). Table \@ref(tab:TableModelXuancheng) shows the estimated regression coefficients and semivariogram parameters. Up to a distance of about three times the estimated distance parameter $\phi$, which is about 8 km, the residuals are spatially correlated, beyond that distance, they are hardly correlated anymore. 

```{r, echo=FALSE}
library(geoR)
mysample <- as(mysample,"data.frame")
dGeoR <- as.geodata(
   obj=mysample, 
   header=TRUE, 
   coords.col=4:5, 
   data.col=13,
   covar.col=12
 )
vgm_REML <- likfit(
  geodata=dGeoR, trend=~dem, cov.model="exponential",
  ini.cov.pars=c(0.05,3),
  nugget=0.1, lik.method="REML", messages=FALSE)
```

```{r TableModelXuancheng, echo=FALSE}
int <- round(vgm_REML$beta[1],3)
dem <- round(vgm_REML$beta[2],5)
nugget <- c(round(vgm_REML$nugget,3))
psill <- c(round(vgm_REML$sigmasq,3))
range <- c(round(vgm_REML$phi,3))

coefs <- data.frame(int,dem,nugget,psill,range)
rownames(coefs) <- c()

knitr::kable(
  coefs, caption = 'Estimated regression coefficients (intercept and slope for dem), and parameters of exponential semivariogram for natural logarithm of soil organic matter concentration in Xuancheng (China).',
  booktabs = TRUE,col.names=c("Int","dem","Nugget","Partial sill", "Distance parameter (km)")
) %>%
  kable_classic()
```

The fitted model is used to predict lnSOM at the nodes of a 200 m $\times$ 200 m discretisation grid.

```{r}
load("data/Xuancheng.RData")
res <- predict(lm_lnSOM, newdata=as(grd,"data.frame"), se.fit=TRUE)
grd <- within(as(grd,"data.frame"), 
              {lnSOMpred <- res$fit; varpred <- res$se.fit^2})
```

The predictions and their standard errors are shown in Figure \@ref(fig:predictedlnSOM).

```{r predictedlnSOM, echo=FALSE, out.width="100%", fig.cap = "Predicted natural logarithm of soil organic matter concentration (g/kg) in the topsoil, and its  standard error in Xuancheng, obtained with a linear regression model with elevation as predictor."}
plt1 <- ggplot(grd) +
  geom_raster(mapping=aes(x=x1, y=x2, fill=lnSOMpred)) +
  scale_fill_continuous(name="lnSOM",type="viridis") + 
  scale_x_continuous(name="Easting /km") +
  scale_y_continuous(name="Northing /km") +
  coord_fixed()

plt2 <- ggplot(grd) +
  geom_raster(mapping=aes(x=x1, y=x2, fill=sqrt(varpred))) +
  scale_fill_continuous(name="se",type="viridis") +
  scale_x_continuous(name="Easting /km") +
  scale_y_continuous(name="Northing /km") +
  coord_fixed()
grid.arrange(plt1, plt2, ncol=1)
```

The discretisation grid with predicted lnSOM consists of 115,526 nodes. These are too many for function `optimStrata`. The grid is therefore thinned to a grid with a spacing of 800 m $\times$ 800 m, resulting in 7257 nodes.

```{r, echo=FALSE}
library(sp)
gridded(grd) <- c("x1","x2")
subgrd <- spsample(grd, type="regular", cellsize=0.8, offset=c(0.5,0.5))
subgrd <- data.frame(coordinates(subgrd), over(subgrd,grd))
```

The first step in optimisation of spatial strata with package **SamplingStrata** is to build the sampling frame with function `buildFrameSpatial`. The argument `X` specifies the stratification variables, and argument `Y` specifies the study variables. In our case we have only one stratification variable and one study variable, and these are the same variable. Argument `var` specifies the variance of the prediction error of the study variable. The variable `dom` is an identifier of the domain of interest of which we want to estimate the mean or total. I assigned the value 1 to all population units, which implies that the stratification is optimised for the entire population. If we have multiple domains of interest, the stratification is optimised for each domain separately.

Finally, as a preparatory step we must specify how precise the estimated mean should be. This precision must be specified in terms of the coefficient of variation (cv), i.e. the standard error of the estimated mean divided by the mean. In case of multiple domains of interest, and multiple study variables a cv must be specified per domain and per study variable. This precision requirement is used to compute the sample size for Neyman allocation (Equation \@ref(eq:Neymanallocation))^[For multivariate stratification, i.e. stratification with multiple study variables, Bethel allocation is used to compute the required sample size.]. The optimal stratification is independent of the precision requirement, although for a large cv, the optimal number of strata can be smaller than the value assigned to argument `nStrata` of function `optimStrata`, see hereafter.

```{r}
library(SamplingStrata)
subgrd$id <- c(1:nrow(subgrd))
subgrd$dom <- rep(1,nrow(subgrd))
frame <-buildFrameSpatial(
  df=subgrd, id="id",
  X=c("lnSOMpred"), Y=c("lnSOMpred"),
  variance=c("varpred"),
  lon="x1", lat="x2",
  domainvalue="dom")
cv <- as.data.frame(list(DOM="DOM1",CV1=0.005,domainvalue=1))
```

The optimal spatial stratification can be computed with function `optimStrata`, with argument `method="spatial"`. The $R^2$ value of the linear regression model, used in the minimisation criterion (Equation \@ref(eq:minicritospatsDeGruijter)), can be assigned to argument `fitting`. I used an $R^2$ value of one, because I believe the smoothing effect is already accounted for by the variance and covariance of the prediction errors (Equation \@ref(eq:Exid2ij)). Arguments `range` and `kappa` are parameters of an exponential semivariogram, needed for computing the covariance of the prediction errors. Function `optimiStrata` uses an extra parameter in the exponential semivariogram (Equation \@ref(eq:ExponVariogram)), $c_0+c_1\; \mathrm{exp}(-\kappa h/\phi)$, so for the usual exponential semivariogram `kappa` equals 1.

```{r, eval=FALSE}
res <- optimStrata(
  framesamp=frame,
  method="spatial",
  errors=cv,
  nStrata=5,
  fitting=1,
  range=c(vgm_REML$phi),
  kappa=1,
  showPlot=FALSE)
```

```{r, eval=FALSE, echo=FALSE}
save(res,file="results/OptimalStrataXuancheng_SamplingStrata_cv005.RData")
```

```{r, echo=FALSE}
load(file="results/OptimalStrataXuancheng_SamplingStrata_cv005.RData")
```

A summary of the optimised strata can be obtained with function `summaryStrata`.

```{r}
print(smr_strata <- summaryStrata(
  res$framenew, res$aggr_strata, progress=FALSE))
```

In the next code chunk it is checked whether the coefficient of variation is indeed equal to the desired value.

```{r}
strata <- res$aggr_strata
framenew <- res$framenew
N_h <- strata$N
w_h <- N_h/sum(N_h)
se <- sqrt(sum(w_h^2*strata$S1^2/strata$SOLUZ))
se/mean(framenew$Y1)
```

The coefficient of variation can also be computed with function `expected_CV`.

```{r}
expected_CV(strata)
```

Figure \@ref(fig:optimalstrataXuanchengSamplingStrata) shows the optimised strata. I used the stratum bounds in the data frame `smr_strata`, to compute the stratum for all raster cells of the original 200 m $\times$  200 m grid.

```{r optimalstrataXuanchengSamplingStrata, echo=FALSE, out.width="100%", fig.cap="Model-based optimal strata for estimating the population mean of natural logarithm of soil organic matter (lnSOM) concentration (g/kg)."}
grd <- as(grd,"data.frame")
preds <- predict(lm_lnSOM,grd)
strat <- findInterval(preds, smr_strata$Upper_X1[-5])

labels <- as.character(round(smr_strata$Upper_X1,2))
first <- paste("<",labels[1])
second <- paste(labels[1],"-",labels[2])
third <- paste(labels[2],"-",labels[3])
fourth <- paste(labels[3],"-",labels[4])
fifth <- paste(">",labels[4])
labs <- c(first,second,third,fourth,fifth)

ggplot(grd) +
  geom_raster(mapping=aes(x=x1, y=x2, fill=factor(strat))) +
  scale_fill_viridis_d(name="lnSOM", labels=labs) + 
  scale_x_continuous(name="Easting /km") +
  scale_y_continuous(name="Northing /km") +
  coord_fixed()
```

```{r, echo=FALSE}
rm(list=ls())
```



<!--chapter:end:13-MBOptimisationProbabilitySampling.Rmd-->

# Sampling for estimating parameters of (small) domains {#SmallAreaEstimation}

This chapter is about probability sampling and estimation of means or totals of subpopulations (subareas, subregions). In the sampling literature these subpopulations are referred to as domains of interest\index{Domains of interest}, or shortly domains. Ideally at the stage of designing a sample these domains are known, and of every population unit we know to which domain it belongs. In that situation it is most convenient to use these domains as strata in random sampling, so that we can control the sample size in each domain (Chapter \@ref(STSI)). 

If we have multiple maps with domains, think for instance of a soil class map, a map with land cover classes, and a map with countries, we can make an overlay of these maps to construct the cross-tabulation strata. However, this may result in numerous strata, in some cases even more than the sample size. In this situation an attractive solution is multi-way stratification (Section \@ref(Multiwaystratification)). With this design the domains of interest are used as strata, not their cross-classification, and the sample sizes of these marginal strata are controlled.

Even with a multi-way stratified sample, resulting in controlled sample sizes for each domain, the sample size of a domain can be too small for a reliable estimate of the total or mean when using the data of that domain only. In that case we may use model-assisted estimators. In Chapter \@ref(Modelassisted) model-assisted estimation of the population mean or total is explained, using all data collected from the population are used. In this chapter (Section \@ref(SmallDomainsModelAssisted)) also data outside the domain are used, more specifically to estimate the population regression coefficients (@cha94, @Rao2003, @Falorsi2008).

We may also wish to estimate the mean or total of domains that are not used as (marginal) strata. The sample size in these domains is then not controlled, and varies among samples selected with the sampling design. As before with multi-way stratified sampling, the mean can either be estimated with the direct estimator, using the data from the domain only (Section \@ref(LargeDomainsDirectEstimator)), or a model-assisted estimator, also using data from outside the domain for estimating regression coefficients (Section \@ref(SmallDomainsModelAssisted)).

## Direct estimator for large domains {#LargeDomainsDirectEstimator}

If the sample size of a domain $d$ is considered large enough to obtain a reliable estimate of the mean, and besides the size of the domain is known, the mean of that domain can be estimated by the direct estimator\index{Direct estimator}:

\begin{equation}
\hat{\bar{z}}_{d}=\frac{1}{N_{d}}\sum_{k \in \mathcal{S}_d}\frac{z_{dk}}{\pi _{dk}} \;,
(\#eq:piestimatormeandomain)
\end{equation}

where $N_{d}$ is the size of the domain, $z_{dk}$ is the value for unit $k$ of domain $d$, and $\pi _{dk}$ is the inclusion probability of this point.

When the domain is not used as a (marginal) stratum, so that the sample size of the domain is random, the mean of the domain can best be estimated by

\begin{equation}
\hat{\bar{z}}_{\text{ratio},d}= \frac{\hat{t}_d(z)}{\widehat{N}_d}=
\frac{\sum_{k \in \mathcal{S}_d}\frac{z_{dk}}{\pi_{dk}}}{\sum_{k \in \mathcal{S}_d}\frac{1}{\pi_{dk}}} \;.
(\#eq:generalratiodomain)
\end{equation}

with $\widehat{N}_{d}$ the estimated size of the domain:

\begin{equation}
\widehat{N}_{d}=\sum_{k \in \mathcal{S}_d}\frac{1}{\pi _{i}} \;.
(\#eq:piestimatorpopulationsize)
\end{equation}

This ratio estimator\index{Ratio estimator} can also be used when the size of the domain is unknown. An example of this is estimating the mean of soil classes *as observed in the field*, and not *as depicted on a soil map*. A soil map is impure, i.e. the map units contain patches with other soil classes than as indicated on the map. The area of a given true soil class is not known. 

For simple random sampling $\pi_{dk} = n/N$. Inserting this in Equation \@ref(eq:generalratiodomain) gives

\begin{equation}
\hat{\bar{z}}_{\text{ratio},d}=\frac{1}{n_{d}}\sum_{k \in \mathcal{S}_d}z_{dk} \;.
(\#eq:ratiodomainSI)
\end{equation}

The mean of the domain is simply estimated by the mean of the $z$-values observed in the domain, i.e. the sample mean in domain $d$. The variance of this estimator can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\text{ratio},d}\right) =
\frac{1}{\hat{a}_{d}^{2}}\cdot\frac{1}{n\,(n-1)}\sum_{k \in \mathcal{S}_d}(z_{dk}-\bar{z}_{\mathcal{S}_d})^{2} \;,
(\#eq:VarratiodomainSI)
\end{equation}

where $\bar{z}_{\mathcal{S}_d}$ is the sample mean in domain $d$, and $\hat{a}_{d}$ is the estimated relative size of domain $d$:

\begin{equation}
\hat{a}_{d}=\frac{n_{d}}{n} \;.
(\#eq:estimatedrelativesizedomain)
\end{equation}

I refer to Section 8.2.2 in @gru06 for the ratio estimator and its standard error with stratified simple random sampling in case the domains cut across the strata, and other sampling designs.

The ratio estimator and its standard error can be computed with function `svyby` of package **survey** [@Lumley2020]. This is illustrated with Eastern Amazonia. We wish to estimate the mean aboveground biomass (AGB) of the sixteen ecoregions from a simple random sample of 200 units.

```{r, echo=FALSE}
load(file="data/Amazonia_1km.RData")
mz_pop <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=mean)
```

```{r}
library(survey)
n <- 200
set.seed(314)
units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
mysample <- gridAmazonia[units,c("AGB","Ecoregion")]
mysample$N <- nrow(gridAmazonia)
design_si <- svydesign(id=~1, data=mysample, fpc=~N)
res <- svyby(~AGB, by=~Ecoregion, design=design_si, FUN=svymean)
```

The ratio estimates are shown in Table \@ref(tab:TableRatioEstimatesEcoregions).

```{r TableRatioEstimatesEcoregions, echo=FALSE}
rownames(res) <- NULL
res[,c(2,3)] <- round(res[,c(2,3)],1)
knitr::kable(
  res, caption = 'Ratio estimates of mean aboveground biomass (AGB) and their standard errors of ecoregions in Eastern Amazonia. The ecoregions with an estimated standard error of 0.0 have one sampling unit only, and actually are non-availables.',
  booktabs = TRUE
) %>%
  kable_classic()
```

The sampling is repeated 1,000 times, and every sample is used to estimate the mean AGB of the ecoregions both with the $\pi$ estimator and the ratio estimator. As can be seen below the standard error of the ratio estimator is much smaller than the standard deviation of the $\pi$ estimator. The reason is that the number of sampling units in a ecoregion varies among samples, i.e. the sample size of an ecoregion is random. When many units are selected from an ecoregion, the estimated total of that ecoregion is large. The estimated mean as obtained with the $\pi$ estimator then is large too, because the estimated total is divided by the fixed size (total number of population units, $N_d$) of the ecoregion. However, in the ratio estimator the size of an ecoregion is estimated from the same sample, despite that we know its size, see Equation \@ref(eq:generalratiodomain). With many units selected from an ecoregion, the estimated size of that ecoregion, $\widehat{N}_d$ is also large. By dividing the large estimated total by the large estimated size, a more stable estimate of the mean of the domain is obtained. For quite a few ecoregions the standard errors are very large, especially of the $\pi$ estimator. These are the ecoregions with very small average sample sizes. With simple random sampling the expected sample size can simply be computed by $E[n] = n \; N_d/N$. In the following section alternative estimators are described for these ecoregions with small expected sample sizes. To speed up the computations I used a 5 km $\times$ 5 km subgrid in this sampling experiment.

```{r, echo=FALSE, eval=FALSE}
load(file="data/Amazonia_5km.RData")
mz_pop <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=mean)
ecoregions <- sort(unique(gridAmazonia$Ecoregion))
N <- nrow(gridAmazonia)
N_eco <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=length)
number_of_samples <- 1000
mx_eco_pop <- tapply(gridAmazonia$lnSWIR2, INDEX=gridAmazonia$Ecoregion, FUN=mean)
mX_eco_pop <- data.frame(Intercept=rep(1, length(mx_eco_pop)), lnSWIR2=mx_eco_pop)

set.seed(314)
mz_eco_HT <- mz_eco_ratio <- mz_eco_regr <- mz_eco_synt <- mz_eco_extsynt <- matrix(nrow=length(ecoregions), ncol=number_of_samples, dimnames=list(ecoregions,seq(1:number_of_samples)))
for (i in 1:number_of_samples) {
  print(i)
  mypop <- gridAmazonia
  units <- sample.int(nrow(mypop), size=n, replace=FALSE)
  mysample <- mypop[units,c("AGB","Ecoregion")]

# HT estimator
  tz <- (N/n) * tapply(mysample$AGB, INDEX=mysample$Ecoregion, FUN=sum)
  mz_eco_HT[names(tz),i] <- tz/N_eco[names(tz)]

# ratio estimator
  mysample$N <- N
  design_si <- svydesign(id=~1, data=mysample, fpc=~N)
  res <- svyby(~AGB, by=~Ecoregion, design=design_si, FUN=svymean)
  mz_eco_ratio[res$Ecoregion,i] <- res$AGB
  
# regression estimator
  mypop$ind <- rep(0,nrow(mypop))
  mypop$ind[units] <- 1
  mypop$AGB[mypop$ind == 0] <- NA 
  res <- forestinventory::twophase(AGB~lnSWIR2, data=mypop,
                                   phase_id=list(phase.col="ind",terrgrid.id=1),
                                   small_area=list(sa.col="Ecoregion",areas=ecoregions,unbiased=TRUE),
                                   psmall=TRUE, exhaustive=mX_eco_pop)$estimation
  mz_eco_regr[,i] <- res$estimate

# synthetic estimator
  res <- forestinventory::twophase(AGB~lnSWIR2, data=mypop,
                                   phase_id=list(phase.col="ind",terrgrid.id=1),
                                   small_area=list(sa.col="Ecoregion",areas=ecoregions,unbiased=FALSE),
                                   psmall=FALSE, exhaustive=mX_eco_pop)$estimation
  mz_eco_synt[,i] <- res$estimate
  
# extended synthetic estimator
  res <- forestinventory::twophase(AGB~lnSWIR2, data=mypop,
                                   phase_id=list(phase.col="ind",terrgrid.id=1),
                                   small_area=list(sa.col="Ecoregion",areas=ecoregions,unbiased=TRUE),
                                   psmall=FALSE, exhaustive=mX_eco_pop)$estimation
  mz_eco_extsynt[,i] <- res$estimate

}
save(mz_eco_HT, mz_eco_ratio, mz_eco_regr, mz_eco_synt, mz_eco_extsynt, file="results/MeanAGB_ecoregions.RData")
```

No covariates are used in the ratio estimator. If we wish to exploit covariates, the mean of a domain can best be estimated by the ratio of the regression estimate of the domain total (Chapter \@ref(Modelassisted)) and the estimated size of the domain:

\begin{equation}
\hat{\bar{z}}_{\text{ratio},d}= \frac{\hat{t}_{\text{regr},d}(z)}{\widehat{N}_d}\;.
\end{equation}

## Model-assisted estimators for small domains {#SmallDomainsModelAssisted}

When the domains are not well represented in the sample, the direct estimators from the previous section lead to large standard errors. In this situation we may try to increase the precision by also using observations from outside the domain. If we have covariates related to the study variable, we may exploit this ancillary information by fitting a regression model relating the study variable to the covariates, and using the fitted model to predict the study variable for all population units (nodes of discretisation grid), see Chapter \@ref(Modelassisted)\index{Model-assisted approach}. However, for small domains\index{Small domain} we may have too few sampled units in that domain to fit a separate regression model. The alternative then is to use the entire sample to estimate the regression coefficients and to use this global regression model to estimate the means of the domains. This introduces a systematic error, a design-bias, in the estimator. However, this extra error is potentially outweighed by the reduction of the random error due to the use of the globally estimated regression coefficients. If one or more units are selected from a domain, the observations of the study variable on these units can be used to correct for the bias. This leads to the regression estimator for small domains\index{Regression estimator!for small domains}. In the absence of such data, the mean of the domain can still be estimated by the so-called synthetic estimator\index{Synthetic estimator}.

There are quite a few packages for model-assisted estimation of means of small areas, the **maSAE** package [@maSAE], the **JoSAE** package [@JoSAE], the **rsae** package [@rsae], and the **forestinventory** package [@Hill2021]. I use package **forestinventory** for model-assisted estimation, and package **JoSAE** for model-based prediction of the means of small areas.

### Regression estimator {#RegressionestimatorSmallDomain}

In the regression estimator the potential bias due to the globally estimated regression coefficients, can be eliminated by adding the $\pi$ estimator of the mean of the regression residuals to the mean of the predictions in the domain(compare with Equation \@ref(eq:GREG)) (@Mandallaz2007, @Mandallaz2013):

\begin{equation}
\hat{\bar{z}}_{\text{regr},d} = \frac{1}{N_d} \sum_{k=1}^{N_d} \mathbf{x}^\mathrm{T}_{dk} \hat{\mathbf{b}} + \frac{1}{N_d} \sum_{k \in \mathcal{S}_d} \frac{\epsilon_{dk}}{\pi_{dk}} = \bar{\mathbf{x}}_d^\mathrm{T} \hat{\mathbf{b}} + \frac{1}{N_d} \sum_{k \in \mathcal{S}_d} \frac{\epsilon_{dk}}{\pi_{dk}} \;,
(\#eq:regressionestimatorsmalldomain)
\end{equation}

with $\mathbf{x}_{dk}$ the vector with covariate values for unit $k$ in domain $d$, $\hat{\mathbf{b}}$ the vector with globally estimated regression coefficients, $\epsilon_{dk}$ the residual for unit $k$ in domain $d$, $\pi_{dk}$ the inclusion probability of that unit, and $\bar{\mathbf{x}}_d$ the mean of the covariates in domain $d$. Alternatively the mean of the residuals in a domain is estimated by the ratio estimator:

\begin{equation}
\hat{\bar{z}}_{\text{regr},d} =  \bar{\mathbf{x}}_d^\mathrm{T} \hat{\mathbf{b}} + \frac{1}{\widehat{N}_d} \sum_{k \in \mathcal{S}_d} \frac{\epsilon_{dk}}{\pi_{dk}} \;,
(\#eq:regressionestimatorsmalldomainratio)
\end{equation}

with $\widehat{N}_d$ the estimated size of domain $d$, see Equation \@ref(eq:generalratiodomain). The regression coefficients can be estimated by Equation \@ref(eq:EstimatorMultipleRegressionCoefficients). With simple random sampling the second term in this estimator is equal to the sample mean of the residuals, so that the estimator reduces to 

\begin{equation}
\hat{\bar{z}}_{\text{regr},d}=\bar{\mathbf{x}}_d^\mathrm{T} \hat{\mathbf{b}} + \bar{\epsilon}_{\mathcal{S}_d}\;,
(\#eq:regressionestimatorsmalldomainSI)
\end{equation}

with $\bar{\epsilon}_{\mathcal{S}_d}$ the sample mean of the residuals in domain $d$.

A regression estimate can only be computed if we have at least one observation of the study variable in the domain $d$. The variance of the regression estimator of the mean for a small domain can be estimated by [@Hill2021]

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\text{regr},d}\right) = \bar{\mathbf{x}}_d^\mathrm{T} \widehat{\mathbf{C}}(\hat{\mathbf{b}}) \bar{\mathbf{x}}_d + \widehat{V}\!\left(\hat{\bar{e}}_d \right)\;,
(\#eq:Varregressionestimatorsmalldomain)
\end{equation}

with $\widehat{\mathbf{C}}(\hat{\mathbf{b}})$ the matrix with estimated sampling variances and sampling covariances of the regression coefficients. The first variance component is the contribution due to uncertainty about the regression coefficients, the second component accounts for the uncertainty about the mean of the residuals in the domain. For simple random sampling the sampling variance of the $\pi$ estimator of the mean of the residuals in a domain can be estimated by the sample variance of the residuals in that domain divided by the sample size $n_d$. This variance estimator is presented in @Hill2021. If the domain is not used as a stratum, and the domain mean of the residuals is estimated by the ratio estimator, the second variance component can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{e}}_{\text{ratio},d}\right) = \frac{1}{\hat{a}_{d}^{2}}\cdot\frac{1}{n\,(n-1)}\sum_{k \in \mathcal{S}_d}(\epsilon_{dk}-\bar{\epsilon}_{\mathcal{S}_d})^{2} \;,
(\#eq:Varratioestimatorofmeanresidual)
\end{equation}

where $\hat{a}_{d}$ is the estimated relative size of domain $d$:

\begin{equation}
\hat{a}_{d}=\frac{n_{d}}{n} \;.
\end{equation}

With simple random sampling the sampling variances and covariances of the estimated regression coefficients can be estimated by (see Equation 2 in @Hill2021)

\begin{equation}
\widehat{\mathbf{C}}(\hat{\mathbf{b}}) = \frac{1}{n} \left( \sum_{k \in \mathcal{S}} \mathbf{x}_k \mathbf{x}^\mathrm{T}_k \right) ^{-1} \left( \frac{1}{n^2} \sum_{k \in \mathcal{S}} \epsilon_k^2  \mathbf{x}_k \mathbf{x}^\mathrm{T}_k \right) \frac{1}{n}\left(\sum_{k \in \mathcal{S}}^n \mathbf{x}_k \mathbf{x}^\mathrm{T}_k \right)^{-1} \;.
(\#eq:samplingVarregressioncoefficients)
\end{equation}

Note that these sampling variances and covariances are not equal to the model variances and covariances of the estimated regression coefficients as obtained with multiple linear regression, using functions `lm` and `vcov`, see Chapter \@ref(Approaches).

Function `twophase` of package **forestinventory** [@Hill2021] can be used to compute the regression estimator for small domains and its standard error. The name 'twophase' is somewhat confusing. It suggests that we have a large sample which is subsampled in a second phase, as described in Chapter \@ref(Twophase). This is not the case here. However, @Hill2021 considers infinite populations, and they treat the grid that discretises this infinite population as the first phase sample. The sampling error introduced by this discretisation grid can then be accounted for. I ignore this sampling error, it will be very small anyway, because the number of grid cells is very large. This can be done by assigning the domain means of the covariates to argument `exhaustive` of function `twophase`.  Function `twophase` assumes simple random sampling (unless optional argument `cluster` is used). Note that for the unobserved population units (not selected units) the AGB values are changed into non-availables. In package `survey` also a function `twophase` is defined, for that reason the  name of the package is made explicit by `forestinventory::twophase`. With arguments `psmall=TRUE` and element `unbiased=TRUE` in the list `small_area` the regression estimate is computed.

```{r, echo=FALSE}
load(file="data/Amazonia_1km.RData")
mz_pop <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=mean)
```

```{r}
library(forestinventory)
n <- 200
set.seed(314)
units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
gridAmazonia$ind <- rep(0,nrow(gridAmazonia))
gridAmazonia$ind[units] <- 1
gridAmazonia$AGB[gridAmazonia$ind == 0] <- NA 
mx_eco_pop <- tapply(
  gridAmazonia$lnSWIR2, INDEX=gridAmazonia$Ecoregion, FUN=mean)
mX_eco_pop <- data.frame(
  Intercept=rep(1,length(mx_eco_pop)), lnSWIR2=mx_eco_pop)
ecos_in_sam <- unique(mysample$Ecoregion)
res <- forestinventory::twophase(
  AGB~lnSWIR2,
  data=gridAmazonia,
  phase_id=list(
    phase.col="ind",
    terrgrid.id=1),
  small_area=list(
    sa.col="Ecoregion",
    areas=sort(ecos_in_sam),
    unbiased=TRUE),
  psmall=TRUE,
  exhaustive=mX_eco_pop)
regr <- res$estimation
```

```{r TableRegressionEstimatesEcoregions, echo=FALSE}
df <- regr[c("area","estimate","ext_variance","g_variance","n2G")]
df[,c(2,3,4)] <- round(df[,c(2,3,4)],1)

knitr::kable(
  df, caption = 'Regression estimates of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia, using lnSWIR2 as a predictor. For explanation of variances of regression estimator, see text. In the final column the number of sampling units per ecoregion is listed.',
  booktabs = TRUE, col.names=c("Ecoregion","AGB","ext_var","g_var","n2G")
) %>%
  kable_classic()
```

The alternative is to save the selected units (the sample) in a `data.frame`, assigned to argument `data`. The results are identical because the true means of the covariate $x$ assigned to argument `exhaustive` contains all required information at the population level.

For two ecoregions no estimate of the mean AGB is obtained (Table \@ref(tab:TableRegressionEstimatesEcoregions)). No units are selected from these domains. The variance of the estimated domain mean is in the column `g_variance`. The column `ext_variance` ignores the first variance component  of Equation \@ref(eq:Varregressionestimatorsmalldomain). Note that for the ecoregions with a sample size of one unit (the sample sizes per domain are in column `n2G`) no estimate of the variance is available, because the variance of the estimated mean of the residuals cannot be estimated from one unit.

Figure \@ref(fig:RatioversusRegrEcoregions) shows the regression estimates plotted against the ratio estimates. The variation of the regression estimates is smaller than those of the ratio estimates. The intercept of the line, fitted with ordinary least squares (OLS), is larger than 0, and the slope is smaller than 1. Using the regression model predictions in the estimation of the means leads to some smoothing.

```{r RatioversusRegrEcoregions, echo=FALSE, out.width="70%", fig.cap="Scatterplot of ratio estimate and regression estimate of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia. In the regression estimate lnSWIR2 is used as a predictor. The line is fitted by ordinary least squares."}
mysample$N <- nrow(gridAmazonia)
design_si <- svydesign(id=~1, data=mysample, fpc=~N)
res <- svyby(~AGB, by=~Ecoregion, design=design_si, FUN=svymean)

names(regr)[1] <- "Ecoregion"

df <- merge(res,regr, by="Ecoregion")
slr <- lm(estimate~AGB, data=df)
ab <- coef(slr)
ggplot(data=df) +
        geom_point(mapping=aes(x=AGB, y=estimate), size=2) +
        geom_abline(intercept=ab[1], slope=ab[2])+
        scale_x_continuous(name="Ratio estimate", limits=c(50,300)) +
        scale_y_continuous(name="Regression estimate", limits=c(50,300))+
        coord_fixed()
```

I quantified the gain in the precision due to the use of the regression model by the variance of the ratio estimator divided by the variance of the regression estimator (Table \@ref(tab:TableGainRegressionestimator)). For ratios larger than 1 there is a gain in precision. Both variances are estimated from the 1,000 repeated ratio and regression estimates. For all but two small ecoregions there is a gain. For quite a few ecoregions the gain is quite large. These are the ecoregions where the globally fitted regression model explains a large part of the spatial variation of AGB.

```{r TableGainRegressionestimator, echo=FALSE}
load(file="results/MeanAGB_ecoregions.RData")
ecoregions <- sort(unique(gridAmazonia$Ecoregion))
v_ratio <- apply(mz_eco_ratio, MARGIN=1, FUN=var, na.rm=TRUE)
v_regr <- apply(mz_eco_regr, MARGIN=1, FUN=var, na.rm=TRUE)
gain <- round(v_ratio/v_regr,2)
df <- data.frame(ecoregions, gain=gain)
rownames(df) <- NULL
knitr::kable(
  df, caption = 'Gain in precision of estimated mean of AGB of ecoregions in Eastern Amazonia, as quantified by the estimated variance of the ratio estimator (no covariate used) divided by the estimated variance of the regression estimator (using lnSWIR2 as a predictor).',
  booktabs = TRUE,col.names=c("Ecoregions","Gain")
) %>%
  kable_classic()
```


### Synthetic estimator

For small domains from which no units are selected, the mean can still be estimated by the synthetic estimator\index{Synthetic estimator}, also referred to as the synthetic regression estimator:

\begin{equation}
\hat{\bar{z}}_{\text{syn},d}=\bar{\mathbf{x}}_d^\mathrm{T} \hat{\mathbf{b}}\;.
(\#eq:syntheticestimatorsmalldomain)
\end{equation}

So the second term in Equation \@ref(eq:regressionestimatorsmalldomain) is dropped. The variance can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\text{syn},d}\right) = \bar{\mathbf{x}}_d^\mathrm{T} \widehat{\mathbf{C}}(\hat{\mathbf{b}}) \bar{\mathbf{x}}_d \;.
(\#eq:Varsyntheticestimatorsmalldomain)
\end{equation}

This is equal to the first variance component of Equation \@ref(eq:Varregressionestimatorsmalldomain). 
The synthetic estimate can be computed with function `twophase`, with arguments `psmall=FALSE` and element `unbiased=FALSE` in the list `small_area` .

```{r}
res <- forestinventory::twophase(
  AGB~lnSWIR2,
  data=gridAmazonia,
  phase_id=list(
    phase.col="ind",
    terrgrid.id=1),
  small_area=list(
    sa.col="Ecoregion",
    areas=ecoregions,
    unbiased=FALSE),
  psmall=FALSE,
  exhaustive=mX_eco_pop)
synt <- res$estimation
```

```{r TableSyntheticEstimates, echo=FALSE}
df <- synt[c("area","estimate","g_variance","n2G")]
df[,c(2,3)] <- round(df[,c(2,3)],1)

knitr::kable(
  df, caption = 'Synthetic estimates of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia, using lnSWIR2 as a predictor. In the final column the number of sampling units per ecoregion is listed.',
  booktabs = TRUE, col.names=c("Ecoregion","AGB","g_var","n2G")
) %>%
  kable_classic()
```


```{r, echo=FALSE}
names(synt)[1] <- "Ecoregion"
df <- merge(synt, regr, by="Ecoregion")
d_estimates <- df$estimate.x-df$estimate.y
md <- mean(d_estimates)
d_vars <- df$g_variance.x-df$g_variance.y
```

For all ecoregions, also the unsampled ones, a synthetic estimate of the mean AGB is obtained (Table \@ref(tab:TableSyntheticEstimates)). For the sampled ecoregions the synthetic estimate differs from the regression estimate. This difference can be quite large for ecoregions with a small sample size. Averaged over all sampled ecoregions the difference, computed as synthetic estimate minus regression estimate,  equals `r round(md,1)`. The variance of the regression estimator is always much larger than the variance of the synthetic estimator. The difference is the variance of the estimated domain mean of the residuals. However, recall that the regression estimator is design-unbiased, whereas the synthetic estimator is not. A more fair comparison is on the basis of the root mean squared error (Table \@ref(tab:tableRMSEs)).

```{r, echo=FALSE}
load(file="results/MeanAGB_ecoregions.RData")
v_mz_eco_regr <- apply(mz_eco_regr, MARGIN=1, FUN=var, na.rm=TRUE)
v_mz_eco_synt <- apply(mz_eco_synt, MARGIN=1, FUN=var, na.rm=TRUE)
m_mz_eco_synt <- apply(mz_eco_synt, MARGIN=1, FUN=mean, na.rm=TRUE)
bias_synt <- m_mz_eco_synt-mz_pop
RMSE_synt <- sqrt(v_mz_eco_synt+bias_synt^2)
RMSE_regr <- sqrt(v_mz_eco_regr)
dRMSE <- RMSE_regr-RMSE_synt
```

```{r tableRMSEs, echo=FALSE}
ecoregions_short <- ecoregions
ecoregions_short[c(1,16)] <- c("Amazon-Orinoco Carib. mangroves","Xingu-Toc.-Arag. moist forests")
df <- data.frame(Ecoregion=ecoregions_short, se.reg=round(sqrt(v_mz_eco_regr),1), se.syn=round(sqrt(v_mz_eco_synt),1), bias.syn=round(bias_synt,1), RMSE.syn=round(RMSE_synt,1))
rownames(df) <- NULL
knitr::kable(
  df, caption = 'Standard error (se), bias, and root mean squared error (RMSE) of the regression estimator (reg) and synthetic estimator (syn). The regression estimator is design-unbiased, so the RMSE of the regression estimator is equal to its standard error.',
  booktabs = TRUE
) %>%
  kable_classic()
```


In the synthetic estimator and the regression estimator both quantitative covariates and categorical variables can be used. If one or more categorical variables are included in the estimator, the variable names in the data frame with the true means of the ancillary variables per domain, assigned to argument `exhaustive`,  must correspond with the column names of the design matrix that is generated with function `lm`, see Section \@ref(RegressionEstimatorSTSI).

## Model-based prediction {#SmallAreaModelBased}

The alternative for design-based and model-assisted estimation of the means or totals of small domains is model-based prediction. The model describes the spatial variation of the study variable. An example of such a model is a linear regression model. Such model is used in the model-assisted estimator of the previous sections. A more advanced model is a linear mixed model\index{Linear mixed model}. In a linear mixed model the mean of the study variable is modelled as a linear combination of covariates, similar to a linear regression model. The difference with a linear regression model is that also the variance of the residuals is modelled. 

### Random intercept model

A basic linear mixed model for model-based prediction of means of small domains is the random intercept model\index{Random intercept model}:

\begin{eqnarray}
Z_{dk} &=& \mathbf{x}_{dk}^{\text{T}} \boldsymbol{\beta} + v_d + \epsilon_{dk} \notag \\
v_d &\sim& \mathcal{N}(0,\sigma^2_v) \\
\epsilon_{dk} &\sim& \mathcal{N}(0,\sigma^2_{\epsilon}) \notag \;.
(\#eq:RandomInterceptModel)
\end{eqnarray}

Two random variables are now involved, both with a normal distribution with mean zero: $v_d$ a random intercept at the domain level with variance $\sigma^2_v$, and the residuals $\epsilon_{dk}$ at the unit level with variance $\sigma^2_{\epsilon}$. The variance $\sigma^2_v$ can be interpreted as a measure of the heterogeneity among the domains after accounting for the fixed effect [@Breidenbach2012]. With this model the mean of a domain can be predicted by

\begin{equation}
\hat{\bar{z}}_{d,\text{mb}} = \bar{\mathbf{x}}_d^\mathrm{T} \hat{\mathbf{b}} + \hat{v}_d \;,
(\#eq:mbpredictordomainmeanrandomintercept)
\end{equation}

with $\hat{\boldsymbol{\beta}}$ the best linear unbiased estimates (BLUE) of the regression coefficients, and $\hat{v}_d$ the best linear unbiased prediction (BLUP) of the intercept for domain $d$, $v_d$. The model-based predictor can also be written as

\begin{equation}
\hat{\bar{z}}_{d,\text{mb}} = \bar{\mathbf{x}}_d^\mathrm{T} \hat{\mathbf{b}} + \lambda_d \left( \frac{1}{n_d }\sum_{k \in \mathcal{S}_d} \epsilon_{dk} \right) \;,
(\#eq:mbpredictordomainmeanrandomintercept2)
\end{equation}

with $\lambda_d$ a weight for the second term that corrects for the bias of the synthetic estimator. This weight is computed by 

\begin{equation}
\lambda_d = \frac{\hat{\sigma}^2_v}{\hat{\sigma}^2_v + \hat{\sigma}^2_{\epsilon}/n_d}\;.
(\#eq:weightrandomintercept)
\end{equation}

This equation shows that the larger the estimated residual variance $\hat{\sigma}^2_{\epsilon}$, the smaller the weight for the bias correction factor, and the larger the sample size $n_d$, the larger the weight. Comparing Equations \@ref(eq:mbpredictordomainmeanrandomintercept) and \@ref(eq:mbpredictordomainmeanrandomintercept) shows that the random intercept of a domain is predicted by the sample mean of the residuals of that domain, multiplied by a weight factor computed by Equation \@ref(eq:weightrandomintercept).  

The means of the small domains can be computed with function `eblup.mse.f.wrap` of package **JoSAE** [@JoSAE]. It requires as input a linear mixed model generated with function `lme` of package **nlme** [@nlme]. The simple random sample of size 200 is used to fit the linear mixed model, with lnSWIR2 as a fixed effect, i.e. the effect of SWIR2 on the mean of AGB. The random effect is added by assigning another formula to the argument `random`. The formula, `~1|Ecoregions` means that the intercept is treated as a random variable, and that it varies among the Ecoregions. This linear mixed model is referred to as a random intercept model: the intercepts are allowed to differ among the small domains, whereas the effects of the covariates, lnSWIR2 in our case, is equal for all domains.

```{r, echo=FALSE}
load("data/Amazonia_1km.RData")
set.seed(314)
gridAmazonia$x1 <- gridAmazonia$x1/1000
gridAmazonia$x2 <- gridAmazonia$x2/1000
units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
mysample <- gridAmazonia[units,c("x1","x2","AGB","lnSWIR2","Ecoregion")]
```

```{r}
library(nlme)
library(JoSAE)
lmm_AGB <- lme(fixed=AGB~lnSWIR2, data=mysample, random=~1|Ecoregion)
```

The fixed effects\index{Fixed effect} can be extracted with function `fixed.effects`.

```{r}
fixed_lmm <- fixed.effects(lmm_AGB)
```

The fixed effects differ somewhat from the fixed effects in the simple linear regression model:
 
```{r, echo=FALSE}
slm <- lm(AGB~lnSWIR2, data=mysample)
ab.lm <- coef(slm)
(df <- data.frame(fixed.lm=ab.lm, fixed.lmm=fixed_lmm))
```

The random effect\index{Random effect} can be extracted with function `random.effect`. 

```{r}
random.effects(lmm_AGB)
```

The random intercepts are added to the fixed intercept; the coefficient of lnSWIR2 is the same for all ecoregions: 

```{r}
coef(lmm_AGB)
```

The fitted model can now be used to predict the means of the ecoregions as follows. As a first step a data frame must be defined with the sizes of the domains and the population means of the covariate lnSWIR2 per domain. This data frame is assigned to argument `domain.data` of function `eblup.mse.f.wrap`. This function computes the model-based prediction as well as the regression estimator (Equation \@ref(eq:regressionestimatorsmalldomain)) and the synthetic estimator (Equation \@ref(eq:syntheticestimatorsmalldomain)) and their variances. The model-based predictor is the variable `EBLUP` in the output data frame. For the model-based predictor two standard errors are computed, see @Breidenbach2012 for details.

```{r}
N_eco <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion,
                FUN=length)
df_eco <- data.frame(Ecoregion=ecoregions, N=N_eco, 
                        lnSWIR2=mx_eco_pop)
res <- eblup.mse.f.wrap(
  domain.data=df_eco, lme.obj=lmm_AGB)
df <- data.frame(
  Ecoregion=res$domain.ID, mb=res$EBLUP,
  se.1=res$EBLUP.se.1, se.2=res$EBLUP.se.2)
```

```{r TableRandomInterceptModelEstimates, echo=FALSE}
df[,c(2,3,4)] <- round(df[,c(2,3,4)],1)

knitr::kable(
  df, caption = 'Model-based predictions of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia, obtained with random intercept model and lnSWIR2 as a predictor.',
  booktabs = TRUE,col.names=c("Ecoregion","AGB","se.1","se.2")
) %>%
  kable_classic()
```

Note that with this model no predictions are obtained for the unsampled ecoregions. For the unsampled ecoregions no prediction is obtained of the random intercept $v_d$, see Equation \@ref(eq:mbpredictordomainmeanrandomintercept2).

### Geostatistical model 

In the random intercept model (Equation \@ref(eq:RandomInterceptModel)) it is assumed that the residuals $\epsilon_{ij}$ are independent. In a geostatistical model\index{Geostatistical model} this assumption is relaxed, and the spatial correlation of the residuals is modelled. For details about geostatistical modelling, I refer to Chapter \@ref(Introkriging).

A simple random sample of size 200 is used to compute the sample semivariogram\index{Sample semivariogram} of the residuals of the simple linear regression model, using lnSWIR2 as a single predictor. Figure \@ref(fig:ResidualVariogramAGB) shows that the larger the distance, the larger half the expected squared difference. This shows that the residuals of units with a separation distance smaller than about 300 km are correlated. A spherical model with nugget is fitted to model the spatial correlation of the residuals $e$.

The residual semivariogram\index{Residual semivariogram} is computed with function `variogram` of package **gstat** [@peb04]. A spherical model is fitted with function `fit.variogram`. The coordinates are shifted to a random point within a 5 km $\times$ 5 km grid cell. This is only done to avoid an error message when the geostatistical model is used to predict AGB at the nodes of the grid hereafter. 

```{r ResidualVariogramAGB, echo=FALSE, fig.asp=0.7, fig.cap="Semivariogram of residuals of simple linear regression model for AGB, using lnSWIR2 as a predictor."}
library(gstat)
mysample$x1 <- jitter(mysample$x1, amount=2.5)
mysample$x2 <- jitter(mysample$x2, amount=2.5)
coordinates(mysample) <- ~x1+x2
vg_resi <- variogram(AGB~lnSWIR2, data=mysample)
vgm_resi <- fit.variogram(vg_resi, model=vgm(psill=1000,  model="Sph", range=300, nugget=1500))
plot(vg_resi,vgm_resi, plot.numbers=TRUE)
```

The semivariogram parameters and the regression coefficients can best be estimated by restricted maximum likelihood (REML), see Section \@ref(REML). This estimation procedure is also used in function `lme` to fit the random intercept model. Here I use function `likfit` of package **geoR** [@geoR]. First a geoR object must be generated with function `as.geodata`.

```{r}
library(geoR)
mysample <- as(mysample,"data.frame")
dGeoR <- as.geodata(
  mysample, header=TRUE,
  coords.col=1:2, data.col=3, covar.col=4)
```

The model parameters can then be estimated with function `likfit`.

```{r}
vgm_REML <- likfit(
  geodata=dGeoR,
  trend=~lnSWIR2,
  cov.model="spherical",
  ini.cov.pars=c(1000,300), nugget=1500,
  lik.method="REML", messages=FALSE)
```

The estimated semivariogram parameters are `r round(vgm_REML$nugget,0)` for the nugget (intercept of the semivariogram), `r round(vgm_REML$sigmasq,0)` for the partial sill (maximum semivariance minus the nugget), and `r round(vgm_REML$phi,1)` for the range (distance at which the semivariance reaches its maximum). The estimated regression coefficients and parameters of the semivariogram can then be used to predict AGB for all units in the population.

```{r, eval=FALSE}
coordinates(mysample) <- ~x1+x2
vgm_REML_gstat <- vgm(
  nugget=vgm_REML$nugget, psill=vgm_REML$sigmasq,
  range=vgm_REML$phi, model="Sph")
coordinates(mysample) <- ~x1+x2
coordinates(gridAmazonia) <- ~x1+x2
predictions  <- krige(
  formula=AGB~lnSWIR2,
  locations=mysample, 
  newdata=gridAmazonia, 
  model=vgm_REML_gstat,
  debug.level=0) %>%
as(.,"data.frame")
```

```{r, eval=FALSE, echo=FALSE}
save(predictions,file="results/ModelBasedPredictionsAGB_Amazonia.RData")
```

The first six rows of `predictions` are shown below.

```{r, echo=FALSE}
load(file="results/ModelBasedPredictionsAGB_Amazonia.RData")
head(predictions)
```

Besides a prediction (column `var1.pred`), for every population unit the variance of the prediction error is computed (`var1.var`). The unit-wise predictions can be averaged across all units of an ecoregion to obtain a model-based prediction of the mean of that ecoregion.

```{r}
AGBpred_unit <- predictions$var1.pred
gridAmazonia <- as(gridAmazonia,"data.frame")
mz_eco_mb <- tapply(AGBpred_unit, INDEX=gridAmazonia$Ecoregion,
                    FUN=mean) %>% round(.,1)
```

A difficulty is the computation of the standard error of these model-based predictions of the ecoregion mean. We cannot simply sum the unit-wise variances and divide the sum by the squared number of units because the prediction errors of units with a mutual distance smaller than about 450 km (the estimated range of the semivariogram) are correlated. A straightforward approach to obtain the standard error of the predicted mean is geostatistical simulation\index{Geostatistical simulation}. A large number of maps is simulated, conditional on the selected sample. For an infinite number of maps, the "average map", i.e. the map obtained by averaging for each unit all simulated values of that unit, is equal to the map with predicted AGB. For each simulated map, the average of the simulated values across all units of an ecoregion is computed. This results in as many averages as we have simulated maps. The variance of the averages of an ecoregion is an estimate of the variance of the predicted mean of that ecoregion. To reduce computing time the 5 km $\times$ 5 km subgrid is used in geostatistical simulation  

```{r, eval=FALSE}
load(file="data/Amazonia_5km.RData")
nsim <- 1000
coordinates(gridAmazonia) <- ~x1+x2
simulations  <- krige(
  formula=AGB~lnSWIR2,
  locations=mysample,
  newdata=gridAmazonia, 
  model=vgm_REML_gstat,
  nmax=100, nsim=nsim,
  debug.level=0) %>%
as(.,"data.frame")
gridAmazonia <- as(gridAmazonia,"data.frame")
AGBsim_eco <- matrix(nrow=length(ecoregions), ncol=nsim)
for (i in 1:nsim) {
  AGBsim_eco[,i] <- tapply(
    simulations[,i+2], INDEX=gridAmazonia$Ecoregion, FUN=mean)
}
```

```{r, eval=FALSE, echo=FALSE}
save(AGBsim_eco,file="results/AGBsimulated_ecoregions.RData")
```

```{r, echo=FALSE}
load(file="results/AGBsimulated_ecoregions.RData")
se_mz_eco_mb <- round(sqrt(apply(AGBsim_eco,MARGIN=1,FUN=var)),1)
```

```{r TableGeostatisticqalModelEstimates, echo=FALSE}
df <- data.frame(Ecoregion=ecoregions, mz_eco_mb, se_mz_eco_mb)
df[,c(2,3)] <- round(df[,c(2,3)],1)
rownames(df) <- NULL
knitr::kable(
  df, caption = 'Model-based predictions of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia, obtained with geostatistical model and lnSWIR2 as a predictor for the mean. se: standard error of predicted mean.',
  booktabs = TRUE, col.names=c("Ecoregion","AGB","se")
) %>%
  kable_classic()
```

Similar to the synthetic estimator, for all ecoregions an estimate of the mean AGB is obtained, also for the unsampled ecoregions (Table \@ref(tab:TableGeostatisticqalModelEstimates)). The model-based prediction is strongly correlated with the synthetic estimate (Figure \@ref(fig:MBvsSynt)).

```{r MBvsSynt, echo=FALSE, out.width="70%", fig.cap="Scatterplot of model-based prediction and synthetic estimate of the mean AGB of ecoregions in Eastern Amazonia. The solid line is the 1:1 line."}
df <- data.frame(ecoregions, mb=mz_eco_mb, se.mb=se_mz_eco_mb, synt=synt$estimate, se.synt=sqrt(synt$g_variance)) 
ggplot(data=df) +
        geom_point(mapping=aes(x=synt, y=mb), size=2) +
        geom_abline(intercept=0, slope=1)+
        scale_x_continuous(name="Synthetic estimate", limits=c(50,300)) +
        scale_y_continuous(name="Model-based prediction", limits=c(50,300))+
        coord_fixed()
```

The most striking difference is the standard error. The standard errors of the synthetic estimator range from 3.2 to 4.3, whereas the standard errors of the geostatistical predictions range from 6.2 to 28.1. However, these two standard errors are fundamentally different, and should not be compared. The standard error of the synthetic estimator is a *sampling* standard error, i.e. it quantifies the variation of the estimated mean of an ecoregion over repeated random sampling with the sampling design, in this case simple random sampling of 200 units. The model-based standard error is not a sampling standard error but a model standard error, which expresses our uncertainty about the means of the domains due to our imperfect knowledge of the spatial variation of AGB. Given the observations of AGB at the selected sample, the map with the covariate lnSWIR2, and the estimated semivariogram model parameters, we are uncertain about the exact value of AGB at unsampled units. No other samples are considered than the one actually selected. For the fundamental difference between the design-based, model-assisted, and model-based estimates of means, I refer to Section \@ref(DBvsMB) and Chapter \@ref(Approaches).

It makes more sense to compare the two model-based predictions, the random intercept model predictions and the geostatistical predictions, and their standard errors. Figure \@ref(fig:MBvsMB) shows that the two model-based predictions are very similar. 

```{r MBvsMB, echo=FALSE,  out.width="70%", fig.cap="Scatterplot of model-based predictions of the mean AGB of ecoregions in Eastern Amazonia, obtained with the random intercept model and the geostatistical model. The solid lines is the 1:1 line."}
res <- eblup.mse.f.wrap(domain.data=df_eco, lme.obj=lmm_AGB)
TF <- (ecoregions %in% ecos_in_sam)
n_eco <- tapply(mysample$AGB, INDEX=mysample$Ecoregion, FUN=length)
df <- data.frame(n_eco, mb.geo=mz_eco_mb[TF], semb.geo=se_mz_eco_mb[TF], mb.rint=res$EBLUP, semb.rint=res$EBLUP.se.1)
ggplot(data=df) +
        geom_point(mapping=aes(x=mb.rint, y=mb.geo), size=2) +
        geom_abline(intercept=0, slope=1)+
        scale_x_continuous(name="Random intercept model prediction ", limits=c(50,300)) +
        scale_y_continuous(name="Geostatistical prediction", limits=c(50,300))+
        coord_fixed()
```

For four ecoregions the standard errors of the geostatistical model predictions are much smaller than those of the random intercept model predictions (Figure \@ref(fig:MBvsMBse)). These are ecoregions with small sample sizes.

```{r MBvsMBse, echo=FALSE,  out.width="70%", fig.cap="Scatterplot of standard error of model-based predictions of the mean AGB of ecoregions in Eastern Amazonia, obtained with the random intercept model and the geostatistical model. The numbers refer to the number of sampling units in an ecoregion. The solid line is the 1:1 line."}
ggplot(data=df) +
        geom_point(mapping=aes(x=semb.rint, y=semb.geo), size=2) +
        geom_text(mapping=aes(x=semb.rint, y=semb.geo, label=n_eco), hjust=1, vjust=1)+
        geom_abline(intercept=0, slope=1)+
        scale_x_continuous(name="Standard error random intercept model prediction ", limits=c(5,40)) +
        scale_y_continuous(name="Standard error geostatistical prediction", limits=c(5,40))+
        coord_fixed()

```

Note that if a different semivariogram model were used, both the predicted means per ecoregion and the standard errors would be different. Especially the variance is sensitive to the semivariogram. For that reason the model-based predictions are also referred to as model-dependent predictions\index{Model-dependent predictor}.

## Supplemental probability sampling of small domains

The sample size in small domains of interest can be so small that no reliable statistical estimate of the mean or total of these domains can be obtained. In that case we may decide to collect a supplemental sample\index{Supplemental sample} from these domains. It is convenient to use these domains as strata in supplemental probability sampling, so that we can control the sample sizes in the strata. If we can safely assume that the study variable at the units of the first sample are not changed, there is no need to revisit these units, otherwise we must revisit them to observe the current values.

There are two approaches for using the two samples to estimate the population mean or total of a small domain [@Grafstrom2019]. In the first approach the two samples are combined, and then the merged sample is used to estimate the population mean or total. In the second approach not the samples are combined, but the two estimates from the separate samples. In this section only the first approach is illustrated with a simple situation in which the two samples are easily combined. I refer to @Grafstrom2019 for a more general approach of how multiple probability samples can be combined.

Suppose that the original sample is a simple random sample from the entire study area. A supplemental sample is selected from small domains, i.e. domains that have few selected units only. For a given small domain, the first sample is supplemented by selecting a simple random sample from the units not yet selected in the first sample. The size of the supplemental sample of a domain depends on the number of units of that domain in the first sample. The first sample is supplemented so that the total sample size of that domain is fixed. In this case the combined sample of a domain is a simple random sample from that domain, so that the usual estimators for simple random sampling can be used to estimate the domain mean or total, and its standard error.

This sampling strategy is illustrated with Eastern Amazonia. A simple random sample without replacement of 400 units is selected.

```{r}
load("data/Amazonia_1km.RData")
gridAmazonia$Biome <- as.factor(gridAmazonia$Biome)
biomes <- c("Mangrove","Forest.dry","Grassland","Forest.moist")
levels(gridAmazonia$Biome) <- biomes
n1 <- 400
set.seed(123)
units_1 <- sample.int(nrow(gridAmazonia), size=n1, replace=FALSE)
mysample_1 <- gridAmazonia[units_1, c("AGB","Biome")]
print(n1_biome <- table(mysample_1$Biome))
```

The selected units are removed from the sampling frame. For each of the three small biomes, Mangrove, Forest.dry and Grassland, the size of the supplemental sample is computed so that the total sample size becomes 40. The supplemental sample is selected by stratified simple random sampling without replacement, using the small biomes as strata.

```{r}
units_notselected <- gridAmazonia[-units_1,]
Biomes_NFM <- 
  units_notselected[units_notselected$Biome!="Forest.moist",]
n_biome <- 40
n2_biome <- rep(n_biome,3) - n1_biome[-4]
ord <- unique(Biomes_NFM$Biome)
units_2 <- sampling::strata(
  Biomes_NFM, stratanames="Biome",
  size=n2_biome[ord], method="srswor")
mysample_2 <- getdata(Biomes_NFM, units_2)
mysample_2 <- mysample_2[c("AGB","Biome")]
```

The two samples are merged, and the means of the domains are estimated by the sample means.

```{r}
mysample <- rbind(mysample_1, mysample_2)
print(mz_biome <- tapply(
  mysample$AGB, INDEX=mysample$Biome, FUN=mean))
```

Finally, the standard error is estimated, accounting for sampling without replacement from a finite population (Equation \@ref(eq:EstVarMeanSI)).

```{r}
N_biome <- table(gridAmazonia$Biome)
fpc <- (1-n_biome/N_biome)
S2z_biome <- tapply(mysample$AGB, INDEX=mysample$Biome, FUN=var)
print(se_mz_biome <- sqrt(fpc*(S2z_biome/n_biome)))
```


```{r, echo=FALSE, eval=FALSE}
mz_biome <- v_mz_biome <- matrix(nrow=10000,ncol=4)
set.seed(314)
for (i in 1:10000) {
  units_1 <- sample.int(nrow(gridAmazonia), size=n1, replace=FALSE)
  mysample_1 <- gridAmazonia[units_1,c("AGB","Biome")]
  n1_biome <- table(mysample_1$Biome)

  units_notselected <- gridAmazonia[-units_1,]
  Biomes.NFM <- units_notselected[units_notselected$Biome!="Forest.moist",]
  n_biome <- 40
  n2_biome <- rep(n_biome,3) - n1_biome[-4]
  if (sum(n2_biome<1)>0) {next} else {
  ord <- unique(Biomes.NFM$Biome)
  units_2 <- sampling::strata(Biomes.NFM, stratanames="Biome", size=n2_biome[ord], method="srswor")
  mysample_2 <- getdata(Biomes.NFM, units_2)
  mysample_2 <- mysample_2[c("AGB","Biome")]

  mysample <- rbin_biome(mysample_1,mysample_2)
  mz_biome[i,] <- tapply(mysample$AGB, INDEX=mysample$Biome, FUN=mean)

  N_biome <- table(gridAmazonia$Biome)
  fpc <- (1-n_biome/N_biome)
  S2z_biome <- tapply(mysample$AGB, INDEX=mysample$Biome, FUN=var)
  v_mz_biome[i,] <- fpc*(S2z_biome/n_biome)
  }
}
save(mz_biome,v_mz_biome,file="results/SupplementalSampleEstimates_Amazonia.RData")
```

```{r, echo=FALSE}
load(file="results/SupplementalSampleEstimates_Amazonia.RData")
nas <- apply(mz_biome,MARGIN=2, FUN=mean, na.rm=TRUE)

Ep_mz_biome <- apply(mz_biome,MARGIN=2, FUN=mean,na.rm=TRUE)
Vp_mz_biome <- apply(mz_biome,MARGIN=2, FUN=var, na.rm=TRUE)
se_mz_biome <- sqrt(v_mz_biome)
Ep_se_mz_biome <- apply(se_mz_biome, MARGIN=2, FUN=mean, na.rm=TRUE)
mz_biome_pop <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Biome, FUN=mean)

alpha <- 0.05
margin <- qt(1-alpha/2,39,lower.tail=TRUE)*sqrt(v_mz_biome[,1:3])
lower <- mz_biome[,1:3]-margin
upper <- mz_biome[,1:3]+margin
Mz_biome_pop <- matrix(nrow=10000, ncol=3, data=mz_biome_pop[1:3], byrow=TRUE)
ind <- (Mz_biome_pop>lower &  Mz_biome_pop<upper)
coverage <- apply(ind, MARGIN=2, FUN=sum, na.rm=TRUE)
dum <- apply(ind, MARGIN=2, FUN=function(x) {sum(!is.na(x))})
coveragerate_95 <- coverage/dum

alpha <- 0.10
margin <- qt(1-alpha/2,39, lower.tail=TRUE)*sqrt(v_mz_biome[,1:3])
lower <- mz_biome[,1:3]-margin
upper <- mz_biome[,1:3]+margin
ind <- (Mz_biome_pop>lower &  Mz_biome_pop<upper)
coverage <- apply(ind,MARGIN=2,FUN=sum,na.rm=TRUE)
dum <- apply(ind, MARGIN=2,FUN=function(x) {sum(!is.na(x))})
coveragerate_90 <- coverage/dum

alpha <- 0.20
margin <- qt(1-alpha/2,39, lower.tail=TRUE)*sqrt(v_mz_biome[,1:3])
lower <- mz_biome[,1:3]-margin
upper <- mz_biome[,1:3]+margin
ind <- (Mz_biome_pop>lower &  Mz_biome_pop<upper)
coverage <- apply(ind, MARGIN=2, FUN=sum, na.rm=TRUE)
dum <- apply(ind, MARGIN=2,FUN=function(x) {sum(!is.na(x))})
coveragerate_80 <- coverage/dum

row_names <- c("Average of estimated means","True means","Standard deviation of estimated means","Average of estimated standard errors","Coverage rate 95%","Coverage rate 90%","Coverage rate 80%")
dom <- matrix(nrow=7,ncol=3, dimnames=list(row_names,NULL))
for (i in 1:3) {
  dom[,i] <- c(round(Ep_mz_biome[i],3), round(mz_biome_pop[i],3), round(sqrt(Vp_mz_biome[i]),3), round(Ep_se_mz_biome[i],3), round(coveragerate_95[i],3), round(coveragerate_90[i],3), round(coveragerate_80[i],3))
}
```

This sampling approach and estimation is repeated 10,000 times, i.e. 10,000 times a simple random sample of size 400 is selected from Eastern Amazonia, and the samples from the three small domains are supplemented so that the total sample sizes in these domains become 40. In two out of the 10,000 samples the size of the first sample in one of the domains exceeded 40 units. These two samples are discarded. Ideally, these samples are not discarded, but their sizes in the small domains are reduced to 40 units, which are then used to estimate the means of the domains.

```{r SmalldomainEstimates, echo=FALSE}
knitr::kable(
  dom, caption = 'Summary statistics of 10,000 estimated means of small domains (biomes) in Eastern Amazonia, estimated by combining a simple random sample of size 400 from Eastern Amazonia, and a supplemental sample from the domains. The total sample size per small domain is 40.',
  col.names = c("Mangrove","Dry forest","Grassland"),
  row.names = TRUE,
  booktabs = TRUE
) %>%
  kable_classic()
```

For all three small domains the average of the 10,000 estimated means is about equal to the true mean (Table \@ref(tab:SmalldomainEstimates)). Also the mean of the 10,000 estimated standard errors is very close to the standard deviation of the 10,000 estimated means. The coverage rates of 95%, 90% and 80% confidence intervals are about equal to the nominal coverage rates.

This simple approach is feasible because at the domain level the two merged samples are a simple random sample. This  approach is also applicable when at the first sample is a stratified simple random sample from the entire population and the supplemental sample is a stratified simple random sample from a small domain, using as strata the intersections of the strata used in the first phase and that domain.

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:14-SmallAreaEstimation.Rmd-->

# Repeated sample surveys for monitoring population parameters {#RepeatedSurveys}

The previous chapters are all about sampling to estimate population parameters *at a given time*. The survey is done in a relatively short period of time, so that we can safely assume that the study variable did not change during that period. This chapter is about repeating the sample survey two or more times, to estimate a temporal change in a population parameter\index{rpeated surveys for monitoring}. Sampling locations are selected by probability sampling, by any design type. Sampling times are not selected randomly, but purposively. For instance, to monitor the carbon stock in the soil of a country, we may decide to repeat the survey after five years, in the same season of the year as the first sampling round.

## Space-time designs

@gru06 present an overview of space-time designs\index{Space-time design}. Four of these designs are schematically shown in Figure \@ref(fig:SpaceTimeDesigns). With repeated sampling in two-dimensional space there are three dimensions: two spatial and one time dimension. In Figure  \@ref(fig:SpaceTimeDesigns) the sampling locations in 2D are plotted in one dimension, along the horizontal axis. A selected unit along this axis actually represents a sampling location in 2D. Twenty sampling locations are selected by simple random sampling.

In the static-synchronous design\index{Space-time design!static-synchronous design}, also referred to as a pure panel\index{Pure panel|see static synchronous design}, all sampling locations selected in the first survey are revisited in the subsequent surveys. On the contrary, in an independent synchronous design\index{Space-time design!independent-synchronous design}, in each survey a probability sample is selected independent from the samples selected in the previous surveys. The serially alternating design\index{Space-time design!serially alternating design} is a compromise between a static-synchronous and an independent synchronous design. The sample selected in the first survey is revisited in the third survey. The sample of the second survey is selected independently from the sample of the first survey, and these locations are revisited in the fourth survey. In this case the period of revisits is two, i.e. two sampling intervals between successive surveys, but this can also be increased. For instance with a period of three, three samples are selected independently from each other for the first three surveys . The sample of the first survey is revisited in the fourth survey, et cetera. Another compromise design is a supplemented panel\index{Space-time design!supplemented panel design}. In this space-time design only a subset of the sampling locations of the first survey is revisited in the subsequent surveys. The samples of the subsequent surveys are supplemented by samples that are selected independently from the samples in the previous surveys. In Figure \@ref(fig:SpaceTimeDesigns), one-half of the sampling locations (ten locations) are fixed, i.e. revisited in all surveys, but the proportion of fixed sampling locations can be smaller or larger and, if prior information on the variation in space and time is available, even optimised.

```{r SpaceTimeDesigns, echo=FALSE, fig.asp=0.8, fig.cap="Space-time designs for monitoring population parameters. Twenty sampling locations are selected by simple random sampling. SS: static-synchronous design; IS: independent synchronous design; SA: serially alternating design; SP: supplemeneted panel design."}

#pure panel
set.seed(314)
Space <- sample.int(n=1000, size=20, replace=FALSE)
mysampleSS <- data.frame(
    Space=rep(x=Space, times=4),
    Time=rep(x=c(1, 2, 3, 4), each=length(Space)),
    Panel=rep("a", 4*length(Space)) #unselect this line for figure withpanelsaslegend
)
mysampleSS$design<-"SS"

#independent synchronous
Space <- sample.int(n=1000, size=80, replace=FALSE)
mysampleIS <- data.frame(
    Space,
    Time=rep(x=c(1, 2, 3, 4), each=20)
)
mysampleIS$Panel <- rep(x=c("a","b","c","d"), each=20)
mysampleIS$design <- "IS"

#serially alternating
# set periodicity
p <- 2
# construct data.frame
mysample1 <- NULL
for (i in seq_len(p)) {
    mysample1 <- 
      rbind(mysample1,
            data.frame(Space=sample.int(n=1000, size=20, replace=FALSE), Time=i, Panel=letters[i]))
}
mysample2 <- mysample1
mysample2$Time <- mysample1$Time + p
mysample2$Panel <- mysample1$Panel
mysampleSA <- rbind(mysample1, mysample2)
mysampleSA$design <- "SA"

#supplemented panel
p <- 5 #number of panels
mysample1 <- NULL
for (i in seq_len(p)) {
    mysample1 <- rbind(
        mysample1,
        data.frame(
            Space=sample.int(n=1000, size=10, replace=FALSE),
            Time=(i==1)*1+(i>1)*(i-1),
            Panel=letters[i])
    )
}
mysample2<-NULL
mysample2$Space[1:10] <- mysample1$Space[1:10]
mysample2$Space[11:20] <- mysample1$Space[1:10]
mysample2$Space[21:30] <- mysample1$Space[1:10]

mysample2$Time <- rep(x=c(2, 3, 4), each=10)
mysample2$Panel <- rep(x="a", each=30)
mysampleSP <- rbind(mysample1, mysample2)
mysampleSP$design<-"SP"

#rotating panel
p <- 5 #number of panels
mysample1 <- NULL
for (i in seq_len(p)) {
    mysample1 <- rbind(
        mysample1,
        data.frame(
            Space=sample.int(n=1000, size=10, replace=FALSE),
            Time=(i==1)*1+(i>1)*(i-1),
            Panel=letters[i])
        )
}
mysample2<-NULL
mysample2$Space[1:10] <- mysample1$Space[11:20]
mysample2$Space[11:20] <- mysample1$Space[21:30]
mysample2$Space[21:30] <- mysample1$Space[31:40]

mysample2$Time <- rep(x=c(2, 3, 4), each=10)
mysample2$Panel <- rep(x=c("b", "c", "d"), each=10)
mysampleRP <- rbind(mysample1, mysample2)
mysampleRP$design<-"RP"

mysample<-rbind(mysampleSS,mysampleIS,mysampleSA,mysampleSP)
mysample$design<-factor(x=mysample$design,levels=c("SS","IS","SA","SP"),ordered=TRUE)

# create plot
ggplot(data=mysample) +
            geom_point(mapping=aes(x=Space, y=Time, shape=factor(Panel), colour=factor(Panel)), size=2) +
            scale_x_continuous(limits=c(0, 1000)) +
            scale_y_continuous(breaks=1:4) +
            scale_shape(name="panel", solid=FALSE) +
            scale_colour_viridis_d(name="panel")+
            facet_wrap(~design)
```
In Figure \@ref(fig:SpaceTimeDesigns) the shape and colour of the symbols represent a panel. A panel is a group of sampling locations that is observed in the same surveys. In the static-synchronous design there is only one panel. All locations are observed in all surveys, so all locations are in the same panel. In the independent synchronous design there are as many panels as there ar surveys. In the serially alternating design with a period of two the number of panels equals the number of surveys divided by two. In these three space-time designs (SS, IS and SA) all sampling locations of a given survey are in the same panel. This is not the case in the supplemented panel design. In each survey two panels are observed, one panel of fixed sampling locations (pure panel part of sample), and another panel of swarming sampling locations. The concept of panels is needed hereafter in estimating space-time population parameters.  

## Space-time population parameters

The data of repeated surveys can be used to estimate various parameters. In this chapter I show how to estimate the current population parameter, i.e. the population parameter in the latest survey, the change of the population parameter between two surveys, and the temporal trend of the population parameter. The current population parameter need not be defined here as only one survey (one sampling time) is involved in this parameter, so that the definitions in Section \@ref(PopulationParameters) are also relevant here. The change of the population parameter is defined as the population parameter at a given survey minus this parameter at an earlier survey. For instance, the change of an infinite population mean\index{Change of population mean (total)} is defined as

\begin{equation}
\bar{d}_{2,1}=\frac{1}{A}\left(\int_{\mathbf{s} \in \mathcal{U}} z(\mathbf{s},t_2) \;\mathrm{d}\mathbf{s}-\int_{\mathbf{s} \in \mathcal{U}} z(\mathbf{s},t_1) \;\mathrm{d}\mathbf{s}\right)\;,
(\#eq:ChangePopMean)
\end{equation}

With more than two surveys an interesting population parameter is the *average change* per time unit of the population parameter, referred to as the temporal trend\index{Temporal trend}. It is defined as a linear combination of the population parameters at the sampling times. For instance, the temporal trend of the population mean\index{Temporal trend of population mean (total)} is defined as [@Breidt99]

\begin{equation}
b=\sum_{j=1}^r w_j \bar{z}_j \;,
(\#eq:TrendofMean)
\end{equation}

with $r$ the number of sampling times and $\bar{z}_j$ the population mean at time $t_j$, and weights $w_j$ equal to

\begin{equation}
w_j = \frac{t_j-\bar{t}}{\sum_{j=1}^r(t_j-\bar{t})^2} \;,
(\#eq:weightsTrendofMean)
\end{equation}

with $\bar{t}$ the mean of the sampling times. Note that the temporal trend is defined as a parameter of a space-time population, not as a parameter of a time-series model.

```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:15-RepeatedSurveys.Rmd-->

# (PART) Sampling for mapping {-}

# Introduction to sampling for mapping {#IntroSamplingforMapping}

## When is probability sampling not required?

This second part of the book deals with sampling for mapping, i.e. for predicting the study variable at the nodes of a fine discretisation grid. For mapping a model-based sampling approach is the most natural option. When a statistical model, i.e. a model containing an error term modelled by a probability distribution, is used to map the study variable from the sample data, selection of the sampling units by probability sampling is not strictly needed anymore in order to make statistical statements about the population, i.e. statements with quantified uncertainty, see Section \@ref(DBvsMB). In a model-based approach we assume the model is correct, possibly after we have managed to verify the model assumptions. As a consequence there is room for optimising the sampling units, i.e. searching for those units that lead to the most accurate map in some operational sense related to map quality, for instance, the smallest squared prediction error averaged over all locations in the mapped study area, see Chapter \@ref(Validation). 

As an illustration, consider the following statistical model to be used for mapping: a linear regression model between a single predictor and the target variable to be mapped:

\begin{equation}
Z_k = \beta_0 + \beta_1 x_k + \epsilon_k \;,
(\#eq:simplelinearregressionmodel)
\end{equation}

with $Z_k$ the study variable of unit $k$, $\beta_0$ and $\beta_1$ regression coefficients and $\epsilon_k$ the error (residual) at unit $k$, normally distributed with mean zero and a constant variance $\sigma^2$. The errors are assumed independent, so that $Cov(\epsilon_k,\epsilon_j)=0$ for all $k \neq j$. Figure \@ref(fig:twosamples) shows a simple random sample without replacement and the sample optimised for mapping with a simple linear regression model. Both samples are plotted on a map of the single covariate (predictor). 

```{r, echo=FALSE}
library(gstat)
#define discretisation grid
s1 <- s2 <- 1:20 - 0.5
grid <- expand.grid(s1,s2)
names(grid) <- c("s1","s2")
N <- nrow(grid)

#define residual  semivariogram for simulation
vgmodel <- vgm(model="Exp", psill=25, range=2, nugget=0)

#compute matrix with covariances between discretisation points
dists1 <- outer(grid$s1, grid$s1, FUN="-")
dists2 <- outer(grid$s2, grid$s2, FUN="-")
dist <- sqrt(dists1^2 + dists2^2)

#compute matrix with covariances
C <- variogramLine(vgmodel, dist_vector=dist, covariance=TRUE)

#now simulate values for grid by Cholesky decomposition
Upper<-chol(C)

#simulate random numbers from standard normal distribution
set.seed(31415)
G <- rnorm(n=nrow(grid),0,1)
e <- crossprod(Upper,G)

mu <- 15
grid$x <- e + mu

ord <- order(grid$x)
grid <- grid[ord,]
grid$x[1] <- 4
grid$x[400] <- 32

#compute values of study variable as linear combination of covariate + white noise
sigma_resid <- 2
set.seed(31415)
grid$z <- 2 + 0.5*grid$x + rnorm(n=nrow(grid), mean=0, sd=sigma_resid)

#save(grid,file="data/SimulatedSquare.RData")

#select simple random sample without replacement
n<-16
idsrandom <- sample.int(400,n)
randomsample <- grid[idsrandom,]

model.random <- lm(z~x, data=randomsample)
det.random <- det(vcov(model.random))

#select optimal sample for simple linear regression model; grid cells are ordered on x
optsample <- grid[c(1,2,3,4,5,6,7,8,393,394,395,396,397,398,399,400),]
model.opt <- lm(z~x, data=optsample)
det.opt <- det(vcov(model.opt))
```

```{r twosamples, echo=FALSE, out.width='100%', fig.cap="Simple random sample (a), and optimised sample for mapping with simple linear regression model (b), plotted in a map of the covariate."}
mysamples <- rbind(randomsample,optsample)
mysamples$design <- rep(c("Random","Optimal"),each=16)

ggplot(data = grid) +
  geom_raster(mapping = aes(x = s1, y = s2, fill = x)) +
  geom_tile(data=mysamples, mapping = aes(x = s1, y = s2), colour="white", size=0.8, width=1, height=1, fill=NA)+
  scale_fill_viridis_c(name="x") +
  scale_x_continuous(name = "Easting") +
  scale_y_continuous(name = "Northing") +
  facet_wrap(~ design, ncol=2, nrow=1) +
  coord_fixed()
```

The optimised sample for mapping with a simple linear regression model contains the units with the smallest or the largest values of the covariate $x$. The optimised sample shows strong spatial clustering. Spatial clustering is not avoided because in a simple linear regression model we assume that the residuals are not spatially correlated. The standard errors of both regression coefficients are considerably smaller for the optimised sample (Table \@ref(tab:sebetas)). The joint uncertainty about the two regression coefficients, quantified by the determinant of the variance-covariance matrix\index{Determinant of variance-covariance matrix} of the estimated regression coefficients, equals `r as.character(round(det.random, 5))` for the simple random sample and `r as.character(round(det.opt, 6))` for the optimised sample. When we are less uncertain about the regression coefficients, we are also less uncertain about the regression model predictions of the study variable $z$ for at points where we have observations of the covariate $x$ only. So, we conclude that for mapping with a simple linear regression model, simple random sampling is not a good option if we are willing to rely on the assumption that there is a linear relation between $z$ and $x$. 

```{r sebetas, echo=FALSE}
tbl <- data.frame(x=c("SI","Optimised"), y=c(1.70,1.08),z=c(0.118,0.051), d=c(0.00388,0.000999))

knitr::kable(
  tbl, caption = 'Standard errors and determinant of variance-covariance matrix of estimated regression coefficients for simple random sample and optimised sample.',
  col.names=c("Sampling design", "se intercept","se slope","Determinant"),
  booktabs = TRUE
) %>%
kable_classic()
```

Of course, this simple example would only be applicable if we have evidence of the linear relation between covariate and target variable and independence of the residuals.

## Sampling for simultaneously mapping and estimating means

Although probability sampling is not strictly needed for mapping with a statistical model, in some situations, when feasible, it can still be advantageous to select a probability sample. If the aim of the survey is to map the study variable, as well as to estimate the mean or total for the entire study area or for several subareas, probability sampling can be a good option. Think, for instance, of sampling for the dual objectives of mapping and at the same time estimating soil carbon stocks. Although the statistical model used for mapping can also be used for model-based prediction of the total carbon stocks in the study area and subareas (Section \@ref(SmallAreaModelBased)), we may prefer to estimate these totals by design-based (Section \@ref(LargeDomainsDirectEstimator)) or model-assisted inference (\@ref(SmallDomainsModelAssisted)). The advantage of design-based and model-assisted estimates of these totals is their validity\index{Validity}. Validity means that an objective assessment of the uncertainty of the estimated  mean or total is warranted, and that the coverage of confidence intervals is (almost) correct, provided that the sample is large enough to assume an approximately normal distribution of the estimator and design-unbiasedness of the variance estimator, see Chapter \@ref(Approaches). In design-based estimation no model of the spatial variation is used. Discussions about how realistic modelling assumptions are, therefore are avoided.  In model-assisted estimation these discussions are irrelevant as well, because we do not rely on these assumptions. A poor model results in large variances of the estimated mean or total, and as a consequence a wide confidence interval, so that the coverage of the confidence interval is in agreement with the nominal coverage, see Section \@ref(ModelassistedvsModeldependent) for more details.

The question then is: what is a suitable probability sampling design for both aims? First, I would recommend a sampling design with equal inclusion probabilities. This is because in standard model-based inference unequal inclusion probabilities are not accounted for, which may lead to systematic prediction errors when small or large values are overrepresented in the sample (Section \@ref(BiasandVariance)).

In case we have subareas of which we would like to estimate the mean or total (domains of interest), using these subareas as strata in stratified random sampling makes sense, unless there are too many. This requires that of all population units (nodes of discretisation grid) we must know to which subarea it belongs, so that this information can be added to the sampling frame.

A sampling design spreading out the sampling units in geographical space is attractive as well, for instance through compact geographical stratification (Section \@ref(geostrata)), or sampling with the local pivotal method (Section \@ref(LPM)). We may profit from this geographical spreading if some version of kriging is used for mapping (Chapter \@ref(Introkriging)). In addition, the geographical spreading may enhance the coverage of the space spanned by covariates related to the study variable. The alternative is to exploit these covariates explicitly in the sampling design, for instance through stratified random sampling from strata constructed by k-means, using the covariates and the spatial coordinates in  clustering the population units (Section \@ref(kmeansstratification)), or through balanced sampling with (geographical) spreading (Section \@ref(BalancedandSpreaded)).

As an illustration I selected a single sample of 500 units from Amazonia with the dual aim of mapping aboveground biomass (AGB) as well as estimating the means of AGB for four biomes. The biomes are used as strata in stratified random sampling. First the stratum sample sizes are computed for proportional allocation, so that the inclusion probabilities are approximately equal for all population units.

```{r}
load("data/Amazonia_5km.RData")
gridAmazonia$Biome <- as.factor(gridAmazonia$Biome)
biomes <- c("Mangrove", "Forest.dry","Grassland","Forest.moist")
levels(gridAmazonia$Biome) <- biomes
N_h <-  table(gridAmazonia$Biome)
n <- 500
n_h <- round(n*N_h/sum(N_h))
n_h[3] <- n_h[3]+1
print(n_h)
```

Biome Forest.moist is by far the largest biome with a sample size of `r n_h[4]` points. The points from this biome are selected by balanced sampling with spreading in geographical space, using the covariate from remote sensing lnSWIR2 as a balancing variable.

```{r}
Biome_FM <- gridAmazonia[gridAmazonia$Biome=="Forest.moist",]
library(BalancedSampling)
Xbal <- cbind(rep(1, times=N_h[4]), Biome_FM$lnSWIR2)
Xspread <- cbind(Biome_FM$x1, Biome_FM$x2)
pi <- rep(n_h[4]/N_h[4], times=N_h[4])
set.seed(314)
units <- lcube(Xbal=Xbal, Xspread=Xspread, prob=pi)
mysample_FM <- Biome_FM[units,]
```

The sample sizes of the other three biomes are rather small, so I decided to keep it simple by selecting simple random samples from these three biomes.

```{r}
library(sampling)
Biomes_NFM <- gridAmazonia[gridAmazonia$Biome!="Forest.moist",]
ord <- unique(Biomes_NFM$Biome)
units <- sampling::strata(
  Biomes_NFM, stratanames="Biome", size=n_h[ord], method="srswor")
mysample_NFM <- getdata(Biomes_NFM, units)
```

Figure \@ref(fig:Sample4MappingandEstimationAmazonia) shows the selected sample.

```{r Sample4MappingandEstimationAmazonia, echo=FALSE, out.width='100%', fig.cap="Balanced sample with geographical spreading from biome moist tropical forest, balanced on lnSWIR, and stratified simple random sample from other three biomes,  Eastern Amazonia (Brazil)."}
mysample <- rbind(mysample_FM[,c("x1","x2")], mysample_NFM[,c("x1","x2")])
library(ggnewscale)

ggplot() +
  geom_tile(data=Biome_FM, mapping=aes(x=x1/1000, y=x2/1000, fill=lnSWIR2)) +
  scale_fill_viridis_c(name="lnSWIR2") +
  new_scale_fill() + 
  scale_fill_discrete() +  
  geom_tile(data=Biomes_NFM, mapping=aes(x=x1/1000, y=x2/1000, fill=Biome)) +
  geom_point(data=mysample, mapping=aes(x=x1/1000, y=x2/1000), size=1)+
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

### Balanced stratified random sampling

A somewhat more advanced sampling  design is balanced sampling, using both the categorical variable biome and the continuous variable lnSWIR2 as balancing variables (Section \@ref(StratifiedsamplingasBalancedsampling)).

```{r BalancedStratified}
pi <- n_h/N_h
stratalabels <- levels(gridAmazonia$Biome)
lut <- data.frame(Biome=stratalabels, pi=as.numeric(pi))
gridAmazonia <- merge(x=gridAmazonia, y=lut)
Xbal <- model.matrix(~Biome-1, data=gridAmazonia)
Xbal <- cbind(Xbal, gridAmazonia$lnSWIR2)
Xspread <- cbind(gridAmazonia$x1, gridAmazonia$x2)
set.seed(314)
units <- lcube(Xbal=Xbal, Xspread=Xspread, prob=gridAmazonia$pi)
mysample <- gridAmazonia[units,]
```

```{r Sample4MappingandEstimationAmazonia2, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap="Balanced stratified sample with geograhical spreading, balanced on lnSWIR2 and stratum sample sizes (biomes used as strata),  Eastern Amazonia (Brazil)."}
ggplot(data=gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=lnSWIR2)) +
  geom_point(data=mysample, mapping=aes(x=x1/1000, y=x2/1000, shape=Biome), size=2)+
  scale_shape_manual(values=c(0,1,2,3), name="") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

I think these are suitable samples, both for mapping AGB across the entire study area, for instance by kriging with an external drift (Section \@ref(IntroKED)), and for estimating the mean AGB of the four biomes. For biome Forest.moist this population mean can be estimated from the data of this biome only, using the $\pi$ estimator, as the sample size of this biome is very large (Section \@ref(BalancedandSpreaded)). For the other three biomes we may prefer model-assisted estimation for small domains as described in Section \@ref(SmallDomainsModelAssisted).

In this example I used one quantitative covariate, lnSWIR2, for balancing the sample. If we have a legacy sample that can be used to fit a linear or nonlinear model, for instance a random forest using multiple covariates and factors as predictors (Chapter \@ref(Modelassisted)), then this model can be used to predict the study variable for all populations units, so that we can use this variable with predictions of the study variable as a balancing variable, see Section \@ref(RandomForest).

## Broad overview of sampling designs for mapping

The non-probability sampling designs for mapping described in the following chapters can be grouped into three categories:  

1. Geometric designs\index{Geometric design} (Chapters \@ref(Regulargrid), \@ref(SpatialCoverage) and \@ref(kmeans))    
2. Adapted experimental designs\index{Adapted experimental design} (Chapters \@ref(cLHS) and \@ref(SpatialResponseSurface))  
3. Model-based designs\index{Model-based design} (Chapters \@ref(MBgridspacing), \@ref(MBSamplePattern))

Square and triangular grids are examples of geometric sampling designs; the sampling units show a regular, geometric spatial pattern. In other geometric sampling designs the spatial pattern is not perfectly regular. Yet these are classified as geometric sampling designs when the samples are obtained by minimising some geometric criterion, i.e. a criterion defined in terms of distances between the sampling units and the nodes of a fine prediction grid discretising the study area (Chapters \@ref(SpatialCoverage) and \@ref(kmeans)).

In model-based sampling designs the samples are obtained by minimising a criterion that is defined in terms of variances of prediction errors. An example is the mean kriging variance criterion, i.e. the average of the kriging variances over all nodes of the prediction grid. Model-based sampling therefore requires prior knowledge of the model of spatial variation. Such a model must be specified and justified. Once this model is given the sample can be optimised. In Chapter \@ref(MBgridspacing) I show how a spatial model can be used to optimise the spacing of a square grid given a requirement on the accuracy of the map. The grid spacing determines the number of sampling units, so this optimisation boils down to determining the required sample size. In Chapter \@ref(MBSamplePattern) I show how a sample of a given size can be further optimised through optimisation of the spatial coordinates of the sampling units.

In Chapter \@ref(GeneralIntro) I introduced the design-based and model-based approaches for sampling and statistical inference. Note that a model-based approach does not necessarily imply model-based sampling. The adjective model-based refers to the model-based inference, not to the selection of the units. In a model-based approach sampling units can be, but need not be, selected by model-based sampling. If they are, then both in selecting the units and in mapping a statistical model is used. In most cases the two models differ: once the  sample data are collected, these are used to update the postulated model used for sampling design. This updated model is then used for mapping.

Besides geometric and model-based sampling designs for spatial survey a third category can be distinguished: sampling designs that are adaptations of experimental designs. An adaptation is necessary because in contrast to experiments, in observational studies one is not free to choose combinations of levels of different factors. For instance, when two covariates are strongly positively correlated, it may happen that there are no units with a relatively large value for one covariate and a relatively small value for the other covariate.

In a full factorial design\index{Full factorial design} all combinations of factor levels are observed. For instance, suppose we have only two covariates, e.g., application rates for N and P in an agricultural experiment, and four levels for each covariate. To account for possible non-linear effects, a good option is to have multiple plots for all $4 \times 4$ combinations. This is referred to as a full factorial design. With $k$ factors and $l$ levels per factor the total number of observations is $l^k$. With numerous factors and/or numerous levels per factor this becomes unfeasible in practice. Alternative designs have been developed that need fewer observations but still provide detailed information about how the study variable responds to changes in the factor levels. Examples are Latin hypercube samples\index{Latin hypercube sample} and response surface designs\index{Response surface design}. The survey sampling analogues of these experimental designs are described in Chapters \@ref(cLHS) and \@ref(SpatialResponseSurface), respectively.  

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:21-IntroSampling4Mapping.Rmd-->

# Sampling on a regular grid {#Regulargrid}

Sampling on a regular grid\index{Regular grid} is an attractive option for mapping because of its simplicity. The data collected on the grid-points are not used for design-based estimation of the population mean or total, and for that reason the grid need not be placed randomly on the study area as in systematic random sampling (Chapter \@ref(SY)). The grid can be located such that the grid nodes optimally cover the study area, in the sense of the average distance of the nodes of a fine discretisation grid to the nearest node of the sampling grid. Commonly used grid configuration are square, triangular and hexagonal. If the grid data are used in kriging (Chapter \@ref(Introkriging)), the optimal configuration depends, among others, on the semivariogram model. If the study variable shows moderate to strong spatial autocorrelation, triangular grids give the best result in comparison to square grids.

Besides the shape of the grid cells, we must decide on the grid spacing\index{Grid spacing}. The grid spacing determines the number of sampling units in the study area, i.e. the sample size. There are two options to decide on this spacing, either starting from the available budget or from a requirement on the quality of the map. The latter is explained in Chapter \@ref(MBgridspacing), as this requires a model of the spatial variation, and as a consequence this is an example of model-based sampling. Starting from the available budget and an estimate of the costs per point, we first compute the affordable sample size. Then we may derive from this number the grid spacing. For square grids, the grid spacing in meters is calculated as $\sqrt{A/n}$, where $A$ is the area in m$^2$, and $n$ is the number of sampling units (sample size).

Grids can be selected with function `spsample` of package **sp** [@Pebesma2005]. The argument `offset` is used to select non-randomly a grid. A sample size can be specified, using argument `n`; alternatively a grid spacing can be specified using argument `cellsize`.

```{r grid}
library(sp)
load("data/Voorst.RData")
gridded(grdVoorst) <- ~s1+s2
mysample <- spsample(
  x=grdVoorst, type="regular", cellsize=c(200,200),
  offset=c(0.5,0.5)) %>% as(.,"data.frame")
```

Figure \@ref(fig:gridVoorst) shows the selected square grid.

```{r gridVoorst, echo=FALSE, out.width='100%', fig.cap="Non-random square grid sample from Voorst."}
grdVoorst <- as(grdVoorst, "data.frame")
ggplot()+
  geom_raster(data=grdVoorst, mapping=aes(x=s1/1000, y=s2/1000), fill="grey")+
  geom_point(data=mysample, mapping=aes(x=x1/1000,y=x2/1000), size=2) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
n <- nrow(mysample)
```

The number of grid points in this example equals `r n`. Nodes of the square grid in parts of the area not belonging to the population of interest, such as built-up areas and roads, are discarded by `spsample`, because these areas are not included in the sampling frame file `grdVoorst`. As a consequence, there are some undersampled areas\index{Undersampled area}, for instance in the middle of the study area where two roads cross. If we use the square grid in spatial interpolation, e.g., by ordinary kriging, we are more uncertain about the predictions in these undersampled areas than in areas where the grid is complete. In the next chapter I show how this local undersampling can be avoided.

#### Exercises {-}

1. Write an **R** script to select a square grid of size 100 from the three woredas in Ethiopia. The data.frame `grdEthiopia` is stored in `data/CovariatesThreeWoredasEthiopia.RData`. Use argument `offset=c(0.5,0.5)` so that the starting point of the grid is not selected randomly.   
    +  Compute the number of selected grid points. How comes that it is not exactly equal to 100?  
    +  Select a square grid with a spacing of 10.2 distance units (km), and compute the sample size.   
    +  Write a for-loop to select 200 times a square grid of on average 100 points with random starting point. Set a seed so that results can be reproduced. Determine for each randomly selected grid the number of selected grid points, and save this in a numeric. Compute summary statistics of the sample size and plot a histogram.  
    +  Select a square grid of exactly 100 points.  
  
```{r, echo=FALSE}
rm(list=ls())
```



<!--chapter:end:22-RegularGrid.Rmd-->

# Spatial coverage sampling {#SpatialCoverage}

Local undersampling with regular grids can be avoided by relaxing the constraint that the sampling units are restricted to the nodes of a regular grid. This is what is done in *spatial coverage sampling*\index{Spatial coverage sampling} or, in case of a sample that is added to an existing sample, in *spatial infill sampling*\index{Spatial infill sampling}. Spatial coverage and infill samples cover the area or fill in the empty space as uniformly as possible. The sampling units are obtained by minimising a criterion that is defined in terms of the geographic distances between the nodes of a fine discretisation grid and the sampling units. @bru07c proposed to minimise the mean of the squared distances of the grid nodes to their nearest sampling unit (mean squared shortest distance, MSSD\index{Mean squared shortest distance}):

\begin{equation}
MSSD=\frac{1}{N}\sum_{k=1}^{N}\min_{j}\left(D_{kj}^{2}\right) \;,
(\#eq:MSSD)
\end{equation}

where $N$ is the total number of nodes of the discretisation grid, and $D_{kj}$ is the distance between the $k$th grid node and the $j$th sampling point. This distance measure can be minimised by the $k$-means algorithm, which is a numerical, iterative procedure. Figure \@ref(fig:spatialcoveragesamplefromsquare) illustrates the selection of a spatial coverage sample of four points from a square. In this simple example the optimal sample is known, being the centers of four subsquares of equal size. A simple random sample of four points serves as an initial solution. Each raster cell is then assigned to the closest sampling point. This is the initial clustering. In the next iteration the centers of these initial clusters are computed. Next, the raster cells are re-assigned to the closest new centers. This continues until there is no change anymore. In this case only nine iterations are needed, where an iteration consists of computing the clusters by assigning the raster cells to the nearest center (sampling unit), followed by computing the centers of these clusters. Figure \@ref(fig:spatialcoveragesamplefromsquare) shows the first, second and ninth iteration. Note that the compact geostrata have equal size, but this is an artefact due to the shape of the area and the number of clusters. Geostrata of equal size are not guaranteed with the $k$-means algorithm described here.

```{r spatialcoveragesamplefromsquare, echo=FALSE, fig.show='hold', out.width='47%', fig.cap="First, second and ninth iteration of k-means algorithm to select a spatial coverage sample of four points from a square. Iterations are rowwise from top to bottom. In the left column of subfigures clusters are computed by assigning the raster cells to the nearest center. In the right column of subfigures centers of the clusters are computed."}
interval<-1/10
x <- y <- seq(from=interval/2, to=1, by=interval)
xy <- expand.grid(x=x, y=y)
set.seed(34526)
xsam <- runif(4)
ysam <- runif(4)
xysam<-data.frame(x=xsam, y=ysam)

i <- 1
repeat {
#compute distance matrix
  dx <- outer(X=xy$x, Y=xysam$x, FUN="-")
  dy <- outer(X=xy$y, Y=xysam$y, FUN="-")
  d <- sqrt(dx^2+dy^2)

#cluster the gridnodes
  xy$cluster <- apply(X=d, MARGIN=1, FUN=which.min)
  xy$cluster <- factor(xy$cluster)
if (i %in% c(1,2,8)) {
  print(ggplot() +
    geom_tile(data=xy, mapping=aes(x=x, y=y, fill=cluster, alpha=0.5), colour="black")+
    scale_fill_viridis_d() +
    geom_point(data=xysam, mapping=aes(x=x, y=y), shape=16, size=4)+
    scale_x_continuous(name="", limits=c(0,1), breaks=c(0.2,0.4,0.6,0.8))+
    scale_y_continuous(name="", limits=c(0,1), breaks=c(0.2,0.4,0.6,0.8))+
    coord_fixed()+
    theme(legend.position="none"))}

#save sample of previous run to check convergence
  xysamcur<-xysam

#compute the centroids of clusters
  xysam$x <- tapply(xy$x, INDEX=as.factor(xy$cluster), FUN=mean)
  xysam$y <- tapply(xy$y, INDEX=as.factor(xy$cluster), FUN=mean)


if (i %in% c(1,2,9)) {
  print(ggplot() +
    geom_tile(data=xy, mapping=aes(x=x, y=y, fill=cluster, alpha=0.5), colour="black")+
    scale_fill_viridis_d() +
    geom_point(data=xysam, mapping=aes(x=x, y=y), shape=16, size=4)+
    scale_x_continuous(name="", limits=c(0,1), breaks=c(0.2,0.4,0.6,0.8))+
    scale_y_continuous(name="", limits=c(0,1), breaks=c(0.2,0.4,0.6,0.8))+
    coord_fixed()+
    theme(legend.position="none"))}
  
#check convergence
  dxsam <- (xysam$x-xysamcur$x)^2
  dysam <- (xysam$y-xysamcur$y)^2
  dxysam <- sqrt(dxsam+dysam)
  sumdxysam <- sum(dxysam)
  if (sumdxysam < 1E-12) {break}

i <- i+1
}
```

The same algorithm was used in Chapter \@ref(STSI) to construct compact geographical strata (shortly referred to as geostrata) for stratified random sampling. In stratified random sampling, one or more sampling units are selected randomly from each geostratum. However, for mapping purposes probability sampling is not required, so the random selection of a unit within each stratum is not needed. With random selection the coverage can be optimal. To select a sample with optimal spatial coverage for each compact geostratum the means of the spatial coordinates of the nodes of the discretisation grid of that geostratum are calculated. These centers are used as sampling points. This improves the spatial coverage compared to stratified *random* sampling.

In probability sampling we may want to have strata of equal area (clusters with equal numbers of units), so that the sampling design becomes self-weighting. For mapping this constraint is not recommended as it may lead to samples with suboptimal spatial coverage. Note that in Figure \@ref(fig:spatialcoveragesamplefromsquare) the geostrata (clusters) are of equal area, but selecting four points from  a square is a very special case. In other cases the geostrata might well have unequal area. If geostrata of equal area are required for stratified simple random sampling, a different $k$-means algorithm must be used, using swops. 

Spatial coverage samples can be computed with package **spcosa** [@walvoort2010], using functions `stratify` and `spsample`, see code chunk below. Note that function `spsample` without optional argument `n` selects non-randomly one point, the center, in each cluster. Figure \@ref(fig:spatcovVoorst) shows a spatial coverage sample of the same size as the regular grid in study area Voorst (Figure \@ref(fig:gridVoorst)). Note that the undersampled area in the center of the study area is now covered by a sampling point.

```{r spatcovVoorst, out.width='100%', fig.cap="Spatial coverage sample from Voorst."}
load("data/Voorst.RData")
library(spcosa)
n <- 115
set.seed(314)
gridded(grdVoorst) <- ~s1+s2
mystrata<-stratify(grdVoorst, nStrata=n, equalArea=FALSE, nTry=10)
mysample <- spsample(mystrata)
plot(mystrata,mysample)
mysample <- as(mysample, "data.frame")
```

If the clusters need not be of equal size, we may also use function `kmeans` of the **stats** package, using the spatial coordinates as clustering variables. This requires less computing time, especially with large data sets.

```{r}
grdVoorst <- as(grdVoorst, "data.frame")
mystrata_kmeans <- kmeans(
  grdVoorst[,c("s1","s2")], centers=n, iter.max=10000, nstart=10)
mysample_kmeans <- mystrata_kmeans$centers %>% data.frame(.)
```

When function `kmeans` is used to compute the spatial coverage sample, there is no guarantee that the computed centers of the clusters used as sampling points are inside the study area. In Figure \@ref(fig:kmeanscenters) there are eight such centers.

```{r kmeanscenters, echo=FALSE, out.width='100%', fig.cap="Centers of spatial clusters computed with kmeans."}
gridded(grdVoorst) <- ~s1+s2
coordinates(mysample_kmeans) <- ~s1+s2
res <- over(mysample_kmeans, grdVoorst)
inside <- as.factor(!is.na(res$z))
levels(inside) <- (c("Outside","Inside"))
grdVoorst <- as(grdVoorst, "data.frame")
mysample_kmeans <- as(mysample_kmeans, "data.frame")
ggplot() +
  geom_raster(data=grdVoorst, mapping=aes(x=s1/1000, y=s2/1000), fill="grey")+
  geom_point(data=mysample_kmeans, mapping=aes(x=s1/1000, y=s2/1000, shape=inside), size=1.5) +
  scale_shape_manual(values = c(8, 3), name="") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  theme_minimal()+
  coord_fixed()
```
This problem can easily be solved by selecting points inside the study area closest to the centers that are outside the study area. Function `rdist` of package **fields** is used to compute a matrix with distances between the centers outside the study area and the nodes of the discretisation grid. Then function `apply` is used with argument `FUN=which.min` to compute the discretisation nodes closest to the centers outside the study area. This procedure is implemented in function `spsample` of package **spcosa** without argument `n`.

```{r}
library(fields)
units_out <- which(inside==FALSE)
D <- fields::rdist(x1=mysample_kmeans[units_out,],
                   x2=grdVoorst[,c("s1","s2")])
units_close <- apply(D, MARGIN=1, FUN=which.min)
mysample_kmeans[units_out,] <- grdVoorst[units_close,c("s1","s2")]
```

#### Exercises {-}

1. In forestry and vegetation surveys square or circular plots are often used as sampling units, for instance squares of 2 m $\times$ 2 m, or circles with a diameter of 2 m. To study the relation between the vegetation and the soil, soil samples must be collected from the vegetation plots. Suppose we want to collect four soil samples from a square plot. Where would you locate the four sampling points, so that they optimally cover the plot?  
2. Suppose  we are also interested in the accuracy of the estimated plot means of the soil properties, not just the means. In that case the soil samples should not be bulked into a composite sample, but analyzed separately. How would you select the sampling points in this case?  
3. For circular vegetation plots it is less clear where the sampling points with smallest MSSD are. Write an **R** script to compute a spatial coverage sample of five points from a circular plot discretised by the nodes of a fine square grid.  Use argument `equalArea=FALSE`. Check the size (number of grid nodes) of the strata.  Repeat this for six sampling points.  
4. Consider the case of six strata. The strata are not of equal size. If the soil samples are bulked into a composite sample, the measurement on this single sample is a biased estimator of the plot mean. How can this bias be avoided?  

## Spatial infill sampling {#SpatialInfill}

If georeferenced data are available that can be used for mapping the study variable, but we need more data for mapping, it is attractive to account for these existing sampling units when selecting the additional sampling units. The aim now is to fill in the empty spaces, i.e. the parts of the study area not covered by the existing sampling units. This is referred to as *spatial infill sampling*. Existing sampling units can easily be accommodated in the $k$-means algorithm, by using them as fixed cluster centers\index{Fixed cluster center}.

Figure \@ref(fig:spatialinfillEthiopia) shows a spatial infill sample for three woredas (districts) in Ethiopia. A large set of legacy data on soil organic matter (SOM) in wt\% is available, but these data come from strongly spatially clustered units along roads. This is a nice example of a convenience sample. The legacy data are not ideal for mapping SOM throughout the three woredas. Clearly, it is desirable to collect additional data in the off-road parts of the woredas, with the exception of the northeastern part where we have already quite a few data not near the main roads. The legacy data are specified as a *SpatialPoints* object to the `priorPoints` optional argument of **spcosa**. This argument fixes these points as cluster centers. A spatial infill sample of 100 points is selected, taking into account these fixed points.

```{r spatialinfillEthiopia, fig.cap="Spatial infill sample in three woredas of Ethiopia."}
load("data/CovariatesThreeWoredasEthiopia.RData")
load("data/ThreeWoredasEthiopia.RData")
gridded(grdEthiopia) <- ~s1+s2
n <- 100
ntot <- n+length(priordataEthiopia)
priordata <- as(priordataEthiopia, "SpatialPoints")
proj4string(priordata) <- NA_character_
set.seed(314)
mystrata <- stratify(
  grdEthiopia, nStrata=ntot, priorPoints=priordata, nTry=10)
mysample <- spsample(mystrata)
plot(mystrata, mysample)
```

In the output object of `spsample` both the prior and the new sampling points are included. The new points can be obtained as follows:

```{r}
units <- which(mysample@isPriorPoint==FALSE)
mysample <- as(mysample,"data.frame")
mysample_new <- mysample[units,]
```

#### Exercises {-}
5. Write an **R** script to select a spatial infill sample of size 100 from study area Xuancheng in China. Existing data on soil organic matter (SOM, g/kg) in the topsoil at 60 sampling points are in the data.frame `data/Xuancheng_iPSMsample.csv`. To map SOM we want to measure SOM at 100 more sampling points. Use the raster file `data/Xuancheng_elevation.tif`  as a discretisation of the study area. This file can be read with function `raster` of package **raster**. 
    +  In the example of this section there are far too many raster cells that could be used as new points in spatial infill sampling. That many cells are not needed. Subsample the raster file by selecting a square grid with a spacing of 900 m $\times$ 900 m. First change the class of the raster file to a `SpatialPixelsDataFrame`. Then use function `spsample` with argument `type=regular`.  
    +  Select a spatial infill sample using functions `stratify` and `sample` of package **spcosa**.  
  
```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:23-SpatialCoverage.Rmd-->

# Covariate space coverage sampling {#kmeans}

Regular grid sampling and spatial coverage sampling are pure spatial sampling designs. Covariates possibly related to the study variable are not accounted for in selecting sampling units. This can be suboptimal when the study variable is related to covariates of which maps are available, think for instance of remote sensing imagery or digital elevation models related to soil properties. Maps of these covariate can be used in mapping the study variable by, for instance, a multiple linear regression model or a random forest. This chapter describes a simple, straightforward method for selecting sampling units on the basis of the covariate values of the grid cells. This is a pure feature (attribute) space design.

The simplest option for covariate space coverage sampling\index{Covariate space coverage sampling} (CSC sampling) is to cluster the grid cells by the $k$-means clustering algorithm in multivariate covariate space. Similar to spatial coverage sampling (Chapter \@ref(SpatialCoverage)) the mean squared shortest distance (MSSD) is minimised, but now the distance is not measured in geographical space but in a $p$-dimensional space spanned by the $p$ covariates (think of it as a multidimensional scatter plot with the covariates along the axes). The covariates are centered and scaled, so that their means become 0 and standard deviations become 1. This is needed because, contrary to the spatial coordinates used as clustering variables in spatial coverage sampling, the dimensions of the covariates used as clustering variables generally differ, and the ranges of the covariates in the population can differ greatly. In the clustering of the grid cells the mean squared shortest *scaled* distance (MSS*S*D)^[The name 'scaled distance' can be confusing. Not the geographic distances are scaled, rather, the distances are computed in a space spanned by the scaled covariates] is minimised.

In the next code chunk a CSC sample of size 20 is selected from Eastern Amazonia. To speed up the computations a subgrid with a spacing of 5000 m is selected, using function `spsample` of package **sp**. All five quantitative covariates, SWIR2, Terra_PP, Prec_dm, Elevation and Clay, are used as covariates. To select twenty points, twenty clusters are constructed using function `kmeans` of the **stats** package [@R2020]. The number of clusters is specified with argument `centers`. Note that the number of clusters is not based, as usual in cluster analysis, on the expected number of subregions with a high density of points in the multivariate distribution, but rather on the number of observation points to be sampled. The $k$-means clustering algorithm is a deterministic algorithm, i.e. the final optimised clustering is fully determined by the initial clustering. This final clustering can be suboptimal, i.e. the minimised MSSSD value is somewhat larger than the global minimum. Therefore the clustering should be repeated many times, every time starting with a different random initial clustering. The number of repeats is specified with argument `nstart`.

```{r}
load("data/Amazonia_5km.RData")
covs <- names(gridAmazonia)[c(4,5,6,7,8)]
n <- 20
set.seed(314)
myclusters <- kmeans(
  scale(gridAmazonia[,covs]), centers=n, 
  iter.max=10000, nstart=100)
gridAmazonia$cluster <- myclusters$cluster
```

Grid cells with the shortest scaled Euclidean distance in covariate-space to the centers of the clusters are selected as the sampling points. To this end first a matrix with the distances of all the grid cells to the cluster centers is computed with function `rdist` of package **fields** [@fields]. The grid cells closest to the centers are computed with function `apply`, using argument `FUN=which.min`. 

```{r}
library(fields)
D <- rdist(x1=myclusters$centers, x2=scale(gridAmazonia[,covs]))
units <- apply(D, MARGIN=1, FUN=which.min)
myCSCsample <- gridAmazonia[units,]
```

Figure \@ref(fig:CSCsample) shows the clustering of the grid cells and the grid cells closest in covariate space to the centers,  used as the selected sample. In Figure \@ref(fig:CSCsampleinscatter) the selected sample is plotted in scatter diagrams of some pairs of covariates. In the scatter diagrams some sampling points are clearly clustered. However, this is misleading, as actually we must look in five-dimensional space to see whether the points are clustered. Two points with a large separation distance in a five-dimensional space can look quite close when these two points are projected on a two-dimensional plane, see also Exercise 2 of this chapter.

The next code chunk shows how the MSSSD of the selected sample can be computed.

```{r}
popmeans <- apply(gridAmazonia[,covs], MARGIN=2, FUN=mean)
popsds <- apply(gridAmazonia[,covs], MARGIN=2, FUN=sd)
D <- rdist(
  x1=scale(myCSCsample[,covs], center=popmeans, scale=popsds),
  x2=scale(gridAmazonia[,covs]))
dmin <- apply(D, MARGIN=2, min)
MSSSD <- mean(dmin^2)
```

Note that to center and scale the covariate values in the CSC sample, the population means and population standard deviations are used, as specified with arguments `center` and `scale` of function `scale`. If these means and standard deviations are unspecified, the *sample* means and *sample* standard deviations are used, resulting in an incorrect value of the minimised MSSSD value. The MSSSD of the selected sample equals `r as.character(round(MSSSD,3))`.

```{r CSCsample, echo=FALSE, out.width="100%", fig.cap="Covariate space coverage sample of twenty points obtained with $k$-means, from Eastern Amazonia using five covariates in clustering. The map shows the spatial distribution of the twenty clusters."}
ggplot(gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=as.character(cluster))) +
  geom_point(data=myCSCsample,mapping=aes(x=x1/1000,y=x2/1000), size=2, colour="red") +
  scale_fill_viridis_d(name="Cluster") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed() +
  theme(legend.position="none")
```

```{r CSCsampleinscatter, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap="Covariate space coverage sample, obtained with $k$-means, plotted in scatter diagrams of pairs of covariates, coloured by cluster."}
plt1 <- ggplot(gridAmazonia) +
  geom_point(mapping=aes(x=SWIR2, y=Prec_dm, colour=as.character(cluster)), alpha=0.5) +
  scale_colour_viridis_d() +
  geom_point(data=myCSCsample, mapping=aes(x=SWIR2, y=Prec_dm), size=1.5, colour="red") +
  scale_x_continuous(name="SWIR2") +
  scale_y_continuous(name="Precipitation dryest month") +
  theme(legend.position="none") +
  theme(axis.title.x=element_text(size=14),
        axis.title.y=element_text(size=14))

plt2 <- ggplot(gridAmazonia) +
  geom_point(mapping=aes(x=Terra_PP, y=Elevation, colour=as.character(cluster)), alpha=0.5) +
  scale_colour_viridis_d() +
  geom_point(data=myCSCsample, mapping=aes(x=Terra_PP, y=Elevation), size=1.5, colour="red") +
  scale_x_continuous(name="Terra_PP") +
  scale_y_continuous(name="Elevation") +
  theme(legend.position="none") +
  theme(axis.title.x=element_text(size=14),
        axis.title.y=element_text(size=14))
grid.arrange(plt1, plt2, nrow=1)
```

Instead of function `kmeans` we may use function `kmeanspp` of package **LICORS** [@Goerg2013]. This function is an implementation of the  $k$-means++ algorithm [@Arthur2007]. This algorithm consists of two parts, namely the selection of an optimised initial sample, followed by the standard $k$-means. The algorithm is as follows:  

1. Select one unit (raster cell) at random.  
2. For each unit $j$, compute $d_{ij}$, the distance in standardised covariate-space between $j$ and the nearest unit $i$ that has already been selected.  
3. Choose one new raster cell at random as a new sampling unit with probabilities proportional to $d^2_{ij}$, and add the selected raster cell to the set of selected cells.    
4. Repeat Steps 2 and 3 until $n$ centers have been selected.  
5. Now that the initial centers have been selected, proceed using standard $k$-means.  

```{r, eval=FALSE}
library(LICORS)
myclusters <- kmeanspp(
  scale(gridAmazonia[,covs]), k=n, iter.max=10000, nstart=30)
```

Due to the improved initial centers, the risk of ending in a local minimum is reduced. The $k$-means++ algorithm\index{\emph{k}-means++ algorithm} is of most interest for small sample sizes. For large sample sizes the extra time needed for computing the initial centers can become substantial and may not outweigh the larger number of starts that can be afforded with the usual $k$-means algorithm for the same computing time.

## Covariate space infill sampling

If we have legacy data that can be used to fit a model for mapping, it is more efficient to select an infill sample, similar to spatial infill sampling explained in Section \@ref(SpatialInfill). The only difference with spatial infill sampling is that the legacy data are now plotted in the space spanned by the covariates, and the empty regions we would like to fill in are now the undersampled regions in this covariate space. The legacy sample units serve as fixed cluster centers, they cannot move through the covariate space during the optimisation of the infill sample. In the next code chunk a function is defined for covariate space infill sampling.

```{r}
CSIS <- function (fixed,nsup,nstarts,mygrd) {
  nfix <- nrow(fixed)
  p <- ncol(mygrd)
  units <- fixed$units
  mygrd_minfx <- mygrd[-units,]
  MSSSD_cur <- NA
  for (s in 1:nstarts) {
    units <- sample.int(nrow(mygrd_minfx),nsup)
    centers_sup <- mygrd_minfx[units,]
    centers <- rbind(fixed[,names(mygrd)],centers_sup)
    repeat {
      D <- rdist(x1=centers, x2=mygrd)
      clusters <- apply(X=D, MARGIN=2, FUN=which.min) %>% 
        as.factor(.)
      centers_cur <- centers
      for (i in 1:p) {
        centers[,i] <- tapply(mygrd[,i], INDEX=clusters, FUN=mean)
      }
      #restore fixed centers
      centers[1:nfix,] <- centers_cur[1:nfix,]
      #check convergence
      sumd <- diag(rdist(x1=centers, x2=centers_cur)) %>% sum(.)
      if (sumd < 1E-12) {
        D <- rdist(x1=centers, x2=mygrd)
        Dmin <- apply(X=D, MARGIN=2, FUN=min)
        MSSSD <- mean(Dmin^2)
        if (s==1 | MSSSD < MSSSD_cur) {
          centers_best <- centers
          clusters_best <- clusters
          MSSSD_cur <- MSSSD
        }
        break
      }
    }
  }
  list(centers=centers_best, clusters=clusters_best)
}
```

The function is used to select an infill sample of fifteen units from Eastern Amazonia. A legacy sample of five units is randomly selected.

```{r, eval=FALSE}
set.seed(314)
units <- sample.int(nrow(gridAmazonia),5)
fixed <- data.frame(units, scale(gridAmazonia[,covs])[units,])
mygrd <- data.frame(scale(gridAmazonia[,covs]))
res <- CSIS(fixed=fixed, nsup=15, nstarts=10, mygrd=mygrd)
```

```{r, eval=FALSE, echo=FALSE}
saveRDS(res, file="results/CSIS_Amazonia.rds")
```

```{r, echo=FALSE}
res <- readRDS(file="results/CSIS_Amazonia.rds")
```

```{r CSCIS, echo=FALSE, out.width="100%", fig.cap="Covariate space infill sample, obtained with modified $k$-means from Eastern Amazonia in a map of SWIR2. The dots represent the fixed centers (legacy sample, five units), the triangles the infill sample (fifteen units)."}
gridAmazonia$cluster <- res$clusters
D <- rdist(x1=res$centers, x2=scale(gridAmazonia[,covs]))
units <- apply(D, MARGIN=1, FUN=which.min)
myCSIsample <- gridAmazonia[units,c("x1","x2",covs)]
myCSIsample$free <- c(rep("FALSE",5), rep("TRUE",15))

ggplot(data=gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=as.character(cluster))) +
#  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=SWIR2))+  
  geom_point(data=myCSIsample, mapping=aes(x=x1/1000, y=x2/1000, shape=free), colour="red", size=2) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") + 
  scale_fill_viridis_d(name="SWIR2") +
  coord_fixed() +
  theme(legend.position="none")
```

```{r CSInfillsampleinscatter, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap="Covariate space infill sample, obtained with modified $k$-means, plotted in scatter diagrams of pairs of covariates. The dots represent the fixed centers (legacy sample), the triangles the infill sample."}
plt1 <- ggplot(gridAmazonia) +
  geom_point(mapping=aes(x=SWIR2, y=Prec_dm, colour=as.character(cluster)), alpha=0.5) +
  scale_colour_viridis_d() +
  geom_point(data=myCSIsample, mapping=aes(x=SWIR2, y=Prec_dm, shape=free), size=1.5, colour="red") +
  scale_x_continuous(name="SWIR2") +
  scale_y_continuous(name="Precipitation dryest month") +
  theme(legend.position="none") +
  theme(axis.title.x=element_text(size=14),
        axis.title.y=element_text(size=14))

plt2 <- ggplot(gridAmazonia) +
  geom_point(mapping=aes(x=Terra_PP, y=Elevation, colour=as.character(cluster)), alpha=0.5) +
  scale_colour_viridis_d() +
  geom_point(data=myCSIsample, mapping=aes(x=Terra_PP, y=Elevation, shape=free), size=1.5, colour="red") +
  scale_x_continuous(name="Terra_PP") +
  scale_y_continuous(name="Elevation") +
  theme(legend.position="none") +
  theme(axis.title.x=element_text(size=14),
        axis.title.y=element_text(size=14))
grid.arrange(plt1, plt2, nrow=1)
```

## Performance of covariate space coverage sampling in random forest prediction

Covariate space coverage sampling can be a good candidate sampling design if we have multiple maps of covariates and we do not want to rely on a linear relation between the study variable and the covariates. In this situation we may consider mapping with machine learning algorithms\index{Machine learning technique}, such as neural networks and random forests\index{Random forest}.

I used the Eastern Amazonia data set to evaluate CSC sampling for mapping the aboveground biomass (AGB). The five covariates are used as predictors in random forest modelling. The calibrated models are used to predict AGB at the units of a validation sample of size 25000, selected by simple random sampling without replacement from the 1 km $\times$ 1 km grid, excluding the cells of the 10 km $\times$ 10 km grid from which the calibration samples are selected. The predicted AGB values at the validation units are compared with the true AGB values, and the prediction errors computed. The sample mean of the (squared) prediction error is a design-unbiased estimator of the population mean (squared) error, i.e. the mean of the (squared) errors at all population units (excluding the units of the 10 km $\times$ 10 km grid), see Chapter \@ref(Validation). Besides, the Nash-Sutcliffe model efficiency coefficient\index{Model efficiency coefficient} (MEC) is estimated.

Three sample sizes are used, $n=$ 25, 50, 100. Of each sample size 500 CSC samples are selected using the $k$-means algorithm, leading to 1500 CSC samples in total.  The number of starts are 500, 350 and 200 for $n=$ 25, 50, 100, respectively. With these number of starts the computing time was about equal to conditioned Latin hypercube sampling, see next chapter. Each sample is used to calibrate a random forest model. Simple random sampling (SI) is used as a reference strategy. The results are described in detail in the next chapter. In short: for $n=25$ and $50$ CSC performs on average somewhat better than SI, for $n=100$ they perform about equal. Most striking is the smaller spread in the map quality indices with CSC as compared to SI.  

In Figure \@ref(fig:RelationMSSSDRMSE) the RMSE is plotted against the minimised MSSSD, both for the $3 \times 500$ CSC samples, and for the $3 \times 500$ simple random samples. The vertical strings of points in the scatter plots are the points for the CSC samples. For all three sample sizes the minimised MSSSD values of the CSC samples is substantially smaller than those of the SI samples. For $n=25$ and $50$ the slope of the fitted line is positive: the smaller the MSSSD the smaller the expected RMSE. For $n=100$ the estimated slope parameter is slightly negative. So for this sample size we do not profit from spreading the sampling units in multivariate covariate space through $k$-means clustering.

```{r RelationMSSSDRMSE, echo=FALSE, fig.asp=0.7, fig.cap="Relation between minimisation criterion MSSSD and the root mean squared error (RMSE) of random forest predictions of aboveground biomass in Eastern Amazonia for three sample sizes. Solid lines are the fitted simple linear regression models for RMSE with MSSSD as a predictor."}
load("results/CSCversusCLH_Amazonia_n25.RData")
df.25 <- data.frame(RMSE=c(RMSE.SI,RMSE.CSC), MSSSD=c(MSSSD.SI,MSSSD.CSC), Design=rep(c("SI","CSC"), each=500),Samplesize=25)

load("results/CSCversusCLH_Amazonia_n50.RData")
df.50 <- data.frame(RMSE=c(RMSE.SI,RMSE.CSC), MSSSD=c(MSSSD.SI,MSSSD.CSC), Design=rep(c("SI","CSC"), each=500),Samplesize=50)

load("results/CSCversusCLH_Amazonia_n100.RData")
df.100 <- data.frame(RMSE=c(RMSE.SI,RMSE.CSC), MSSSD=c(MSSSD.SI,MSSSD.CSC), Design=rep(c("SI","CSC"), each=500),Samplesize=100)

df <- rbind(df.25, df.50, df.100)
df$Samplesize <- as.factor(df$Samplesize)
RMSE.lm <- lm(RMSE~MSSSD*Samplesize, data=df)
ggplot(df, mapping=aes(x=MSSSD, y=RMSE, shape=Samplesize))+
  geom_point(alpha=0.5) +
  scale_shape_manual(values=c(1,0,2), name="Sample size") +
  geom_line(mapping=aes(x=MSSSD, y=RMSE.lm$fitted))
```

#### Exercises {-}

1. Write an **R** script to select a covariate space coverage (CSC) sample of size 20,  using the covariates cti and ndvi in $k$-means clustering of the grid cells. Plot the clusters and the sample in a scatter diagram of cti against ndvi.  
2. Repeat this, but now with covariates cti, ndvi *and* elevation_m as covariates. Plot the clusters and the sample again in a scatter diagram of cti against ndvi. Explain that in this case a sampling location (cluster center) can be quite close to another sampling location, and that a cluster in a 2D-scatter diagram may also contain units of a different cluster.   
  
```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:24-CovariateSpaceCoverage.Rmd-->

# Conditioned Latin hypercube sampling {#cLHS}

This chapter and the next on response surface sampling are about experimental designs that have been adapted for spatial surveys. Adaptation is necessary because, in contrast to experiments, in observational studies one is not free to choose any possible combination of levels of different factors. When two covariates are strongly correlated it may happen that there are no units with a relatively large value for one covariate and a relatively small value for the other covariate. By contrast, in experimental research it is possible to select combinations of levels of factors so that the factors are independent.

In a full factorial design\index{Full factorial design} all combinations of factor levels\index{Factor level} are observed. With $k$ factors and $l$ levels per factor the total number of observations is $l^k$. With numerous factors and/or numerous levels per factor observing $l^k$ experimental units becomes unfeasible in practice. Alternative experimental designs have been developed that need fewer observations but still provide detailed information about how the study variable responds to changes in the factor levels. In this chapter I describe and illustrate the survey sampling analogue of Latin hypercube sampling\index{Latin hypercube sampling}. Response surface sampling will follow in the next chapter.

Latin hypercube sampling (LHS) is used in designing industrial process, agricultural and computer experiments, with numerous covariates and/or factors of which we want to study the effect on the output [@McKay1979]. With numerous covariates and/or levels per covariate a full factorial design becomes unfeasible. A much cheaper alternative then is an experiment with, for all covariates, exactly one observation per level. So in the agricultural experiment described in Chapter \@ref(IntroSamplingforMapping) with two factors, being application rates of N and of P, and four levels for each factor, this would entail four observations only, distributed in a square in such way that we have in all rows and in all columns one observation. This is referred to as a Latin square. The generalisation of a Latin square to a higher number of dimensions is a Latin hypercube (LH).

@Minasny2006 adapted LH sampling for observational studies; this adaptation is referred to as conditioned Latin hypercube sampling\index{Conditioned Latin hypercube sampling} (cLH sampling). For each covariate a series of intervals (marginal strata) is defined. The breaks of the marginal strata are chosen such that the numbers of grid cells in these marginal strata are equal. This can be done by using the quantiles corresponding with evenly spaced cumulative probabilities as stratum breaks. For instance, for five marginal strata we use the quantiles corresponding with the cumulative probabilities 0.2, 0.4, 0.6 and 0.8.

The minimisation criterion proposed by @Minasny2006 is a weighted sum of three components:   

1.  O1: the sum over all marginal strata of the absolute deviations of the marginal stratum sample size from  the targeted sample size (equal to 1).  
2.  O2: the sum over all classes of categorical covariates of the absolute deviations of the sample proportion of a given class from the population proportion of that class.  
3.  O3: the sum over all entries of the correlation matrix of the absolute deviation of the correlation in the sample from the correlation in the population.  

With cLH sampling the marginal distributions of the covariates in the sample are close to these distributions in the population. This can be advantageous for mapping methods that do not rely on linear relations, for instance in machine learning techniques like classification and regression trees (CART), and random forests. In addition, criterion O3 ensures that the correlations between predictors are respected in the sample set.

cLH samples can be selected with package **clhs** [@Roudier2011]. With this package the criterion is minimised by simulated annealing, see Section \@ref(SSA) for an explanation of this optimisation method.

cLH sampling is illustrated with the five covariates of Eastern Amazonia that were used before in covariate space coverage sampling (Chapter \@ref(kmeans)). 

```{r, eval=FALSE}
library(clhs)
load("data/Amazonia_5km.RData")
covs <- names(gridAmazonia)[c(4,5,6,7,8)]
set.seed(314)
res <- clhs(
  gridAmazonia[,covs], size=20, tdecrease=0.95,
  iter=10000, progress=FALSE, simple=FALSE)
index <- res$index_samples
myCLHsample <- gridAmazonia[index, ]
```

```{r, eval=FALSE, echo=FALSE}
save(res, file="results/cLHS_Amazonia.RData")
```

```{r, echo=FALSE}
load(file="results/cLHS_Amazonia.RData")
```

Figure \@ref(fig:cLHS) shows the selected sample in a map of SWIR2. 

Figure \@ref(fig:cLHSscat) shows the sample plotted in a scatter diagram of Precipitation Dryest Month against SWIR2. Each black dot represents one grid cell in the population. The horizontal and vertical lines in this scatter diagram are at the boundaries of the marginal strata of SWIR2 and Precipitation Dryest Month, respectively. The number of black dots within each rectangle formed by the horizontal and vertical bars are equal (i.e. marginal strata have equal size). Thus the intervals are the narrowest (rectangles have the least area) where the density of black dots in the plot is highest. Ideally in each column and each row there is exactly one sampling point but of course this is not possible if the number of points is smaller than the number of boxes in hyperspace. For example, we can see in Figure \@ref(fig:cLHSscat) that in the first marginal stratum of SWIR2 there are no sampling units, whereas in the 13th marginal two units are selected. 

```{r cLHS, echo=FALSE, out.width="100%", fig.cap="Conditioned Latin hypercube sample from Eastern Amazonia in a map of SWIR2."}
load("data/Amazonia_5km.RData")
covs <- names(gridAmazonia)[c(4,5,6,7,8)]
index <- res$index_samples
myCLHsample <- gridAmazonia[index, ]
ggplot(data=gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=SWIR2)) +  
  geom_point(data=myCLHsample, mapping=aes(x=x1/1000, y=x2/1000), colour="red", size=2) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +    
  scale_fill_viridis_c(name="SWIR2") +
  coord_fixed()
```

```{r cLHSscat, echo=FALSE, fig.cap="Conditioned Latin hypercube sample plotted in a scatter diagram of SWIR2 against precipitation in dryest month. The horizontal and vertical lines are at the boundaries of the marginal strata of the covariates SWIR2 and precipitation dryest month, respectively."}
probs <- seq(from=0, to=1, length.out=nrow(myCLHsample)+1)
breaks <- apply(gridAmazonia[,covs], MARGIN=2, FUN=function(x) quantile(x, probs=probs, type=3))
ggplot(data=gridAmazonia) +
  geom_point(mapping=aes(x=SWIR2, y=Prec_dm), colour="black", size=1, alpha=0.5) +
  geom_point(data=myCLHsample, mapping=aes(x=SWIR2, y=Prec_dm), colour="red", size=2) +
  geom_vline(xintercept=breaks[c(-1,-length(breaks)),1], colour="grey") +
  geom_hline(yintercept=breaks[c(-1,-length(breaks)),3], colour="grey") +
  scale_x_continuous(name="SWIR2") +
  scale_y_continuous(name="Precipitation dryest month")
```

Figure \@ref(fig:StratumSampleSizes) shows the sample sizes for all 100 marginal strata.

For all marginal strata\index{Marginal strata} with one sampling unit the contribution to component O1 of the criterion is zero. For marginal strata with zero or two sampling units, the contribution is 1, for marginal strata with three sampling units the contribution equals 2.

```{r StratumSampleSizes, echo=FALSE, out.width='100%', fig.asp=0.4, fig.cap="Sample sizes of marginal strata for the conditioned Latin hypercube sample of size twenty from Eastern Amazonia."}
counts <- lapply(1:5, function (i) 
  hist(myCLHsample[, i+3], breaks[,i], plot=FALSE)$counts
)

countslf <- data.frame(counts=unlist(counts))
countslf$covariate <- rep(names(gridAmazonia)[c(4,5,6,7,8)], each=20)
countslf$stratum <- rep(1:20, times=5)
ggplot(countslf) +
  geom_point(mapping=aes(x=stratum,y=counts), colour="black", size=1) +
  facet_wrap(~covariate) +
  scale_x_continuous(name="Stratum") +
  scale_y_continuous(name="Sample size", breaks=c(0,1,2,3))
```

Figure \@ref(fig:tracecLHS) shows the trace of the objective function, i.e. the values of the minimisation criterion during the optimisation.

```{r}
trace <- res$obj
```

```{r tracecLHS, echo=FALSE, fig.asp=0.6, fig.cap="Trace of minimisation criterion during optimisation of conditioned Latin hypercube sampling from Eastern Amazonia."}
tracedf <- data.frame(trace=trace)
ggplot(tracedf) +
  geom_line(mapping=aes(x=1:nrow(tracedf), y=trace), colour="black", size=0.6) +
  scale_x_continuous(name="Iteration") +
  scale_y_continuous(name="Criterion")
```

cLH samples can also be selected with function `optimCLHS` of package **spsann** [@Alessandro2016]. With this package the criterion is minimised by a spatial version of simulated annealing\index{Simulated annealing}. The function `scheduleSPANN` is used to define the annealing schedule\index{Annealing schedule}. It has some interesting arguments so that we have better control of the annealing compared to the package **clhs**, such as the arguments `initial.acceptance` and `stopping`, see Chapter \@ref(MBSamplePattern) for details. On the other hand, my experience is that package **clhs** is much quicker than package **spsann**, and can handle larger data sets.

#### Exercises {-}

1. Load the simulated data of Figure \@ref(fig:twosamples) (data/SimulatedSquare.RData), and select a cLH sample of size 16, using the covariate $x$ and the spatial coordinates as stratification variables. Plot the selected sample in the square with simulated covariate values.   
    +  What do you think of the geographical spreading of the sampling units (spatial coverage)? Is it optimal?  
    +  Compute the number of sampling points in the marginal strata of $s1$, $s2$ and the covariate $x$. First compute the breaks of these marginal strata.  Are all marginal strata of $s1$ and $s2$ sampled?  Suppose that all marginal strata of $s1$ and $s2$ are sampled (contain one sampling point), does this guarantee good spatial coverage?  
    +  Plot the trace of the minimisation criterion, and retrieve the minimised value. Is this minimised value in agreement with the marginal stratum sample sizes?  

## Conditioned Latin hypercube infill sampling {#cLHIS}

Package **clhs** can also be used for selecting a conditioned Latin hypercube sample in addition to existing sampling points, as in spatial infill sampling (Chapter \@ref(SpatialCoverage)). For this the argument `include` can be used. The argument size must then be set to the total sample size, i.e. the number of mandatory points plus the number of additional infill points.

To illustrate conditioned Latin hypercube *infill* sampling (cLHIS), I selected randomly ten points from Eastern Amazonia to serve as existing data (legacy sample). Twenty new points are selected by cLHIS. The ten mandatory points (i.e. already sampled and thus must be in the sample set computed by cLHIS) are at the end of the vector with the index of the selected raster cells.

```{r, eval=FALSE}
set.seed(314)
units <- sample.int(nrow(gridAmazonia), 10, replace=FALSE)
res <- clhs(
  gridAmazonia[,covs], size=30, include=units,
  tdecrease=0.95, iter=10000,
  progress=FALSE, simple=FALSE)
index <- res$index_samples
myCLHIsample <- gridAmazonia[index, ]
myCLHIsample$free <- as.factor(rep(c(1,0), c(20,10)))
```

```{r, eval=FALSE, echo=FALSE}
save(myCLHIsample, file="results/cLHIS_Amazonia.RData")
```

```{r, echo=FALSE}
load(file="results/cLHIS_Amazonia.RData")
```

Figure \@ref(fig:cLHIS) shows the selected Latin hypercube infill sample in a map of SWIR2, and in Figure \@ref(fig:cLHISscat) the sample is plotted in a scatter diagram of SWIR2 against Prec_dm. The marginal strata already covered by the legacy sample are mostly avoided by the additional sample.

```{r cLHIS, echo=FALSE, out.width="100%", fig.cap="Conditioned Latin hypercube infill sample from Eastern Amazonia in a map of SWIR2. Legacy points have free-value 0, infill points have free-value 1."}
ggplot(data=gridAmazonia) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000, fill=SWIR2)) +  
  geom_point(data=myCLHIsample, mapping=aes(x=x1/1000, y=x2/1000, shape=free), colour="red", size=2) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") + 
  scale_fill_viridis_c(name="SWIR2") +
  coord_fixed()
```

```{r cLHISscat, echo=FALSE, fig.asp=0.7, fig.cap="Conditioned Latin hypercube infill sample plotted in scatter diagram of SWIR2 against precipitation in dryest month. Legacy points have free-value 0, infill points have free-value 1."}
#recompute stratum boundaries as we have now 10+20 points
probs <- seq(from=0, to=1, length.out=31)
breaks <- apply(gridAmazonia[,covs], MARGIN=2, FUN=function(x) quantile(x, probs=probs, type=3))

ggplot(data=gridAmazonia) +
  geom_point(mapping=aes(x=SWIR2, y=Prec_dm), colour="black", size=1, alpha=0.5) +
  geom_point(data=as.data.frame(myCLHIsample), mapping=aes(x=SWIR2, y=Prec_dm, colour=free), size=2) +
  scale_colour_discrete() +
  geom_vline(xintercept=breaks[c(-1,-length(breaks)),1], colour="grey") +
  geom_hline(yintercept=breaks[c(-1,-length(breaks)),3], colour="grey") +
  scale_x_continuous(name="SWIR2") +
  scale_y_continuous(name="Precipitation dryest month")
```

## Performance of conditioned Latin hypercube sampling in random forest prediction

The performance of conditioned Latin hypercube sampling is studied in the same experiment as covariate space coverage sampling of the previous chapter. For this, 500 cLH samples of size 25, and an equal number of samples of size 50 and 100 are selected. Each sample is used to calibrate a random forest model for aboveground biomass (AGB), using five covariates as predictors. The calibrated models are used to predict AGB at the 25,000 validation units, selected by simple random sampling without replacement. The same procedure is used for a simple random sample (SI), as a prediction model that ignores covariates. The prediction errors are used to estimate three map quality indices\index{Map quality indices}, the population mean error\index{Population mean error} (ME), population mean squared error\index{Population mean squared error} (MSE) and the population Nash-Sutcliffe model efficiency coefficient\index{Model efficiency coefficient} (MEC), see Chapter \@ref(Validation). Figure \@ref(fig:boxplotsval) shows the results as boxplots, each based on 500 estimates.

```{r repeatedCSCandcLHS, echo=FALSE, eval=FALSE}
library(LICORS)
library(ranger)
load("data/Amazonia_1km.RData")
covs <- names(gridAmazonia)[c(2,3,4,5,6)]
#select subgrid to be used as master sample for selecting calibration samples
gridAmazonia$id <- 1:nrow(gridAmazonia)
gridded(gridAmazonia) <- ~x1+x2
subgrid <- spsample(gridAmazonia, type="regular", cellsize=10000, offset=c(0.5,0.5))
res <- over(subgrid,gridAmazonia)
subgrid <- data.frame(coordinates(subgrid), res)

#Use all nodes of 1 km $\times$ 1 km grid not selected in 10 km $\times$ 10 km grid for selecting a large validation by simple random sampling
gridAmazonia <- as(gridAmazonia,"data.frame")
grdmincalibration <- gridAmazonia[-subgrid$id,]
nval<-25000
set.seed(314)
units <- sample.int(nrow(grdmincalibration), size=nval, replace=FALSE)
myvalidationsample <- grdmincalibration[units,]

populationmeans <- apply(gridAmazonia[,covs], MARGIN=2, FUN=mean)
populationsds <- apply(gridAmazonia[,covs], MARGIN=2, FUN=sd)
r.population <- cor(gridAmazonia[,covs])

n <- 100
probs <- seq(from=0,to=1,length.out=n+1)
breaks <- apply(subgrid[,covs], MARGIN=2, FUN=function(x) quantile(x, probs=probs, type=3))

S <- 500
MSSSD.CSC <- MSSSD.CLH <- MSSSD.SI <- O1O3.CSC <- O1O3.CLH <- O1O3.SI <- time.CSC <- time.CLH <- numeric(length=S)
ME.CSC <- ME.CLH <- ME.SI <- RMSE.CSC <- RMSE.CLH <- RMSE.SI <- numeric(length=S)
for (i in 1:S) {
  print(i)

#select CSC sample
  
#  time <- system.time(myClusters <- kmeans(scale(gridAmazonia[,covs]),centers=n,iter.max=10000,nstart=500)) #n=25
#  time <- system.time(myClusters <- kmeans(scale(gridAmazonia[,covs]),centers=n,iter.max=10000,nstart=350)) #n=50
  time <- system.time(myClusters <- kmeans(scale(subgrid[,covs]),centers=n,iter.max=10000,nstart=200)) #n=100
#  time <- system.time(myClusters <- kmeanspp(scale(gridAmazonia[,covs]),k=n,iter.max=10000,nstart=40))
  time.CSC[i] <- time[1]
  subgrid$cluster <- myClusters$cluster
  res <- rdist(x1=myClusters$centers,
                     x2=scale(subgrid[,covs]))
  units <- apply(res, MARGIN=1, FUN=which.min)
  myCSCsample <- subgrid[units,]
#compute MSSSD
  res <- rdist(x1=scale(myCSCsample[,covs], center=populationmeans, scale=populationsds),
                   x2=scale(subgrid[,covs]))
  dmin <- apply(res,MARGIN=2, min)
  MSSSD.CSC[i] <- mean(dmin^2)
#compute O1+O3
  counts <- lapply(1:5, function (i) 
  hist(myCSCsample[, i+3], breaks[,i], plot=FALSE)$counts
  )
  countslf <- data.frame(counts=unlist(counts))
  O1 <- sum(abs(countslf-1))
  r.sample <- cor(myCSCsample[,covs])
  O3 <- sum(abs(r.population-r.sample))
  O1O3.CSC[i] <- O1+O3

#select cLH sample
  
   time <- system.time(clhs.out <- clhs(subgrid[, covs], size=n, tdecrease=0.95, iter=10000,
                 progress=FALSE, simple=FALSE))
  time.CLH[i] <- time[1]
  index <- clhs.out$index_samples
  myCLHsample <- subgrid[index, ]
#save O1 + O3
  O1O3.CLH[i] <- tail(clhs.out$obj,1)
#compute MSSSD
  res <- rdist(x1=scale(myCLHsample[,covs], center=populationmeans, scale=populationsds),
                  x2=scale(subgrid[,covs]))
  dmin <- apply(res, MARGIN=2, min)
  MSSSD.CLH[i] <- mean(dmin^2)

#select SI sample
  
  units <- sample.int(nrow(subgrid), size=n, replace=FALSE)
  mySIsample <- subgrid[units,]
#compute MSSSD
  res <- rdist(x1=scale(mySIsample[,covs], center=populationmeans, scale=populationsds),
                   x2=scale(subgrid[,covs]))
  dmin <- apply(res, MARGIN=2, min)
  MSSSD.SI[i] <- mean(dmin^2)
#compute O1+O3
  counts <- lapply(1:5, function (i)
  hist(mySIsample[, i+3], breaks[,i], plot=FALSE)$counts
  )
  countslf <- data.frame(counts=unlist(counts))
  O1 <- sum(abs(countslf-1))
  r.sample <- cor(mySIsample[,covs])
  O3 <- sum(abs(r.population-r.sample))
  O1O3.SI[i] <- O1+O3

#fit random forest
  
#use CSC sample for calibration
  forest.sample <- ranger(
    AGB ~ SWIR2+Terra_PP+Prec_dm+Elevation+Clay,
    data=myCSCsample,
    num.trees=1000
  )
  out <- predict(forest.sample, data=myvalidationsample, type="response")
  AGBpred <- out$predictions
  error <- AGBpred-myvalidationsample$AGB
  ME.CSC[i] <- mean(error)
  RMSE.CSC[i] <- sqrt(mean(error^2))
  
#use CLH sample for calibration
  forest.sample <- ranger(
    AGB ~ SWIR2+Terra_PP+Prec_dm+Elevation+Clay,
    data=myCLHsample,
    num.trees=1000
  )
  out <- predict(forest.sample, data=myvalidationsample, type="response")
  AGBpred <- out$predictions
  error <- AGBpred-myvalidationsample$AGB
  ME.CLH[i] <- mean(error)
  RMSE.CLH[i] <- sqrt(mean(error^2))

#use SI sample for calibration
  forest.sample <- ranger(
    AGB ~ SWIR2+Terra_PP+Prec_dm+Elevation+Clay,
    data=mySIsample,
    num.trees=1000
  )
  out <- predict(forest.sample, data=myvalidationsample, type="response")
  AGBpred <- out$predictions
  error <- AGBpred-myvalidationsample$AGB
  ME.SI[i] <- mean(error)
  RMSE.SI[i] <- sqrt(mean(error^2))
}
save(ME.CSC, ME.CLH, ME.SI, RMSE.CSC, RMSE.CLH, RMSE.SI, MSSSD.CSC, MSSSD.CLH, MSSSD.SI, O1O3.CSC, O1O3.CLH, O1O3.SI, time.CSC, time.CLH, file="results/CSCversusCLH_Amazonia_n100_new.RData")
#save(error.CSC, MSSSD.CSC, O1O3.CSC, time.CSC, file="results/kmeanspp_Amazonia_n25.RData")
```

Figure \@ref(fig:boxplotsval) shows that for $n=25$ and $100$ cLH sampling performs best, whereas for $n=50$ CSC sampling performs best. For $n=25$ and $50$ the boxplots of cLH and simple random sampling show quite a few outliers with large values of RMSE, resulting in small values of MEC. For CSC these map quality indices are more stable. The poor performance of SI shows that, if covariates are well-related with the target variable, SI is far from optimal in covering the covariate space, so that the resulting random forest models are quite poor.

```{r boxplotsval, echo=FALSE, out.width="100%", fig.asp=0.7, fig.cap ="Boxplots of ME, RMSE and MEC of predictions with random forest models calibrated on conditioned Latin hypercube (cLH), covariate space coverage (CSC) and simple random (SI) samples of Eastern Amazonia, for sample sizes of 25, 50 and 100 units."}
load("data/Amazonia_1km.RData")
#select subgrid to be used as master sample for selecting calibration samples
gridAmazonia$id <- 1:nrow(gridAmazonia)
gridded(gridAmazonia) <- ~x1+x2
subgrid <- spsample(gridAmazonia,type="regular",cellsize=10000,offset=c(0.5,0.5))
res <- over(subgrid,gridAmazonia)
subgrid <- data.frame(coordinates(subgrid),res)

#Use all nodes of 1 km $\times$ 1 km grid not selected in master sample for selecting calibration samples (10 km $\times$ 10 km grid) for selecting a large validation by simple random sampling
gridAmazonia <- as(gridAmazonia,"data.frame")
grdmincalibration <- gridAmazonia[-subgrid$id,]
nval <- 25000
set.seed(314)
units <- sample.int(nrow(grdmincalibration),size=nval,replace=FALSE)
myvalidationsample <- grdmincalibration[units,]

#ME

load("results/CSCversusCLH_Amazonia_n25.RData")
df <- data.frame(cbind(ME.CLH,ME.CSC,ME.SI))
names(df) <- c("cLH","CSC","SI")
d_25 <- df %>% pivot_longer(cols=c("cLH","CSC","SI"))
d_25$n <- 25

load("results/CSCversusCLH_Amazonia_n50.RData")
df <- data.frame(cbind(ME.CLH,ME.CSC,ME.SI))
names(df) <- c("cLH","CSC","SI")
d_50 <- df %>% pivot_longer(cols=c("cLH","CSC","SI"))
d_50$n <- 50

load("results/CSCversusCLH_Amazonia_n100.RData")
df <- data.frame(cbind(ME.CLH,ME.CSC,ME.SI))
names(df) <- c("cLH","CSC","SI")
d_100 <- df %>% pivot_longer(cols=c("cLH","CSC","SI"))
d_100$n <- 100

d <- data.frame(rbind(d_25,d_50,d_100))
d$n <- as.factor(d$n)
levels(d$n) <- c("25","50","100")
names(d)[c(1,2)] <- c("Design","ME")

plt1 <- ggplot(d, aes(x=n, y=ME)) + 
  geom_boxplot(
    aes(color=Design),
    position=position_dodge (1)) +
  scale_colour_viridis_d()

#RMSE

load("results/CSCversusCLH_Amazonia_n25.RData")
df <- data.frame(cbind(RMSE.CLH,RMSE.CSC,RMSE.SI))
names(df) <- c("cLH","CSC","SI")
d_25 <- df %>% pivot_longer(cols=c("cLH","CSC","SI"))
d_25$n <- 25

load("results/CSCversusCLH_Amazonia_n50.RData")
df <- data.frame(cbind(RMSE.CLH,RMSE.CSC,RMSE.SI))
names(df) <- c("cLH","CSC","SI")
d_50 <- df %>% pivot_longer(cols=c("cLH","CSC","SI"))
d_50$n <- 50

load("results/CSCversusCLH_Amazonia_n100.RData")
df <- data.frame(cbind(RMSE.CLH,RMSE.CSC,RMSE.SI))
names(df) <- c("cLH","CSC","SI")
d_100 <- df %>% pivot_longer(cols=c("cLH","CSC","SI"))
d_100$n <- 100

d <- data.frame(rbind(d_25,d_50,d_100))
d$n <- as.factor(d$n)
levels(d$n) <- c("25","50","100")
names(d)[c(1,2)] <- c("Design","RMSE")

plt2 <- ggplot(d, aes(x=n, y=RMSE)) + 
  geom_boxplot(
    aes(color=Design),
    position=position_dodge (1)) +
  scale_colour_viridis_d()

#MEC

S2.AGB <- var(myvalidationsample$AGB)
d$MEC <- 1 - d$RMSE^2/S2.AGB
plt3 <- ggplot(d, aes(x=n, y=MEC)) + 
  geom_boxplot(
    aes(color=Design),
    position=position_dodge (1)) +
  scale_colour_viridis_d()

grid.arrange(plt1, plt2, plt3, ncol=2)
```

In Figure \@ref(fig:RelationO1O3RMSE) the RMSE is plotted against the minimised O1 + O3 criterion for the cLH and the simple random samples. For all three sample sizes the slope of the fitted line is positive, so the smaller O1 + O3, the smaller the expected RMSE. The slope decreases with the sample size. Especially for small and moderate sample sizes selecting sampling units by minimising the O1 + O3 criterion has a positive effect on the quality of the estimates (smaller RMSE).


```{r RelationO1O3RMSE, echo=FALSE, fig.asp=0.7, fig.cap="Relation between minimisation criterion O1 + O3 and the root mean squared error (RMSE) of random forest predictions of aboveground biomass in Eastern Amazonia for three sample sizes. Solid lines are the fitted simple linear regression models for RMSE with O1 + O3 as a predictor."}
load("results/CSCversusCLH_Amazonia_n25.RData")
df.25 <- data.frame(RMSE=c(RMSE.SI,RMSE.CLH), O1O3=c(O1O3.SI,O1O3.CLH), Design=rep(c("SI","cLH"), each=500),Samplesize=25)

load("results/CSCversusCLH_Amazonia_n50.RData")
df.50 <- data.frame(RMSE=c(RMSE.SI,RMSE.CLH), O1O3=c(O1O3.SI,O1O3.CLH), Design=rep(c("SI","cLH"), each=500),Samplesize=50)

load("results/CSCversusCLH_Amazonia_n100.RData")
df.100 <- data.frame(RMSE=c(RMSE.SI,RMSE.CLH), O1O3=c(O1O3.SI,O1O3.CLH), Design=rep(c("SI","cLH"), each=500),Samplesize=100)

df <- rbind(df.25,df.50,df.100)
df$Samplesize <- as.factor(df$Samplesize)
RMSE.lm <- lm(RMSE~O1O3*Samplesize, data=df)
ggplot(df, mapping=aes(x=O1O3, y=RMSE, shape=Samplesize)) +
  geom_point(alpha=0.5) +
  scale_shape_manual(values=c(1,0,2), name="Sample size") +
  geom_line(mapping=aes(x=O1O3,y=RMSE.lm$fitted))
```

These results are somewhat different from the results of @Wadoux2019 and @Ma2020. In these case studies cLH sampling appeared to be an inefficient design for selecting a calibration sample that is subsequently used for mapping. @Wadoux2019 compared cLH sampling, CSC sampling, spatial coverage sampling (SCS) (Chapter \@ref(SpatialCoverage)), and simple random sampling for mapping soil organic carbon in France with a random forest model. The latter two sampling designs do not exploit the covariates in selecting the calibration units. Sample sizes were 100, 200, 500 and 1000. cLH sampling of calibration units performed worse (larger RMSE) than CSC sampling, and not significantly better than SI sampling for all sample sizes. For sample sizes 500 and 1000, SCS performed the best. 

@Ma2020 compared cLH, CSC and simple random sampling for mapping soil classes by various models, among which a random forest model, in a study area in Germany. Sample sizes were 20, 30, 40, 50, 75, and 100 points. They found no relation between the minimisation criterion of cLH sampling and the overall accuracy of the map with predicted soil classes. Models calibrated on CSC samples performed better on average, i.e. on average the overall accuracy of the maps obtained by calibrating the models on these CSC samples had higher overall accuracy. cLH sampling was hardly better than simple random sampling.

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:25-cLHS.Rmd-->

# Spatial response surface sampling {#SpatialResponseSurface}

As with conditioned Latin hypercube sampling (cLHS), spatial response surface sampling\index{Spatial response surface sampling} is an experimental design adapted for spatial surveys. Experimental response surface designs aim at finding an optimum combination of the response within specified ranges of the factors. There are many types of response surface designs, see @myers2002.  With response surface sampling one assumes that some type of low order (linear or quadratic) regression model can be used to accurately approximate the relationship between the study variable and the covariates.  A commonly used design is the central composite design\index{Central composite design}. The data produced as a result of this design are used to fit a curved, quadratic surface, i.e. a multiple linear regression model with quadratic terms.

The response surface sampling approach is an example of a model-based sampling design. From that viewpoint I should have described this sampling design in the later part of this book dealing with model-based sampling. Sampling units are selected to implicitly optimise the estimation of the linear or quadratic regression model. However, this optimisation is done under one or more spatial constraints. Unconstrained optimisation of the sampling design under the linear regression model will not prevent the units from spatial clustering, see Figure \@ref(fig:twosamples)(b). The assumption of independent data might be violated when the sampling units are spatially clustered.  For that reason the response surface sampling design selects samples with good spatial coverage, so that the design becomes robust against violation of the independence assumption.

@lesch95 adapted the response surface methodology so that it can be applied in observational studies. Several problems needed to be tackled. First, when multiple covariates are used, the covariates must be decorrelated. Second, when sampling units are spatially clustered, the assumption in linear regression modelling of spatially uncorrelated model residuals can be violated. To address these two problems @lesch95 proposed the following procedure; see also @lesch2005:   

1. Transform the covariate matrix into a scaled, centered, de-correlated matrix by principal components analysis (PCA).   
2. Choose the response surface design type.   
3. Select candidate sampling units based on the distance from the design points in PC-space and then select multiple units per design point.   
4. Select the combinatin of candidate sampling units with the highest value for a criterion that quantifies how uniform the sample is spread across the study area.   

This design has been applied, among others, for mapping soil salinity (ECe), using electromagnetic induction (EM) measurements and surface array conductivity measurements as predictors in multiple linear regression models. For applications, see @corwin2005, @lesch2005, @fitzgerald2006, @Corwin2010 and @Fitzgerald2010.

Spatial response surface sampling  is illustrated with the electromagnetic induction (EM) measurements (mS/m) of the apparent electrical conductivity on the 80 ha Cotton Research Farm in Uzbekistan (Section \@ref(Datasets)). The EM measurements in vertical dipole mode with transmitter at 1 m and 0.5 m from the receiver, are on transects covering the Cotton Research Farm (Figure \@ref(fig:EMdataUzbekistan)). As a first step the natural logarithm of the two EM measurements are interpolated by ordinary kriging to a fine grid (Figure \@ref(fig:EMdataUzbekistan2)). These ordinary kriging predictions of lnEM are used as covariates in response surface sampling (Figure \@ref(fig:EMdataUzbekistan)). The two covariates are strongly correlated, $r=0.73$, as would be expected since they are of the same variable at two depths.

```{r EMdataUzbekistan, echo=FALSE, out.width='100%', fig.cap="Natural logarithm of EM38 measurements on the Cotton Research Farm in Uzbekistan (with transmitter at 1 m and 0.5 m from receiver)."}
dat <- read.csv(file="data/TransectsData_EM_CRF.csv")
dat$lnEMv1m <- log(dat$EMv1mt)
dat$lnEMv0.5m <- log(dat$EMv05mt)
dat <- na.omit(dat)
coordinates(dat) <- ~ x * y
proj4string(dat) <- CRS("+proj=longlat +datum=WGS84") #=  +init=epsg:4326
dat <- spTransform(dat, CRS = CRS("+proj=tmerc +lat_0=0.000000000 +lon_0=63.000000000 +k=1.000000 +x_0=500000.000 +y_0=0.000 +ellps=krass +units=m"))
dat <- as(dat,"data.frame")
names(dat)[c(9,10)] <- c("lnEM100cm","lnEM50cm")
df <- dat %>% pivot_longer(cols=c("lnEM100cm","lnEM50cm"))

ggplot(data = df) +
  geom_point(mapping = aes(x = x/1000, y = y/1000, colour = value), size=0.3) +
  scale_colour_viridis_c(name = "lnEM") +
  scale_x_continuous(name="Easting (km)",limits=c(305.5,308)) +
  scale_y_continuous(name="Northing (km)",limits=c(4602,4603.5)) +
  coord_fixed() +
  facet_grid(~ name)
```



```{r EMdataUzbekistan2, echo=FALSE, out.width='100%', fig.cap="Interpolated surfaces of natural logarithm of EM38 measurements on the Cotton Research Farm in Uzbekistan, used as covariates in spatial response surface sampling."}
load(file="data/CottonResearchFarm.RData")
df <- EM_CRF %>% pivot_longer(cols=c("lnEM100cm","lnEM50cm"))

ggplot(data = df) +
  geom_raster(mapping = aes(x = x1/1000, y = x2/1000, fill = value)) +
  scale_fill_viridis_c(name = "lnEM") +
  scale_x_continuous(name="Easting (km)",limits=c(305.5,308)) +
  scale_y_continuous(name="Northing (km)",limits=c(4602,4603.5)) +
  coord_fixed() +
  facet_grid(~ name)
```

Function `prcomp` of the **stats** package [@R2020] is used to compute the principal component scores\index{Principal component score} for all units in the population (grid cells). The two covariates are centered and scaled, i.e. we compute standardised principal components. 

```{r}
grdsub <- subset(EM_CRF, select=c(lnEM100cm,lnEM50cm))
pc <- prcomp(grdsub, center=TRUE, scale=TRUE)
```

The means of the two principal component scores are 0, their standard deviations are `r round(pc$sdev[1],3)` and `r round(pc$sdev[2],3)`. The principal component scores are then scaled so that their standard deviations become 1, i.e. they will have the same weight in the following steps. 

```{r}
EM_CRF$PC1 <- pc$x[,1]*1/pc$sdev[1]
EM_CRF$PC2 <- pc$x[,2]*1/pc$sdev[2]
```

Figure \@ref(fig:candidatelocations) shows a scatter plot of the two standardised principal component scores of all `r nrow(EM_CRF)` grid cells.

Function `ccd` of package **rsm** ([@Lenth2009] is now used to generate a central composite response surface design\index{Central composite response surface design} (CCRSD). Argument `basis` specifies the number of factors, which is two in our case; argument `n0` is the number of center points, and argument `alpha` determines the position of the "star points" (explained hereafter).

```{r}
library(rsm)
set.seed(314)
print(ccdesign <- ccd(basis=2, n0=1, alpha="rotatable"))
```

The experiment consists of two blocks, each of five experimental units. Block 1, the so-called cube block, consists of one center point and four cube points\index{Cube point}. In the experimental unit represented by the center point both factors have levels in the center of the experimental range. In the experimental units represented by the cube points the levels of both factors is either -1 or +1 unit in the design space. Block 2, referred to as the star block, consists of one center point and four star points\index{Star point}. With `alpha = rotatable` the  start points are on the circle circumscribing the square (Figure \@ref(fig:ccdesign)).

```{r ccdesign, echo=FALSE, fig.cap="Rotatable central composite response surface design for two factors."}
cube <- data.frame(x1=c(-1,1,-1,1,0),x2=c(-1,-1,1,1,0))
star <- data.frame(x1=c(-sqrt(2),sqrt(2),0,0,0), x2=c(0,0,-sqrt(2),sqrt(2),0))
df <- rbind(cube,star)
df$block <- rep(c("cube","star"),each=5)
ggplot(df) +
  geom_point(mapping=aes(x=x1,y=x2,shape=block),size=2) +
  scale_shape_manual(values=c(0, 8)) +
  geom_path(data=data.frame(x=c(-1,-1,1,1,-1),y=c(-1,1,1,-1,-1)),aes(x=x,y=y),lty=2) +
  geom_circle(aes(x0=0,y0=0,r=sqrt(2)),lty=2) +
  coord_fixed()
```

To adapt this design for an observational study, we drop one of the center points (0,0).
 
```{r}
ccd_df <- data.frame(x1=ccdesign$x1, x2=ccdesign$x2)
ccd_df <- ccd_df[-6,]
```

The points in the CCRSD design are adjusted so that a large proportion $p$ of the bivariate standardised principal component scores of the population units are within a circle of a given radius. This radius is computed as a sample quantile of the empirical distribution of the distances of the points in the scatter to the center. For $p$ I chose 0.7.

```{r}
d <- sqrt(EM_CRF$PC1^2+EM_CRF$PC2^2)
radius <- quantile(d, p=0.7)
print(radius)
ccd_df$x1 <- ccd_df$x1*radius
ccd_df$x2 <- ccd_df$x2*radius
```

The next step is to select for each design point several candidate sampling units. For each of the nine design points\index{Design point} 0.5% of the grid cells are selected that are closest to that design point. This results in $9 \times 8$ candidate sampling points.

```{r}
EM_CRF$unit <- 1:nrow(EM_CRF)
candi_all <- NULL
for (i in 1:nrow(ccd_df)) {
    d2dpnt <- sqrt((EM_CRF$PC1-ccd_df$x1[i])^2+
                     (EM_CRF$PC2-ccd_df$x2[i])^2)
    q <- quantile(d2dpnt, p=0.005)
    units_close <- which(d2dpnt < q)
    candi <- EM_CRF[units_close,c("unit","x1","x2","PC1","PC2")]
    candi$dpnt <- i
    candi_all <- rbind(candi_all,candi)
}
```

Figure \@ref(fig:candidatelocations) shows the nine clusters of candidate sampling points around the design points. Note that the location of the candidate points associated with the design points with coordinates  (-1.51,-1.51), (0, -2.13), (1.51,-1.51) and (2.13,0) are all far inside the circle that passes through the design points. So for the optimised sample the value of one of the principal component scores will be less extreme than the ideal values according to the CCRSD design.   

```{r candidatelocations, echo=FALSE, fig.cap="Clusters of units (red points) around the design points (triangles) of a central composite design (two covariates), serving as candidate sampling points."}
notcandidates <- EM_CRF[-candi_all$unit,]
ggplot(notcandidates) +
  geom_point(mapping=aes(x=PC1,y=PC2),alpha=0.5) +
  geom_point(data=candi_all,mapping=aes(x=PC1,y=PC2),colour="red") +
  geom_point(data=ccd_df,aes(x=x1,y=x2),shape=2) +
  scale_x_continuous(name="PC1",limits=c(-4,3)) +
  scale_y_continuous(name="PC2",limits=c(-3,3)) +
  coord_fixed()
```
Figure \@ref(fig:candidatesingeospace) shows that in geographical space for most design points there are multiple clusters of candidate units. For instance, for design point 9 there are three clusters of candidate sampling units. Due to this there is scope to optimise the sample computationally. 

```{r candidatesingeospace, echo=FALSE, fig.cap="Candidate sampling points plotted in geographical space on the first standardised principal component."}
library(ggpubr)
ggplot(EM_CRF) +
  geom_raster(aes(x=x1/1000,y=x2/1000,fill=PC1)) +
  geom_point(data=candi_all,mapping=aes(x=x1/1000,y=x2/1000,shape=as.factor(dpnt)),size=2) +
  scale_shape_manual(values=c(0,1,2,3,4,5,6,7,8),name="design point") +
  scale_fill_viridis_c(name="PC1") + 
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

As a first step an initial subsample from the candidate sampling units is selected by stratified simple random sampling, using the factor `dpnt` as strata. Function `strata` of package **sampling** is used for stratified random sampling [@Tille2016].

```{r}
library(sampling)
set.seed(314)
units_stsi <- sampling::strata(
  candi_all, stratanames="dpnt", size=rep(1,9))
mysample0 <- getdata(candi_all, units_stsi)
mysample0 <- mysample0[,c("unit","x1","x2","PC1","PC2","dpnt")]
```

The locations of the nine sampling points are now optimised by minimising a criterion. Two minimisation criteria are implemented, a geometric criterion and a model-based criterion. 

In the geometric criterion (as proposed by @lesch2005) for each sampling point the shortest distance to the other points is computed, and the logarithm of this shortest distance is computed. The minimisation criterion is the negative of the sample mean of the logarithm of shortest distance. 

The model-based minimisation criterion is the average correlation of the sampling points. This criterion requires as input the parameters of a residual correlogram (see Section \@ref(IntroKED)). I assume an exponential  correlogram without nugget, so that the only parameter to be chosen is the distance parameter $\phi$. Three times $\phi$ is referred to as the effective range\index{Effective range} of the exponential covariance function. The correlation of two random variables at this distance is 0.05. A penalty term is added to these criteria, equal to the average distance, in the space spanned by the principal component scores, of the sampling points to the associated design points, multiplied by a weight. With weights $> 0$ sampling points close to the design points are preferred over more distant points.

A function is defined for computing the minimisation criterion.  Given a chosen value for $\phi$, the $9 \times 9$ distance matrix of the sampling points can be converted into a correlation matrix, using function `variogramLine` of package **gstat** [@peb04]. Argument `weight` is an optional argument with default value 0.

```{r}
getCriterion <- function(mysample, dpnt, weight=0, phi=NULL){
  D2dpnt <- sqrt((mysample$PC1-dpnt$x1)^2+
                   (mysample$PC2-dpnt$x2)^2)
  D <- as.matrix(dist(mysample[,c("x1","x2")]))
  if (!is.null(phi)) {
    vgmodel <- vgm(model="Exp", psill=1, range=phi)
    C <- variogramLine(vgmodel, dist_vector=D, covariance=TRUE)
    criterion_cur <- mean(C)+mean(D2dpnt)*weight
  } else {
    diag(D) <- NA
    logdmin <- apply(D, MARGIN=1, FUN=min, na.rm=TRUE) %>% log(.)
    criterion_cur <- mean(-logdmin)+mean(D2dpnt)*weight
  }
}
```

The function `getCriterion` is used to compute the geometric criterion for the initial sample.

```{r}
criterion_geo <- getCriterion(mysample=mysample0, dpnt=ccd_df)
```

The initial value of the geometric criterion  is `r round(criterion_geo,3)`. The initial value for the model-based criterion is computed with an effective range of 50 m. Note that it does not make sense to make this range smaller than the size of the grid cells, which is 25 m in our case. For smaller ranges the correlation matrix is for any sample a matrix with zeroes. If the effective range is smaller than the smallest distance between two points in a cluster, the mean correlation is equal for all samples. 

```{r}
phi <- 50
criterion_mb <- getCriterion(
  mysample=mysample0, dpnt=ccd_df, phi=phi)
```

The initial value of the model-based criterion is `r round(criterion_mb,3)`.

The objective function defining the minimisation criterion is minimised with simulated annealing\index{Simulated annealing} (@Kirkpatrick1983, @Aarts1987). One sampling point is randomly selected, and replaced by another candidate sampling point from the same cluster. If the criterion of the new sample is smaller than that of the current sample, the new sample is accepted, if it is larger it is accepted with a probability that is a function of the change in the criterion (the larger the increase, the smaller the acceptance probability) and of an annealing parameter named the temperature (the higher the temperature, the larger the probability of accepting a new, poorer sample, given an increase of the criterion). See Section \@ref(SSA) for a more detailed introduction to simulated annealing. The annealing functions for spatial response surface sampling are defined in **R** script
[AnnealingFunctions4SpatialResponseSurfaceSampling.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Rscripts/AnnealingFunctions4SpatialResponseSurfaceSampling.R)^[https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Rscripts/AnnealingFunctions4SpatialResponseSurfaceSampling.R].

```{r, eval=FALSE}
source('Rscripts/AnnealingFunctions4SpatialResponseSurfaceSampling.R')
set.seed(314)
mySRSsample <- anneal(
  mysample=mysample0, candidates=candi_all, dpnt=ccd_df,
  phi=50, T_ini=1, coolingRate=0.9,
  maxPermuted=25*nrow(mysample0), maxNoChange=20,
  verbose=TRUE)
```

```{r, eval=FALSE, echo=FALSE}
save(mySRSsample, file="results/SpatialResponseSurfaceSample_CRF_geo.RData")
#save(mySRSsample, file="results/SpatialResponseSurfaceSample_CRF_mb.RData")
```

Figure \@ref(fig:CCRSDinPCspace) shows the optimised CCRSD samples, obtained with the geometric and model-based criterion, plotted together with the design points. The two optimised samples are very similar.

```{r CCRSDinPCspace, echo=FALSE, out.width='100%', fig.cap="Principal component scores of CCRSD sample (triangles), optimised with the geometric and model-based criterion. Dots: design points."}
load(file="results/SpatialResponseSurfaceSample_CRF_geo.RData")
mysample_geo<-mySRSsample$mysample
critmin_geo <- tail(mySRSsample$trace,1)

load(file="results/SpatialResponseSurfaceSample_CRF_mb.RData")
mysample_mb <- mySRSsample$mysample
critmin_mb <- tail(mySRSsample$trace,1)

mysamples <- rbind(mysample_geo, mysample_mb)
mysamples$design <- rep(c("geometric","model-based"), each=9)

ggplot(mysamples) +
 geom_point(aes(x=PC1,y=PC2), shape=2, size=3) +
 geom_point(data=ccd_df, mapping=aes(x=x1,y=x2), size=3) +
 scale_x_continuous(name="PC1") +
 scale_y_continuous(name="PC2") +
 facet_wrap(~ design) +
 coord_fixed()
```

Figure \@ref(fig:CCRSDSample) shows the two optimised CCRSD samples plotted in geographical space on the first standardised principal component scores.

```{r CCRSDSample, echo=FALSE, fig.cap="CCRSD sample from the Cotton Research Farm in Uzbekistan, optmized with the geometric and model-based criterion."}

ggplot(mysamples) +
  geom_raster(data=EM_CRF, mapping=aes(x=x1/1000,y=x2/1000,fill=PC1)) +
  geom_point(data=mysamples, mapping=aes(x=x1/1000, y=x2/1000), size=2) +
  scale_fill_viridis_c(name="PC1") + 
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  facet_wrap(~ design, ncol=1, nrow=2)+
  coord_fixed()
```

## Increasing the sample size {#IncreaseSampleSize}

Nine points are rather few for fitting a polynomial regression model, especially for a second-order polynomial with interaction. Therefore, in experiments often multiple observations are done for each design point. Increasing the sample size of a response surface sample in observational studies is not straightforward. The challenge is to avoid spatial clustering of sampling points. A simple solution is to select multiple points from each subset of candidate sampling units. The success of this solution depends on the strength of the spatial clustering of the candidate sampling units per design point. For the Cotton Research Farm for most design points the candidate sampling units are not in one spatial cluster, so in this case this solution may work properly. I increased the number of candidate sampling units per design point (argument `p` in function `quantile` is now 0.01), so that there is a larger choice in the optimisation of the sample pattern. 

```{r}
candi_all <- NULL
for (i in 1:nrow(ccd_df)) {
    d2dpnt <- sqrt((EM_CRF$PC1-ccd_df$x1[i])^2+
                     (EM_CRF$PC2-ccd_df$x2[i])^2)
    q <- quantile(d2dpnt, p=0.01)
    units_close <- which(d2dpnt < q)
    candi <- EM_CRF[units_close,c("unit","x1","x2","PC1","PC2")]
    candi$dpnt <- i
    candi_all <- rbind(candi_all,candi)
}
```

A stratified random subsample of two points per stratum is selected, which serves as an initial sample.

```{r}
set.seed(314)
units_stsi <- sampling::strata(
  candi_all, stratanames="dpnt", size=rep(2,9))
mysample0 <- getdata(candi_all, units_stsi)
mysample0 <- mysample0[,c("unit","x1","x2","PC1","PC2","dpnt")]
```

The `data.frame` with the design points must be doubled. Note that the order of the design points must be the equal to the order in the stratified subsample.

```{r}
tmp <- data.frame(ccd_df,dpnt=1:9)
dpnt <- rbind(tmp,tmp)
ccd_df2 <- dpnt[order(dpnt$dpnt),]
```

```{r, echo=FALSE, eval=FALSE}
set.seed(314)
mySRSsample <- anneal(
  mysample=mysample0,
  candidates=candi_all,
  dpnt=ccd_df2,
  phi=50,
  T_ini=1,
  coolingRate=0.9,
  maxPermuted=25*nrow(mysample0),
  maxNoChange=20,
  verbose=TRUE
)
save(mySRSsample, file="results/SpatialResponseSurfaceSample_2n_CRF_mb.RData")
```

Figures \@ref(fig:CCRSDUzbekistan2n) and \@ref(fig:CCRSDinPCSpace2n) show the optimised CCRSD sample of eighteen points in geographical and principal component space, respectively, obtained with the model-based criterion, an effective range of 50 m, and zero weight for the penalty term. Sampling points are not spatially clustered, so I do not expect violation of the assumption of independent residuals. In principal component space all points are pretty close to the design points, except for the four design points in the lower right corner, where no candidate units near these design points are available.

```{r CCRSDUzbekistan2n, echo=FALSE, fig.cap="CCRSD sample with two points per design point, from the Cotton Research Farm in Uzbekistan."}
load(file="results/SpatialResponseSurfaceSample_2n_CRF_mb.RData")
mysample<-mySRSsample$mysample
ggplot(EM_CRF) +
  geom_raster(aes(x=x1/1000,y=x2/1000,fill=PC1)) +
  geom_point(data=mysample,mapping=aes(x=x1/1000,y=x2/1000),size=2) +
  scale_fill_continuous(name="PC1",type = "viridis") + 
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

```{r CCRSDinPCSpace2n, echo=FALSE, out.width='50%', fig.cap="CCRSD sample (triangles) with two points per design point (dots), optimised with model-based criterion."}
load(file="results/SpatialResponseSurfaceSample_2n_CRF_mb.RData")
mysample<-mySRSsample$mysample
ggplot(mysample) +
 geom_point(data=ccd_df,aes(x=x1,y=x2),size=3) +
 geom_point(aes(x=PC1,y=PC2),size=3,shape=2) +
 scale_x_continuous(name="PC1") +
 scale_y_continuous(name="PC2") +
 coord_fixed()
```

## Stratified spatial response surface sampling

The sample size can also be increased by stratified spatial response surface sampling\index{Stratified spatial response surface sampling}. The strata are subareas of the study area. When the subsets of candidate sampling units for some design points are strongly spatially clustered, the final optimised sample obtained with the method of the previous section may also show strong spatial clustering. An alternative is then to split the study area into two or more subareas (strata), and to select from each stratum candidate sampling units. This guarantees that for each design point we have at least as many spatial clusters of candidate units as we have strata. The spatial strata are not used for fitting separate regression models; all data are used to fit one (second-order) polynomial regression model. 

Figure \@ref(fig:StrataCRF4CCRSD) shows two subareas used as strata in stratified response surface sampling of the Cotton Research Farm.

```{r StrataCRF4CCRSD, echo=FALSE, fig.cap="Two subareas of the Cotton Research Farm in Uzbekistan used as strata in stratified CCRSD sampling."}
load(file="results/SpatialResponseSurfaceSample_2n_CRF_mb.RData")
ggplot(EM_CRF) +
  geom_raster(aes(x=x1/1000,y=x2/1000, fill=as.factor(subarea))) +
  scale_fill_grey(name="Strata") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

The candidate sampling units are selected in a double for-loop. The outer loop is over the strata, the inner loop over the design points. Note that the variable `dpnt` continues to increase by 1 after the inner-loop over the nine design points in subarea 1 is completed, so that the variable `dpnt` (used as a stratum in subsampling the sample of candidate sampling points) now has values $1,2, \dots , 18$.  Stratum 2 is larger than stratum 1. To select an equal number of candidate sampling points per design point in both strata (eight points), I adapted argument `p` of function `quantile'. 

```{r}
candi_all <- NULL
p <- c(0.0105,0.009)
for (h in c(1,2)) {
  units <- which(EM_CRF$subarea==h)
  data_stratum <- EM_CRF[units,]
  candi_stratum <- NULL
  for (i in 1:nrow(ccd_df)) {
      d2dpnt <- sqrt((data_stratum$PC1-ccd_df$x1[i])^2+
                       (data_stratum$PC2-ccd_df$x2[i])^2)
      q <- quantile(d2dpnt,p=p[h])
      units_close <- which(d2dpnt < q)
      candi <- data_stratum[units_close,
                            c("unit","x1","x2","PC1","PC2")]
      candi$dpnt <- i + (h-1)*nrow(ccd_df)
      candi_stratum <- rbind(candi_stratum, candi)
  }
  candi_all <- rbind(candi_all, candi_stratum)
}
```

```{r, echo=FALSE, fig.cap="Candidate sampling points for stratified CCRSD sampling, plotted on first principal component (PC1)"}
subarea <- as.factor(c(rep(1,nrow(candi_all)/2),rep(2,nrow(candi_all)/2)))
dpnt9 <- c(rep(1:9, each=8), rep(1:9, each=8))
ggplot(EM_CRF) +
  geom_raster(aes(x=x1/1000,y=x2/1000,fill=PC1)) +
  geom_point(data=candi_all,mapping=aes(x=x1/1000,y=x2/1000,shape=as.factor(dpnt9)),size=1.5)+
  scale_shape_manual(values=c(0,1,2,3,4,5,6,7,8),name="design point") +
  scale_fill_continuous(name="PC1",type = "viridis") + 
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

As before, `dpnt` is used as a stratum identifier to subsample the candidate sampling units. Finally, the number of rows in the `data.frame` `ccd_df` with the design points is doubled.

```{r}
set.seed(314)
units_stsi <- sampling::strata(
  candi_all, stratanames="dpnt", size=rep(1,18))
mysample0 <- getdata(candi_all, units_stsi)
mysample0 <- mysample0[,c("unit","x1","x2","PC1","PC2","dpnt")]
ccd_df2 <- rbind(ccd_df,ccd_df)
```

```{r, echo=FALSE, eval=FALSE}
set.seed(314)
mySRSsample <- anneal(
  mysample=mysample0,
  candidates=candi_all,
  dpnt=ccd_df2,
#  weight=5,
  phi=50,
  T_ini=1,
  coolingRate=0.9,
  maxPermuted=25*nrow(mysample0),
  maxNoChange=20,
  verbose=TRUE
)
save(mySRSsample, file="results/StratifiedSpatialResponseSurfaceSample_CRF_mb.RData")
#save(mySRSsample, file="results/StratifiedSpatialResponseSurfaceSample_CRF_mb_w5.RData")
```

Figures \@ref(fig:StratifiedCCRSD) and \@ref(fig:StratifiedCCRSDinPCSpace) show the optimised sample of eighteen points in geographical and principal component space, obtained with the model-based criterion with an effective range of 50 m. The pattern in the principal component space is worse compared to the pattern in Figure \@ref(fig:CCRSDinPCSpace2n). In stratum 1 the distance to the star point at the top and the upper left cube point is very large. In this stratum no population units are present that are close to these two design points. The distance could be decreased a bit by adding a penalty term to the minimisation criterion that is proportional to this distance. However, the optimised sample obtained with `weight=5` shows much stronger spatial clustering. In addition, there are some pairs of points with a separation distance smaller than the effective range used in optimisation, so that violation of the independence assumption becomes more likely. 

```{r StratifiedCCRSD, echo=FALSE, fig.cap="Stratified CCRSD samples from the Cotton Research Farm in Uzbekistan, optimised with model-based criterion, obtained without (weight = 0) and with penalty (weight = 5) for large average distance to design points."}
load(file="results/StratifiedSpatialResponseSurfaceSample_CRF_mb.RData")
mysample_w0 <- mySRSsample$mysample

load(file="results/StratifiedSpatialResponseSurfaceSample_CRF_mb_w5.RData")
mysample_w5 <- mySRSsample$mysample
mysamples <- rbind(mysample_w0,mysample_w5)
mysamples$weight <- rep(c("weight: 0","weight: 5"), each=18)

ggplot(mysamples) +
  geom_raster(data=EM_CRF, mapping=aes(x=x1/1000,y=x2/1000, fill=PC1)) +
  geom_point(data=mysample,mapping=aes(x=x1/1000,y=x2/1000), size=2) +
  scale_fill_continuous(name="PC1",type = "viridis") + 
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  facet_wrap(~ weight, ncol=1, nrow=2) +
  coord_fixed()
```

```{r StratifiedCCRSDinPCSpace, echo=FALSE, out.width='100%', fig.cap="Principal component scores of the stratified CCRSD sample, optimised with model-based criterion, obtained without (weight = 0) and with penalty (weight = 5) for a large average distance to design points (dots)."}
load(file="results/StratifiedSpatialResponseSurfaceSample_CRF_mb.RData")
mysample_w0<-mySRSsample$mysample
mysample_w0$subarea <- as.factor(rep(c(1,2),each=9))

load(file="results/StratifiedSpatialResponseSurfaceSample_CRF_mb_w5.RData")
mysample_w5<-mySRSsample$mysample
mysample_w5$subarea <- as.factor(rep(c(1,2),each=9))

mysamples <- rbind(mysample_w0,mysample_w5)
mysamples$weight <- rep(c("weight: 0","weight: 5"), each=18)

ggplot(mysamples) +
 geom_point(data=ccd_df, mapping=aes(x=x1, y=x2), size=2) +
 geom_point(aes(x=PC1,y=PC2, shape=subarea), size=2) +
 scale_shape_manual(values=c(2,3), name="Stratum") +
 scale_x_continuous(name="PC1") +
 scale_y_continuous(name="PC2") +
 facet_wrap(~ weight) +
 coord_fixed()
```


```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:26-SpatialResponseSurface.Rmd-->

# Introduction to kriging {#Introkriging}

In the following chapters a geostatistical model\index{Geostatistical model}, i.e. a statistical model of the spatial variation of the study variable, is used to optimise the sample size and/or spatial pattern of the sampling units. This is the core of model-based sampling. This chapter is a short introduction to geostatistical modelling.

In Chapter \@ref(MBpredictionofDesignVariance) we have already seen how a geostatistical model can be used to optimise probability sampling designs for estimating the population mean or total. In the following chapters the focus is on mapping. A map of the study variable is obtained by predicting the study variable at the nodes of a fine discretisation grid. Spatial prediction using a geostatistical model is referred to as kriging [@webster2007].

With this prediction method besides a map of the kriging predictions, a map of the variance of the prediction error is obtained. I show hereafter that this prediction error variance is not influenced by the values of the study variable at the sampling units. For that reason it is possible to search, before the start of the survey, for the sampling locations that lead to the minimum prediction error variance averaged over all nodes of a fine prediction grid, provided that the semivariogram is known.

The kriging predictions and prediction error variances are derived from a statistical model of the spatial variation of the study variable. There are several versions of kriging, building on different models of the spatial variation.  In *ordinary kriging*\index{Kriging!ordinary kriging} (OK) it is assumed that the mean of the study variable is constant, i.e. the same everywhere [@webster2007]:

\begin{eqnarray}
Z(\mathbf{s}) &=& \mu + \epsilon(\mathbf{s}) \notag \\
\epsilon(\mathbf{s}) &\sim& \mathcal{N}(0,\sigma^2) \\
\mathrm{Cov}(\epsilon(\mathbf{s}),\epsilon(\mathbf{s}^{\prime})) &=& C(\mathbf{h}) \notag \;,
(\#eq:OKmodel)
\end{eqnarray}

with $Z(\mathbf{s})$ the study variable  at location $\mathbf{s}$, $\mu$ the constant mean, independent of the location $\mathbf{s}$, $\epsilon(\mathbf{s})$ the error or residual (difference between study variable $z$ and mean $\mu$) at location $\mathbf{s}$, and $C(\mathbf{h})$ the covariance of $\epsilon$ at two points separated by vector $\mathbf{h} = \mathbf{s} - \mathbf{s}^{\prime}$. $C(\cdot)$ is the covariance function\index{Covariance function}, also referred to as the covariogram\index{Covariogram}, and a scaled version of it obtained by dividing $C(\cdot)$ by the variance $C(0)$, is the correlation function\index{Correlation function} or correlogram\index{Correlogram}. Stated otherwise, in ordinary kriging we assume *stationarity in the mean*\index{Stationarity in the mean} over the area to be mapped. The residuals are not independent, but spatially correlated. So if we have a large positive residual at some location $\mathbf{s}$, then in many cases we also have a positive residual at a nearby location $\mathbf{s}^{\prime}$.

If the data set is of substantial size, it is possible to specify that not all sample data be used to predict the study variable at a prediction location, but only the sample data in some predefined neighbourhood. This implies that the stationarity assumption is relaxed to the often more realistic assumption of a constant mean within neighbourhoods.

In ordinary kriging, the value of the study variable at a prediction location $\mathbf{s}_0$, $\widehat{Z}(\mathbf{s}_0)$, is predicted as a weighted average of the observations at the sampling locations within the neighbourhood:

\begin{equation}
\widehat{Z}_{\mathrm{OK}}(\mathbf{s}_0)=\sum_{i=1}^{n}\lambda_i \,Z(\mathbf{s}_i) \;,
(\#eq:weightedsumkriging)
\end{equation}

where $Z(\mathbf{s}_i)$ is the study variable at the $i^{\mathrm{th}}$ sampling location, and $\lambda _{i}$ is the weight attached to this location. The weights should be related to the strength of correlation of the study variable at the sampling location and the prediction location. Note that as the mean is assumed constant (Equation \@ref(eq:OKmodel)), the correlation of the study variable $Z$ is equal to the correlation of the residual $\epsilon$. Roughly speaking, the stronger this *autocorrelation*\index{Autocorrelation} (auto refers to the fact that the same variable is considered at both locations), the larger the weight must be. So if we have a model for this autocorrelation, then we can use this model to find the optimal weights. Further, if two sampling locations are very close, the weight attached to these two locations should not be twice the weight attached to a single, isolated sampling location at the same distance of the interpolation node. This explains that in computing the kriging weights, besides the covariances of the $n$ pairs of interpolation node and sampling location, also the covariances of the $n\cdot(n-1)/2$ pairs that can be formed with the $n$ sampling units are used. For OK, the optimal weights, i.e. the weights that lead to the model-unbiased\index{Model-unbiased}^[Model-unbiasedness is explained in Chapter \@ref(Approaches).] predictor with minimum error variance (best linear unbiased predictor\index{Best linear unbiased predictor}) can be found by solving the following $(n+1)$ equations:

\begin{equation}
\begin{array}{ccccc}
\sum\limits_{j=1}^{n}\lambda _{j}\,C(\mathbf{s}_1,\mathbf{s}_j)&+&\nu &=&C(\mathbf{s}_1,\mathbf{s}_0)\\
\sum\limits_{j=1}^{n}\lambda _{j}\,C(\mathbf{s}_2,\mathbf{s}_j)&+&\nu &=&C(\mathbf{s}_2,\mathbf{s}_0)\\
&&&\vdots\\
\sum\limits_{j=1}^{n}\lambda _{j}\,C(\mathbf{s}_n,\mathbf{s}_j)&+&\nu &=&C(\mathbf{s}_n,\mathbf{s}_0)\\
\sum\limits_{j=1}^{n}\lambda _{j}&&&=&1
\end{array} \;,
(\#eq:krigingequations)
\end{equation}

where $C(\mathbf{s}_i,\mathbf{s}_j)$ is the covariance of the $i$th and $j$th sampling location, $C(\mathbf{s}_i,\mathbf{s}_0)$ the covariance of the $i$th sampling location and the interpolation node $s_0$, and $\nu$ an extra parameter to be estimated, referred to as the Lagrange multiplier\index{Lagrange multiplier}. This Lagrange multiplier must be included in the set of equations because the error variance is minimised under the constraint that the kriging weights sum to one, see the final line in Equation \@ref(eq:krigingequations). This constraint ensures that the OK-predictor is model-unbiased.  
It is convenient to write this system of equations in matrix form:

\begin{eqnarray}
\left[
\begin{array}{ccccc}
C_{11}&C_{12}&\dots&C_{1n}&1\\
C_{21}&C_{22}&\dots&C_{2n}&1\\
\vdots&\vdots&\dots&\vdots&1\\
C_{n1}&C_{n2}&\dots&C_{nn}&1\\
1&1&\dots&1&0\\
\end{array}
\right]
\left[
\begin{array}{c}
\lambda_1\\
\lambda_2\\
\vdots\\
\lambda_n\\
\nu\\
\end{array}
\right]
=
\left[
\begin{array}{c}
C_{10}\\
C_{20}\\
\vdots\\
C_{n0}\\
1\\
\end{array}
\right]\;.
(\#eq:krigingeqsmatrix)
\end{eqnarray}

Replacing submatrices by single symbols results in the shorthand matrix equation:

\begin{eqnarray}
\left[
\begin{array}{cc}
\mathbf{C} & \mathbf{1} \\
\mathbf{1}^{\mathrm{T}} & 0 \\
\end{array}
\right]
\left[
\begin{array}{c}
\boldsymbol{\lambda}\\
\nu\\
\end{array}
\right]
=
\left[
\begin{array}{c}
\mathbf{c}_0\\
1\\
\end{array}
\right]\;.
(\#eq:OKsystemshort)
\end{eqnarray}

The kriging weights\index{Kriging weight} $\boldsymbol{\lambda}$ and the Lagrange multiplier $\nu$ can then be computed by premultiplying both sides of Equation \@ref(eq:OKsystemshort) with the inverse of the first matrix of this equation:

\begin{eqnarray}
\left[
\begin{array}{c}
\lambda\\
\nu\\
\end{array}
\right]
=
\left[
\begin{array}{cc}
\mathbf{C} & \mathbf{1} \\
\mathbf{1}^{\mathrm{T}} & 0 \\
\end{array}
\right]^{-1}
\left[
\begin{array}{c}
\mathbf{c}_0\\
1\\
\end{array}
\right]\;.
(\#eq:krigingweights)
\end{eqnarray}

The variance of the prediction error (ordinary kriging variance\index{Ordinary kriging variance}) at a prediction location equals

\begin{equation}
V_{\mathrm{OK}}(\widehat{Z}(\mathbf{s}_0))= \sigma^2 - \lambda^{\mathrm{T}}\mathbf{c}_0 - \nu \;,
(\#eq:OKvariance)
\end{equation}

with $\sigma^2$ the sill of the semivariogram (a priori variance\index{A priori variance}). This equation shows that the ordinary kriging variance is not a function of the data at the sampling locations. Given a covariance function it is fully determined by the coordinates of the sampling locations and of the prediction location. It is this property of kriging that makes it possible to optimise the grid-spacing, and as we will see in Chapter \@ref(MBSamplePattern) to optimise the spatial pattern of the sampling units, given a requirement on the kriging variance. If the kriging variance were a function of the data at the sampling locations, optimisation would be much more complicated.

Commonly the kriging variance is expressed in terms of the *semivariances*\index{Semivariance} between the sampling points and a prediction point (hereafter the relation between a covariance function and a semivariogram is explained):

\begin{equation}
V_{\mathrm{OK}}(\widehat{Z}(\mathbf{s}_0))= \lambda^{\mathrm{T}}\boldsymbol{\gamma}_0 + \nu \;,
(\#eq:OKvariancesemivariances)
\end{equation}

with $\boldsymbol{\gamma}_0$ the vector with semivariances between the sampling points and a prediction point.

Computing the kriging predictor requires a model for the covariance as a function of the vector separating two locations. Often the covariance is modelled as a function of the length of the separation vector only, so as a function of the Euclidian distance between two locations. We then assume isotropy\index{Isotropy}. In general practice, the covariance function is not used in kriging, rather, a semivariogram\index{Semivariogram}. A semivariogram is a model of the *dissimilarity* of the study variable at two locations. The dissimilarity is quantified by half the squared difference of the study variable values at two points. A covariance function and semivariogram are related by, see Figure \@ref(fig:CovFunctionVariogram):

\begin{equation}
\gamma(\mathbf{h}) = \sigma^2 - C(\mathbf{h})\;.
(\#eq:gammavscov)
\end{equation}

```{r CovFunctionVariogram, echo=FALSE, fig.asp=0.7, fig.cap="Spherical covariance function (red line and dot) and semivariogram (black line and dot)."}
library(gstat)
nugget<-25
psill<-75
range<-250
vgmodel<-vgm(model="Sph", nugget=nugget, psill=psill, range=range)
d <- variogramLine(vgmodel, maxdist=700, min=0.01)
cov <- variogramLine(vgmodel, maxdist=700, min=0.01, covariance=TRUE)
d$cov <- cov$gamma

x<-ycov<-ysemi<-numeric(length=2)
x<-c(0,0)
ycov<-c(psill,psill+nugget)
ysemi<-c(0,nugget)
xydf<-data.frame(x,ycov,ysemi)
ggplot() +
  geom_line(data=d,aes(x=dist, y=cov), colour="red", size=1)+
  geom_point(data=xydf, aes(x=x[1],y=ycov[1]), shape=1, size=3, colour="red")+
  geom_point(data=xydf, aes(x=x[2],y=ycov[2]), shape=16, size=3, colour="red")+
  geom_line(data=d, aes(x=dist, y=gamma), colour="black", size=1)+
  geom_point(data=xydf, aes(x=x[1], y=ysemi[1]), shape=16, size=3, colour="black")+
  geom_point(data=xydf, aes(x=x[2], y=ysemi[2]), shape=1, size=3, colour="black")+
  scale_x_continuous(name="Distance (m)", breaks=c(100,200,300,400,500,600,700)) +
  scale_y_continuous(name="Covariance, Semivariance\n")
```

Only authorized functions are allowed, ensuring that the variance of any linear combination of random variables, like the kriging predictor, is positive. Commonly used functions are an exponential, spherical and Mat$\acute{\text{e}}$rn model. 

The spherical semivariogram model\index{Spherical semivariogram model} has three parameters:  

1. Nugget\index{Nugget} ($c_0$): this is where the semivariogram crosses the y-axis (in Figure \@ref(fig:CovFunctionVariogram): 25).  
2. Partial sill\index{Partial sill} ($c_1$): the difference between the maximum semivariance and the nugget (in Figure \@ref(fig:CovFunctionVariogram): 75).  
3. Range\index{Range} ($\phi$): this is the distance at which the semivariance reaches its maximum (in Figure \@ref(fig:CovFunctionVariogram): 500 m). 

The formula for the spherical semivariogram is:

\begin{equation}
\gamma(h)=\left \{
\begin{array}{ll}
0      &\,\,\,\mathrm{if}\,\,\, h=0 \\
c_0+c_1\left[ 1-\frac{3}{2}\left( \frac{h}{\phi}\right) +\frac{1}{2}\left( \frac{h}{\phi}\right) ^{3}\right] &\,\,\,\mathrm{if}\,\,\, 0 < h \leq \phi \\
c_0+c_1     & \,\,\,\mathrm{if}\,\,\, h>\phi
\end{array}
\right.
(\#eq:spherical)
\end{equation}

The sum of the nugget and the partial sill is referred to as the sill\index{Sill} (or sill variance, or a priori variance\index{A priori variance}). An exponential semivariogram model\index{Exponential semivariogram model} also has three parameters. Its formula is

\begin{equation}
\gamma(h)=\left \{
\begin{array}{ll}
0      &\,\,\,\text{if}\,\,\, h=0 \\
c_0+c_1\; \mathrm{exp}(-h/\phi) &\,\,\,\text{if}\,\,\, h > 0 \\
\end{array}
\right.
(\#eq:exponential)
\end{equation}

In an exponential semivariogram the semivariance goes asymptotically to a maximum; it never reaches it. In an exponential semivariogram the range parameter is replaced by the distance parameter. In an exponential semivariogram without nugget the semivariance at three times the distance parameter is at 95\% of the sill. Three times the distance parameter is referred to as the *effective* or *practical* range. 

In following chapters I also use a correlogram\index{Correlogram}, which is a scaled covariance function, such that the sill of the correlogram equals one:

\begin{equation}
\rho(\mathbf{h}) = \frac{C(\mathbf{h})}{\sigma^2} \;.
(\#eq:correlogram)
\end{equation}

To illustrate that the ordinary kriging variance\index{Ordinary kriging variance} is independent of the values of the study variable at the sampling locations, I simulated a spatial population of 50 $\times$ 50 units. At each unit a value of the study variable is simulated, using the semivariogram of Figure \@ref(fig:CovFunctionVariogram). This is repeated ten times, resulting in ten simulated populations of 2500 units. Figure \@ref(fig:Twokrigingsimulations) shows two of the ten simulated populations. Note that the two simulations clearly show spatial structure (patches of similar values).

```{r, echo=FALSE}
s1 <- s2 <- seq(from=20, to=1000, by=20) - 10
mypop <- expand.grid(s1, s2)
names(mypop) <- c("s1","s2")

#Compute matrix with distances between grid nodes
H <- as.matrix(dist(mypop[,c(1,2)]))

C <- variogramLine(vgm(model="Sph", psill=psill, range=range, nugget=nugget), dist_vector=H, covariance=TRUE)
Upper <- chol(C) #Cholesky decomposition of covariance matrix

set.seed(314)
mu <- 50
Z <- matrix(nrow=nrow(mypop),ncol=10)
for (i in 1:10) {
  N <- rnorm(n=nrow(mypop), 0, 1) #simulate numbers from standard normal distribution
  Z[,i] <- crossprod(Upper,N)+mu
}
mypop <- cbind(mypop,Z)
```

```{r Twokrigingsimulations, echo=FALSE, out.width='100%', fig.cap="Two maps simulated with the spherical semivariogram of the figure above, centered square grid of sampling units, and prediction unit (red cell with coordinates (590,670))."}
#select square grid of 100 units
gridded(mypop) <- ~s1+s2
mysample <- spsample(x=mypop, type="regular", cellsize=c(100,100), offset=c(0.5,0.5)) %>% as(.,"data.frame")
mypop <- as(mypop,"data.frame")

#select prediction unit
s_0<-data.frame(s1=590, s2=670)

df <- mypop[,c("s1","s2","X1","X2")]
names(df)[c(3,4)] <- c("z1","z2")

df_lf <- df %>% pivot_longer(cols=c("z1","z2"))

ggplot(data=df_lf) +
  geom_tile(mapping=aes(x=s1, y=s2, fill=value)) +
  geom_tile(data=mysample, mapping=aes(x=x1, y=x2), width=20, height=20, size=0.6, colour="white", fill=NA) +
  geom_tile(data=s_0,mapping=aes(x=s1, y=s2), width=25, height=25, fill="red")+
  scale_fill_viridis_c(name="z") +
  scale_x_continuous(name="Easting") +
  scale_y_continuous(name="Northing") +
  facet_grid(~ name) +
  coord_fixed()
```

The simulated fields are sampled on a centered square grid with a spacing of 100 distance units, resulting in a sample of 100 units. Each sample is used one-by-one to predict the study variable at one prediction location (see Figure \@ref(fig:Twokrigingsimulations)), using again the semivariogram of Figure \@ref(fig:CovFunctionVariogram). The semivariogram is specified by function `vgm` of package **gstat** [@peb04]. Usually this semivariogram is estimated from a sample, see Chapter \@ref(SamplingVariogram), but here we assume that it is known. Function `krige` of package **gstat** is used for kriging. The formula argument specifies the dependent (study variable) and independent variables (covariates). The formula `z ~ 1` means that we do not have covariates, and that predictions are done by ordinary kriging (or simple kriging, see Section \@ref(IntroKED)). Argument `locations` is a file of class `SpatialPointsDataFrame` with the spatial coordinates and observations. Argument `newdata` is a file of class `SpatialPoints` with the locations where we want to predict. Argument `nmax` can be used to specify the number of nearest observations that should be used in kriging.  

```{r}
library(sp)
library(gstat)
vgmodel <- vgm(model="Sph", nugget=25, psill=75, range=500)
gridded(mypop) <- ~s1+s2
mysample <- spsample(
  x=mypop, type="regular", cellsize=c(100,100),
  offset=c(0.5,0.5))
zsim_sample <- over(mysample, mypop)
coordinates(s_0) <- ~s1+s2
zpred_OK <- v_zpred_OK <- NULL
for (i in 1:ncol(Z)) {
  mysample$z <- zsim_sample[,i]
  predictions <- krige(
    formula=z~1,
    locations=mysample,
    newdata=s_0,
    model=vgmodel,
    debug.level=0)
  zpred_OK[i] <- predictions$var1.pred
  v_zpred_OK[i] <- predictions$var1.var
}
```

As can be seen below, unlike the predicted value, the ordinary kriging variance produced from the different simulations is constant.

```{r OKpredandvar, echo=FALSE}
tbl <- data.frame(zpred_OK,v_zpred_OK)

knitr::kable(
  tbl, caption='Ordinary kriging predictions and kriging variance at a fixed prediction location for ten data sets with simulated values at a square grid.',
  col.names=c("Kriging prediction", "Kriging variance"),
  booktabs=TRUE
) %>%
  kable_classic()
```

## Block-kriging {#BlockKriging}

In the previous section the support of the prediction units is equal to that of the sampling units. So if the observations are done at points (point support\index{Point support}), the support of the predictions are also points. There is no change of support\index{Change of support}. In some cases we may prefer predictions at a larger support than that of the observations.  For instance, we may prefer predictions of the average concentration of some soil pollutant of blocks of 5 m $\times$ 5 m, instead of predictions at points, simply because of practical relevance. If the observations are at points, there is a change of support, from points to blocks. Kriging with a prediction support that is larger than the support of the sample data is referred to as block-kriging\index{Kriging!block-kriging}. Kriging without change of support, the sample support and prediction support are equal, is referred to as point-kriging\index{Kriging!point-kriging}.  Note that point-kriging does not necessarily imply that the support is a point, it can be, for instance, a small block.

In block-kriging the mean of a prediction block $\mathcal{B}_0$ is predicted as a weighted average of the observations at the sampling units. The kriging weights are derived much in the same way as in point-kriging (Equations \@ref(eq:krigingequations) to \@ref(eq:krigingweights)). In block-kriging the covariance between a sampling point $i$ and a prediction point, $C(\mathbf{s}_i,\mathbf{s}_0)$ is replaced by the *mean* covariance between the sampling point and a prediction block $\overline{C}(\mathbf{s}_i,\mathcal{B}_0)$ (Equation \@ref(eq:krigingequations)). This mean covariance can be approximated by discretising the prediction block by a fine grid, computing the covariance between a sampling point $i$ and each of the discretisation points, and averaging.

The variance of the prediction error of the block-mean (block-kriging variance\index{Block-kriging variance}) equals

\begin{equation}
V_{\mathrm{OBK}}(\widehat{\overline{Z}}(\mathcal{B}_0)) = \lambda^{\mathrm{T}}\bar{\boldsymbol{\gamma}}(\mathcal{B}_0) + \nu - \bar{\gamma}(\mathcal{B}_0,\mathcal{B}_0)\;,
(\#eq:OBKvariance)
\end{equation}

with $\bar{\boldsymbol{\gamma}}(\mathcal{B}_0)$ the vector with mean semivariances between the sampling points and a prediction block, and $\bar{\gamma}(\mathcal{B}_0,\mathcal{B}_0)$ the mean semivariance within the prediction block. Comparing this with the variance with point-kriging (Equation \@ref(eq:OKvariancesemivariances)) shows that the block-kriging variance is smaller than the point-kriging variance\index{Point-kriging variance} by an amount approximately equal to the mean semivariance within a prediction block\index{Mean semivariance!within prediction block}. Recall from Chapter \@ref(MBpredictionofDesignVariance) that the mean semivariance within a block is a model-based prediction of the variance within a block (Equation \@ref(eq:meansemivariance)).

## Kriging with an external drift {#IntroKED}

In kriging with an external drift\index{Kriging!kriging with an external drift} (KED) the spatial variation of the study variable is modelled as the sum of a linear combination of covariates and a spatially correlated residual:

\begin{eqnarray}
Z(\mathbf{s}) &=& \sum_{k=0}^p \beta_k x_k(\mathbf{s}) + \epsilon(\mathbf{s}) \notag \\
\epsilon(\mathbf{s}) &\sim& \mathcal{N}(0,\sigma^2)\\
\mathrm{Cov}(\epsilon(\mathbf{s}),\epsilon(\mathbf{s}^{\prime})) &=& C(\mathbf{h}) \notag \;,
(\#eq:KEDmodel2)
\end{eqnarray}

with $x_k(\mathbf{s})$ the value of the $k$th covariate at location $\mathbf{s}$ ($x_0$ = 1 for all locations), $p$ the number of covariates, and $C(\mathbf{h})$ the covariance of the residuals at two points separated by vector $\mathbf{h} = \mathbf{s}-\mathbf{s}^{\prime}$. The constant mean $\mu$ in Equation \@ref(eq:OKmodel) is replaced by a linear combination of covariates, and as a consequence the mean is not constant anymore, but varies in space.

With KED the study variable at a prediction location $\mathbf{s}_0$ is predicted by

\begin{equation}
\hat{Z}_{\mathrm{KED}}(\mathbf{s}_0)=\sum_{k=0}^p \hat{\beta}_k x_k(\mathbf{s}_0)+\sum_{i=1}^n \lambda_i\left[Z(\mathbf{s}_i)-\sum_{k=0}^p \hat{\beta}_k x_k(\mathbf{s}_i)\right]\;,
(\#eq:KEDpredictor)
\end{equation}

with $\hat{\beta}_k$ the estimated regression coefficient. The first component of this predictor is the estimated expectation at the new location using the covariate values at this location and the estimated regression coefficients, and the second component is a weighted sum of the residuals at the sampling locations.

The optimal kriging weights $\lambda_i, i = 1 \dots n$ are obtained in a similar way as in ordinary kriging. The difference is that additional constraints on the weights are needed, to ensure unbiased predictions. Not only the weights must sum to one, but also for all $p$ covariates the weighted sum of the covariate values at the sampling locations must equal the covariate value at the target location ($\sum_{i=1}^n \lambda_i x_k(\mathbf{s}_i) = x_k(\mathbf{s}_0)$ for all $k=1 \dots p$). This leads to a system of $n+p+1$ simultaneous equations that must be solved. In matrix notation this system is

\begin{eqnarray}
\left[
\begin{array}{cc}
\mathbf{C} & \mathbf{X} \\
\mathbf{X}^{\mathrm{T}} & \mathbf{0} \\
\end{array}
\right]
\left[
\begin{array}{c}
\boldsymbol{\lambda}\\
\nu\\
\end{array}
\right]
=
\left[
\begin{array}{c}
\mathbf{c}_0\\
\mathbf{x}_0\\
\end{array}
\right]\;,
(\#eq:KEDsystem)
\end{eqnarray}

with

\begin{eqnarray}
\mathbf{X}=
\left[
\begin{array}{ccccc}
1&x_{11}&x_{12}&\dots&x_{1p}\\
1&x_{21}&x_{22}&\dots&x_{2p}\\
\vdots&\vdots&\dots&\vdots\\
1&x_{n1}&x_{n2}&\dots&x_{np}\\
\end{array}
\right]\;.
\end{eqnarray}

The submatrix $\mathbf{O}$ is a $((p+1) \times (p+1))$ matrix with zeroes, $\nu$ a ($p+1$) vector with Lagrange multipliers, and $\mathbf{x}_0$ a $(p+1)$ vector with covariate values at the prediction location (including a 1 as the first entry).

The kriging variance with KED equals

\begin{equation}
V_{\mathrm{KED}}(\widehat{Z}(\mathbf{s}_0))= \sigma^2 - \lambda^{\mathrm{T}}\mathbf{c}_0 - \nu^{\mathrm{T}} \mathbf{x}_0 \;.
(\#eq:KEDvariance)
\end{equation}

The prediction error variance with KED can also be written as the sum of the variance of the predictor of the mean and the variance of the error in the interpolated residuals [@chr91]:

\begin{equation}
V(\widehat{Z}(\mathbf{s}_0))= \sigma^2 - \mathbf{c}_0^{\mathrm{T}}\mathbf{C}^{-1}\mathbf{c}_0 + (\mathbf{x}_0-\mathbf{X}^{\mathrm{T}}\mathbf{C}^{-1}\mathbf{c}_0)^{\mathrm{T}}(\mathbf{X}^{\mathrm{T}}\mathbf{C}^{-1}\mathbf{X})^{-1}(\mathbf{x}_0-\mathbf{X}^{\mathrm{T}}\mathbf{C}^{-1}\mathbf{c}_0)\;.
(\#eq:KEDvariance2)
\end{equation}

The first two terms constitute the interpolation error variance, the third term the variance of the predictor of the mean. Note that the computation is as Equation \@ref(eq:KEDvariance), with the $\lambda$ and $\nu$ from the solution of the KED system; Equation \@ref(eq:KEDvariance2) shows this in terms of linear modelling theory. 

To illustrate that the kriging variance with KED depends on the values of the covariate at the sampling locations and prediction location, values of a covariate $x$ and of a correlated study variable $z$ are simulated for the $50 \times 50$ units of a spatial population (Figure \@ref(fig:SimulatedXandZ)). First a field with covariate values is simulated. Then a field with residuals is simulated. The field of the study variable is then obtained by multiplying the simulated field with covariate values by two, adding a constant of 10, and finally adding the simulated field with residuals.

```{r, echo=FALSE}
mypop <- as(mypop,"data.frame")
mypop <- mypop[,c("s1","s2")] #remove column with z values
```

```{r}
#simulate covariate values
vgmdl_x <- vgm(model="Sph", psill=10, range=200, nugget=0)
C <- variogramLine(vgmdl_x, dist_vector=H, covariance=TRUE)
Upper <- chol(C) 
set.seed(314)
N <- rnorm(n=nrow(mypop),0,1)
mypop$x <- crossprod(Upper,N)+10
#simulate values for residuals
vgmdl_resi <- vgm(model="Sph", psill=5, range=100, nugget=0)
C <- variogramLine(vgmdl_resi, dist_vector=H, covariance=TRUE)
Upper <- chol(C)
set.seed(314)
N <- rnorm(n=nrow(mypop),0,1)
e <- crossprod(Upper,N)
#compute mean of study variable
betas <- c(10,2)
mu <- betas[1] + betas[2]*mypop$x
#compute study variable z
mypop$z <- mu  + e
```

As before, a centred square grid with a spacing of 100 distance units is selected. The simulated values of the study variable $z$ and covariate $x$ are used to predict $z$ at a prediction location $\mathbf{s}_0$ by kriging with an external drift (red cell in Figure \@ref(fig:SimulatedXandZ)). Although at the prediction location we have only one simulated value of covariate $x$, a series of covariate values is used to predict $z$ at that location: $x_0 = 0, 2, 4, \dots, 20$. In practice we have of course only one value of the covariate at a fixed location, but this is for illustration purposes only. Note that we have only one data set with `observations' of $x$ and $z$ at the sampling locations (square grid).

```{r SimulatedXandZ, echo=FALSE, out.width='100%', fig.cap="Maps with simulated values of covariate $x$ and study variable $z$, centered square grid of sampling units, and prediction unit (red cell with coordinates (590,670))."}
s_0 <- as(s_0,"data.frame")

plt1 <- ggplot(data=mypop) +
  geom_tile(mapping=aes(x=s1, y=s2, fill=x)) +
  geom_tile(data=as(mysample,"data.frame"), mapping=aes(x=x1, y=x2), width=20, height=20, size=0.6, colour="white", fill=NA) +
  geom_tile(data=s_0, mapping=aes(x=s1, y=s2), width=25, height=25, fill="red")+
  scale_fill_viridis_c(name="x") +
  scale_y_continuous(name="Northing") +
  scale_x_continuous(name="Easting") +
  coord_fixed()

plt2 <- ggplot(data=mypop) +
  geom_tile(mapping=aes(x=s1, y=s2, fill=z)) +
  geom_tile(data=as(mysample,"data.frame"), mapping=aes(x=x1, y=x2), width=20, height=20, size=0.6, colour="white", fill=NA) +
  geom_tile(data=s_0, mapping=aes(x=s1, y=s2), width=25, height=25, fill="red")+
  scale_fill_viridis_c(name="z") +
  scale_y_continuous(name="Northing") +
  scale_x_continuous(name="Easting") +
  coord_fixed()

grid.arrange(plt1, plt2, nrow=1)

coordinates(mypop) <- ~s1+s2
coordinates(s_0) <- ~s1+s2
```

```{r}
zxsim_sample <- over(mysample, mypop)
mysample$z <- zxsim_sample$z
mysample$x <- zxsim_sample$x
x0 <- seq(from=0, to=20, by=2)
v_zpred_KED <- NULL
for (i in 1:length(x0)) {
  s_0$x <- x0[i]
  predictions  <- krige(
    formula=z~x,
    locations=mysample,
    newdata=s_0,
    model=vgmdl_resi,
    debug.level=0)
  v_zpred_KED[i] <- predictions$var1.var
}
```

Note the formula `z~x` in the code chunk above, indicating that there is now an independent variable (covariate). The covariate values are attached to the file with the prediction location one-by-one in a for-loop. Also note that for KED we need the semivariogram of the residuals, not of the study variable itself. The residual semivariogram used in prediction is the same as the one used in simulating the fields: a spherical model without nugget, a sill of 5 and a range of 100 distance units.

To assess the contribution of the uncertainty about the mean, I also predict the values assuming that the mean is known. In other words we assume that the two regression coefficients $\beta_0$ (intercept) and $\beta_1$ (slope) are known. This type of kriging is referred to as simple kriging\index{Kriging!simple kriging} (SK). With SK the constraints explained above are removed, so that there are no Lagrange multipliers involved. Argument `beta` is used to specify the known regression coefficients. I used the same values as in simulation. 

```{r}
v_zpred_SK <- NULL
for (i in 1:length(x0)) {
  s_0$x <- x0[i]
  prediction  <- krige(
    formula=z~x, 
    locations=mysample, 
    newdata=s_0, 
    model=vgmdl_resi, 
    beta=betas, 
    debug.level=0)
  v_zpred_SK[i] <- prediction$var1.var
}
```

Figure \@ref(fig:KEDVarSKVar) shows that, contrary to the ordinary kriging variance,  the kriging variance with KED is not constant, but depends on the covariate value at the prediction location. It is the smallest near the mean of the covariate values at the sampling sites, which is 10.0. The more extreme the covariate value at the prediction location, the larger the kriging variance with KED. This is analogous to the variance of predictions with a linear regression model.

The variance with simple kriging (SK) is constant. This is because with SK only the error in the interpolation of the residuals contribute to the variance (first two terms in Equation \@ref(eq:KEDvariance2). This interpolation error is independent of the value of $x$ at the prediction location. In Figure \@ref(fig:KEDVarSKVar) the difference between the variance with KED and with SK is the variance of the predictor of the mean, due to uncertainty about the regression coefficients. These regression coefficients must be *estimated* from the sample data. 

```{r KEDVarSKVar, echo=FALSE, fig.asp=0.7, fig.cap="Variance of prediction error with kriging with an external drift (KED) and simple kriging (SK) as a function of the covariate value at a fixed prediction location."}
df<-data.frame(x0, KED=v_zpred_KED, SK=v_zpred_SK)
df_lf <- df %>% pivot_longer(.,cols=c("KED","SK"))
ggplot(df_lf) +
    geom_point(mapping=aes(x=x0, y=value, shape=name), size=3) +
    scale_shape_manual(values=c(1,2), name="Prediction") +
    scale_x_continuous(name="Covariate value at prediction location") +
    scale_y_continuous(name="Variance", limits=c(0,5))
```

## Estimating the semivariogram {#VariogramEstimation}

Kriging requires a semivariogram or covariance function as input for computing the covariance matrix of the study variable at the sampling locations and the vector of covariance of the study variable at the sampling locations and the prediction location. In most cases the semivariogram model is unknown and must be estimated from sample data; however it may be justified to use a semivariogram model developed in a similar study. Once the parameters of the semivariogram model are estimated, these are plugged in the kriging equations. There are two fundamentally different approaches for estimating the semivariogram parameters from sample data: the *method-of-moments*\index{Method-of-moments} and *maximum likelihood estimation*\index{Maximum likelihood estimation} [@lar00b].

### Method-of-moments {#MoM}

With the method-of-moments approach the semivariogram is estimated in two steps. In the first step a sample semivariogram\index{Sample semivariogram}, also referred to as an experimental semivariogram\index{Experimental semivariogram}, is estimated. This is done by choosing a series of distance intervals (bins)^[If a semivariogram in different directions is required we must also choose direction intervals]. For each distance interval all pairs of points with a separation distance\index{Separation distance} in that interval are identified. For each pair half the squared difference of the study variable is computed, and the average of these squared differences over all point-pairs of that interval is computed. This average is the estimated semivariance of that distance interval. The estimated semivariances for all distance intervals are plotted against the average separation distances per distance interval. In the second step a permissible model is fitted to the sample semivariogram, using some form of weighted least squares. For details, see @webster2007.

The next code chunk shows how this can be done in **R**.  A simple random sample of 150 points is selected from the first simulated field shown in Figure \@ref(fig:Twokrigingsimulations). Function `variogram` of package **gstat** is then used to compute the sample semivariogram. Note that no distance intervals need be specified to function `variogram`. This can be done with argument `width` or argument `boundaries`. In their absence, the default value for the argument `width` is equal to the maximum separation distance divided by fifteen, so that there are fifteen points in the sample semivariogram. The maximum separation distance can be set with the argument `cutoff`. The default value for this argument is equal to one-third of the longest diagonal of the bounding box of the point set. The output is a data frame, with the number of point-pairs, average separation distance and estimated semivariance in the first three columns.

```{r, echo=FALSE}
#Copy mypop to mypop_spdf, which is needed later
mypop_spdf <- mypop
mypop <- as(mypop,"data.frame")
mypop <- mypop[,c("s1","s2")] #remove column with x and z values
mypop$z <- Z[,1]
```

```{r samplevariogramSimulatedField1, fig.asp=0.7}
set.seed(123)
units <- sample.int(n=nrow(mypop), size=150)
mysample <- mypop[units,]
coordinates(mysample) <- ~s1+s2
vg <- variogram(z~1, data=mysample)
head(vg[,c(1,2,3)])
```

The next step is to fit a model. This can be done with function `fit.variogram` of the **gstat**  package. Many models can be fitted with this function (type `vgm()` to see all models). I chose a spherical model. Function `fit.variogram` requires initial values of the semivariogram parameters. From the sample semivariogram my eyeball estimates are 25 for the nugget, 250 for the range and 75 for the partial sill. These are specified to the `vgm` function, and used as the `model` argument to `fit.variogram`. The sample semivariogram and the fitted model can simply be plotted with function `plot`.

```{r semivariogramSimulatedField1, fig.asp=0.7}
vgm_MoM <- fit.variogram(
  vg, model=vgm(model="Sph", psill=75, range=250, nugget=25))
plot(vg, vgm_MoM, plot.numbers=TRUE)
print(vgm_MoM)
```

Note that `fit.variogram` has several options for weighted least squares optimisation, see `?fit.variogram` for details. Also, note that this non-linear fit may not converge to a solution, especially if the starting values specified to `vgm` are not near their optimal values.

Further, this method depends on the choice of cutoff and distance intervals. We hope that changing these does not change the fitted model too much, but this is not always the case, especially with smaller data sets.

### Maximum likelihood {#MLestimationVariogram}

In contrast to the method-of-moments, with the maximum likelihood method the data are not paired into couples and binned into a sample semivariogram. Instead the semivariogram model is estimated in one step. To apply this method one typically assumes that (possibly after transformation) the $n$ sample data come from a multivariate normal distribution\index{Multivariate normal distribution}. If we have one observation from a normal distribution, the probability density of that observation is given by

\begin{equation}
f(z|\mu,\sigma ^{2})=
\frac{1}{\sigma \sqrt{2\pi }}\exp \left\{ -\frac{1}{2}\left( \frac{z-\mu }{\sigma }\right) ^{2}\right\} \;,
(\#eq:densitynormal)
\end{equation}

with $\mu$ the mean and $\sigma^2$ the variance. With multiple independent observations, each of them coming from a normal distribution, the joint probability density is given by the product of the probability densities per observation. However, if the data are not independent we must account for the covariances, and the joint probability density can be computed with

\begin{equation}
f(\mathbf{z}|\boldsymbol{\mu} ,\boldsymbol{\theta})=
(2\pi )^{-\frac{n}{2}}|\mathbf{C}|^{-\frac{1}{2}}
\exp \left\{ -\frac{1}{2}(\mathbf{z}-\boldsymbol{\mu} )^{\mathrm{T}}\,\mathbf{C}^{-1}\,(\mathbf{z}-\boldsymbol{\mu} )\right\} \;,
(\#eq:densitymvnormal)
\end{equation}

where $\mathbf{z}$ is the vector with the $n$ sample data, $\boldsymbol{\mu}$ is the vector with means, $\boldsymbol{\theta}$ is the vector with parameters of the covariance function, and $\mathbf{C}$ is the $n \times n$ matrix with variances and covariances of the sample data. If the probability density of Equation \@ref(eq:densitymvnormal) is regarded as a function of $\boldsymbol{\mu}$ and $\boldsymbol{\theta}$ with the data $\mathbf{z}$ fixed, this equation defines the likelihood\index{Likelihood}. 

Maximum likelihood estimates of the semivariogram can be obtained with function `likfit` of package **geoR** [@geoR]. First a geoR object must be made, specifying in which columns of the data frame the spatial coordinates and the study variable are.

```{r}
library(geoR)
mysample <- as(mysample,"data.frame")
dGeoR <- as.geodata(
  obj=mysample, header=TRUE,
  coords.col=1:2, data.col=3)
```

The model parameters can then be estimated with function `likfit`. The argument `trend="cte"` means that we assume that the mean is constant throughout the study area.

```{r}
vgm_ML <- likfit(
  geodata=dGeoR, trend="cte", 
  cov.model="spherical", ini.cov.pars=c(80,200),
  nugget=20, lik.method="ML", messages=FALSE)
```

Table \@ref(tab:VariogramEstimates) shows the maximum likelihood estimates together with the method-of-moments estimates.

```{r VariogramEstimates, echo=FALSE}
tbl <- data.frame(
Parameter=c("nugget","partial sill", "range"), MoM=c(round(vgm_MoM$psill[1],1),round(vgm_MoM$psill[2],1),round(vgm_MoM$range[2],1)),
ML=c(round(vgm_ML$nugget,1),round(vgm_ML$sigmasq,1),round(vgm_ML$phi,1)))

knitr::kable(
  tbl, caption='Estimates of semivariogram parameters obtained with method-of-moments and maximum likelihood.',
  booktabs=TRUE
) %>%
  kable_classic()
```

As can be seen, the estimates are substantially different, especially the division of overall variance into partial sill and nugget.

## Estimating the residual semivariogram {#ResidualVariogram}

For KED estimates of the regression coefficients and of the parameters of the residual semivariogram are needed. Estimation of these model parameters is not a trivial problem, as the estimated regression coefficients and estimated residual semivariogram parameters are not independent. The residuals depend on the estimated regression coefficients, and as a consequence also the parameters of the residual semivariogram depend on the estimated coefficients. Vice versa, the estimated regression coefficients depend on the spatial correlation of the residuals, and so on the estimated residual semivariogram parameters. This a classic "which came first, the chicken or the egg?" recursive problem.

Estimation of the model parameters is illustrated with the simulated field of Figure \@ref(fig:SimulatedXandZ). A simple random sample of size 150 is selected to estimate the model parameters.

### Iterative method-of-moments {#IterativeMoM}

A simple option is iterative estimation of the regression coefficients followed by method-of-moments estimation of the sample semivariogram and fitting of a semivariogram model. In the first iteration the regression coefficients are estimated by ordinary least squares (OLS). This implies that the data are assumed independent, i.e. we assume a pure nugget residual semivariogram. The sample semivariogram of the OLS residuals is then computed by the method-of-moments, followed by fitting a model to this sample semivariogram. With package **gstat** this can be done with one line of **R** code, using in function `variogram` as an argument a formula specifying the study variable and the predictors.

```{r, echo=FALSE}
mypop <- mypop_spdf
```

```{r}
set.seed(314)
units <- sample.int(n=nrow(mypop), size=150)
mysample <- cbind(mypop[units,])
vg_resi <- variogram(z~x, data=mysample)
vgmdl <- vgm(model="Sph", psill=10, range=150, nugget=0)
vgmresi_MoM <- fit.variogram(vg_resi, model=vgmdl)
```

Given these estimates of the semivariogram parameters, the regression coefficients are re-estimated by accounting for spatial dependency of the residuals. This can be done by generalised least squares\index{Generalised least squares} (GLS). Function `spDists` of package **sp** is used to compute the matrix with distances between the sampling locations, `variogramLine` of package **gstat** to transform the distance matrix into a covariance matrix. The operator `%*%` is for multiplying two matrices.  Type `?<name of function>` for help about the functions `chol2inv`, `crossprod` and `solve`.

```{r}
X <- matrix(data=1, nrow=nrow(as(mysample, "data.frame")), ncol=2)
X[,2] <- mysample$x
z <- mysample$z
D <- spDists(mysample)
C <- variogramLine(vgmresi_MoM, dist_vector=D, covariance=TRUE)
Cinv <- chol2inv(chol(C))
XC <- crossprod(X, Cinv)
XCz <- XC%*%z
XCX <- XC%*%X
betaGLS <- solve(XCX, XCz)
```

The GLS estimates of the regression coefficients can then be used to re-compute the residuals of the mean, and so on, until the changes in the model parameters are negligible.

```{r}
repeat {
  betaGLS.cur <- betaGLS
  mu <- X%*%betaGLS
  mysample$e <- z-mu
  vg_resi <- variogram(e~1, data=mysample)
  vgmresi_MoM <- fit.variogram(vg_resi, model=vgmdl)
  C <- variogramLine(vgmresi_MoM, dist_vector=D, covariance=TRUE)
  Cinv <- chol2inv(chol(C))
  XC <- crossprod(X, Cinv)
  XCz <- XC%*%z
  XCX <- XC%*%X
  betaGLS <- solve(XCX, XCz)
  if (sum(abs(betaGLS-betaGLS.cur))<0.0001) {
    break
  }
}
```

Table \@ref(tab:ResidualVariogramEstimates) shows the estimates of the residual semivariogram parameters and regression coefficients, together with the estimates obtained by restricted maximum likelihood, which is explained in the next section.

### Restricted maximum likelihood {#REML}

The estimates of the residual semivariogram parameters obtained by the iterative method-of-moments\index{Iterative method-of-moments} procedure are not unbiased. When the mean is not constant but a linear combination of one or more covariates, also ML estimation results in biased estimates of the residual semivariogram parameters. Unbiased estimates of the regression coefficients and residual semivariogram parameters can be obtained by restricted maximum likelihood\index{Restricted maximum likelihood estimation} (also referred to as residual maximum likelihood), REML. In REML the vector with the data are premultiplied by a so-called projection matrix $\mathbf{P}$ [@Kitanidis1983]. This projection matrix has the property that a vector with zeroes is obtained when the matrix $\mathbf{X}$ with the covariate values at the sampling locations (and ones in first column) is pre-multiplied with $\mathbf{P}$:

\begin{equation}
\mathbf{P}\mathbf{X}=\mathbf{0} \;.
\end{equation}

Pre-multiplying both sides of the KED model (Equation \@ref(eq:KEDmodel2)) with $\mathbf{P}$ gives [@webster2007]

\begin{equation}
\mathbf{P}\mathbf{z}(\mathbf{s})=\mathbf{y}(\mathbf{s})=\mathbf{P}\mathbf{X}\boldsymbol{\beta} + \mathbf{P}\boldsymbol{\epsilon}(\mathbf{s})=\mathbf{P}\boldsymbol{\epsilon}(\mathbf{s}) \;.
\end{equation}

In words, by pre-multiplying the variable $\mathbf{z}$ with matrix $\mathbf{P}$ a new variable $\mathbf{y}$ is obtained that has a constant mean. So the trend is filtered out, whatever the regression coefficients are. The semivariogram parameters of this new variable can be estimated by ML. The projection matrix $\mathbf{P}$ can be computed with

\begin{equation}
\mathbf{P}=\mathbf{I}-\mathbf{X}(\mathbf{X}^{\mathrm{T}}\mathbf{X})^{-1}\mathbf{X}^{\mathrm{T}} \;,
\end{equation}

with  $\mathbf{I}$ the $n \times n$ identity matrix (matrix with ones on the diagonal, zeroes in all off-diagonal elements). The natural logarithm of the residual likelihood can be computed with [@lar06]

\begin{equation}
\ell(\boldsymbol{\theta}|\mathbf{z})=\mathrm{constant}-0.5(\mathrm{ln}|\mathbf{C}|+|\mathbf{X}^{\mathrm{T}}\mathbf{C}^{-1}\mathbf{X}|+\mathbf{y}^{\mathbf{T}}\mathbf{C}^{-1}(\mathbf{I-\mathbf{Q}})\mathbf{z})) \;,
\end{equation}

with $\mathbf{Q} = \mathbf{X}(\mathbf{X}^{\mathrm{T}}\mathbf{C}^{-1}\mathbf{X})^{-1}\mathbf{X}^{\mathrm{T}}\mathbf{C}^{-1}$

Restricted maximum likelihood estimates of the semivariogram can be obtained with function `likfit` of package **geoR**, used above in maximum likelihood estimation of the variogram [@geoR].

```{r, echo=FALSE}
library(geoR)
mysample <- as(mysample,"data.frame")
dGeoR <- as.geodata(
   obj=mysample, 
   header=TRUE, 
   coords.col=4:5, 
   covar.col=1,
   data.col=2
 )
```

```{r}
vgm_REML <- likfit(
  geodata=dGeoR, trend=~x,
  cov.model="spherical", ini.cov.pars=c(2,100),
  nugget=0, lik.method="REML", messages=FALSE)
```


```{r ResidualVariogramEstimates, echo=FALSE}
tbl <- data.frame(
Parameter=c("nugget","partial sill", "range","intercept","x"), iMoM=c(round(vgmresi_MoM$psill[1],3),round(vgmresi_MoM$psill[2],3),round(vgmresi_MoM$range[2],3),round(betaGLS[1],3),round(betaGLS[2],3)),
REML=c(round(vgm_REML$nugget,3),round(vgm_REML$sigmasq,3),round(vgm_REML$phi,3),round(vgm_REML$beta[1],3),round(vgm_REML$beta[2],3)))

knitr::kable(
  tbl, caption='Estimates of residual spherical semivariogram parameters and regression coefficients obtained with iterative method-of-moments (iMoM) and restricted maximum likelihood (REML).',
  booktabs=TRUE
) %>%
  kable_classic()
```

Table \@ref(tab:ResidualVariogramEstimates) shows that REML results in a smaller estimated (partial) sill and larger estimated range than iterative method-of-moments. Of the two regression coefficients especially the estimated intercept differs considerably among the two estimation methods. 

I realise that this is a rather short introduction to kriging. I refer to @isa89 for an introduction to geostatistics, to @goo97 for an expos$\acute{\text{e}}$ of the many versions of kriging, and to @webster2007 for an elaborate explanation of kriging. An nice educational tool for getting a feeling for ordinary kriging is [E{Z}-Kriging](https://wiki.52north.org/AI_GEOSTATS/SWEZKriging)^[https://wiki.52north.org/AI_GEOSTATS/SWEZKriging].

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:27-IntroKriging.Rmd-->

# Model-based optimisation of grid spacing {#MBgridspacing}

This is the first chapter on model-based sampling\index{Model-based sampling}^[Spatial response surface sampling can also be considered as model-based sampling, especially when a model-based criterion is used, see Chapter \@ref(SpatialResponseSurface.]. In Chapters \@ref(SpatialCoverage) and \@ref(kmeans) a geometric criterion was minimised, i.e. a criterion defined in terms of distances, either in geographic space (Chapter \@ref(SpatialCoverage)), or in covariate space (Chapter \@ref(kmeans)). In model-based sampling the minimisation criterion is a function of the variance of the prediction errors.

This first chapter on model-based sampling is about optimisation of the spacing of a regular grid, i.e. the distance between neighbouring points in the grid. In case the budget for the survey may not exceed a given amount, and the total costs can be approximated by the costs per point multiplied by the sample size, this spacing can be derived from the affordable sample size (Chapter \@ref(Regulargrid)). The larger the affordable sample size, the smaller the grid spacing. The alternative is to derive the grid spacing from a requirement on the accuracy of the map. Here and in following chapters I assume that the map is constructed by kriging, see Chapter \@ref(Introkriging) for an introduction. 

## Optimal grid spacing for ordinary kriging {#GridspacingOK}

Suppose that we require the mean kriging variance not to exceed a given threshold. The question then is what is the tolerable or maximum possible grid spacing given this requirement. For finding this tolerable grid spacing\index{Tolerable grid spacing} one must have prior knowledge of the spatial variation. I first consider the situation in which it is reasonable to assume that the mean of the study variable is constant throughout the study area, but unknown. With the mean unknown, this implies that ordinary kriging is used for mapping.  Further, we need a semivariogram of the study variable. In practice we often do not have a reliable estimate of the semivariogram. In the best case scenario we have some existing data, of sufficient quantity and suitable spatial distribution, that can be used to estimate the semivariogram. In other cases such data are lacking, and a best guess of the semivariogram must be made, for instance using data for the same study variable from other, similar areas.

There is no simple equation that relates the grid spacing to the kriging variance. What can be done is to calculate the mean kriging variance for a range of grid spacings, plot the mean kriging variances against the grid spacing, and use this plot inversely to determine the tolerable grid spacing, given a constraint on the mean ordinary kriging variance.

In the next code chunks this procedure is used to compute the tolerable spacing of a square grid for mapping soil organic matter (SOM) in the three woredas of Ethiopia. The legacy data used before to design a spatial infill sample (Chapter \@ref(SpatialCoverage)) are used here to estimate a semivariogram. A sample semivariogram is estimated by the method-of-moments, and a spherical model is fitted using functions of package **gstat** [@peb04]. Note that the values for the partial sill, range and nugget in the `model` argument of the function `fit.variogram` are guesses from an eyeball examination of the sample semivariogram obtained with the function  `variogram`, see Figure \@ref(fig:variogramSOMEthiopia). 

```{r}
library(gstat)
load(file="data/CovariatesThreeWoredasEthiopia.RData")
load(file="data/ThreeWoredasEthiopia.RData")
vg <- variogram(SOM~1, data=priordataEthiopia)
vgmdl <- vgm(model="Sph", psill=0.6, range=40, nugget=0.6)
vgm_MoM <- fit.variogram(vg, model=vgmdl)
```

```{r variogramSOMEthiopia, echo=FALSE, fig.asp=0.7, fig.cap="Sample semivariogram and fitted spherical model of SOM estimated from legacy data in three woredas of Ethiopia."}
fitted<-variogramLine(vgm_MoM,maxdist=60,n=1000)
ggplot(data=vg) +
  geom_point(mapping=aes(x=dist,y=gamma),size=3) +
  geom_smooth(data=fitted,mapping=aes(x=dist,y=gamma),colour="red") +
  scale_x_continuous(name= "Distance (km)") +
  scale_y_continuous(name= "Semivariance",limits=c(0,1.3))
```

The semivariogram of SOM can also be estimated by maximum likelihood using function `likfit` of package **geoR** [@geoR].

```{r}
library(geoR)
priordata <- as(priordataEthiopia,"data.frame")
dGeoR <- as.geodata(
  obj=priordata, header=TRUE,
  coords.col=13:14, data.col=1)
vgm_ML <- likfit(
  geodata=dGeoR, trend="cte",
  cov.model="spherical", ini.cov.pars=c(0.4,40),
  nugget=0.6, lik.method="ML", messages=FALSE)
```

Table \@ref(tab:VariogramEstimatesEthiopia) shows the maximum likelihood (ML) estimates of the parameters of the spherical semivariogram, together with the method-of-moments estimates. Either could be used in the following steps.

```{r VariogramEstimatesEthiopia, echo=FALSE}
tbl <- data.frame(Parameter=c("nugget","partial sill", "range"),MoM=c(round(vgm_MoM$psill,2),round(vgm_MoM$range[2],1)),ML=c(round(vgm_ML$nugget,2),round(vgm_ML$sigmasq,2),round(vgm_ML$phi,1)))

knitr::kable(
  tbl, caption = 'Method-of-moments and ML estimates of parameters of spherical semivariogram of SOM in Ethiopia.',
  booktabs = TRUE
) %>%
  kable_classic()
```

## Controlling the mean or a quantile of the ordinary kriging variance

To decide on the grid spacing we may require that the population mean of the kriging variance (MKV) not exceeds a given threshold. Instead of the population mean, we may use the population median or any other quantile, for instance the 0.90 quantile (P90) of the kriging variance as a quality criterion. Hereafter the ML semivariogram is used to optimise the grid spacing given a requirement on the mean, median and P90 of the kriging variance.

As a first step a series of spacings of the square grid with observations are specified. Only spacings are considered which would result in expected sample sizes that are reasonable for kriging. With a spacing of 5 km the expected sample size is 434 points, with a spacing of 12 km these are 75 points. 

```{r}
spacing <- 5:12
```

The next step is to select a simple random sample of evaluation points. It is important to select a large sample, so that the precision of the estimated population mean or quantile of the kriging variance will be high. The standard error of the estimated MKV can be estimated, see Chapter \@ref(SI), substituting the kriging variance at the sampling points for the study variable values.

```{r}
load(file="data/CovariatesThreeWoredasEthiopia.RData")
set.seed(314)
units <- sample.int(nrow(grdEthiopia), size=5000, replace=TRUE)
mysample <- grdEthiopia[units,]
mysample$s1 <- jitter(mysample$s1, amount=0.5)
mysample$s2 <- jitter(mysample$s2, amount=0.5)
```

The **R** code below shows the next steps. Given a spacing, a square grid with a fixed starting point is selected with function `spsample`, using argument `offset`. A dummy variable is added to the data frame, having value 1 at all grid points. So the predicted value will everywhere be 1, since an unbiased predictor, being a weighted sum (as in OK) of any single value, must be that value. However, we are not interested in the predicted value, but in the kriging variance only, and we have seen in Chapter \@ref(Introkriging) that the kriging variance is independent of the  observations. The maximum likelihood estimates of the semivariogram are used in function `vgm` of package **gstat** to define a semivariogram model of class `variogramModel` that can be handled by function `krige`. For each grid spacing the population mean, median and P90 of the kriging variance is estimated from the evaluation sample. The median and P90 can be computed with function `quantile` of the **stats** package.

```{r}
coordinates(mysample) <- ~s1+s2
gridded(grdEthiopia) <- ~s1+s2
MKV_OK <- P50KV_OK <- P90KV_OK <- samplesize <- 
  numeric(length=length(spacing))
vgm_ML_gstat <- vgm(
  model="Sph", nugget=vgm_ML$nugget, psill=vgm_ML$sigmasq,
  range=vgm_ML$phi)
for (i in 1:length(spacing)) {
  mygridxy <- spsample(
    x=grdEthiopia, cellsize=spacing[i],
    type="regular", offset=c(0.5,0.5))
  mygrid<-data.frame(s1=mygridxy$x1, s2=mygridxy$x2, dummy=1)
  samplesize[i] <- nrow(mygrid)
  coordinates(mygrid) <- ~s1+s2
  predictions  <- krige(
    formula=dummy~1,
    locations=mygrid,
    newdata=mysample,
    model=vgm_ML_gstat,
    nmax=100,
    debug.level=0)
  MKV_OK[i] <- mean(predictions$var1.var)
  P50KV_OK[i] <- quantile(predictions$var1.var,probs=0.5)
  P90KV_OK[i] <- quantile(predictions$var1.var,probs=0.9)
}
dfKV_OK <- data.frame(
  spacing, samplesize, MKV_OK, P50KV_OK, P90KV_OK)
```

The estimated mean and quantiles of the kriging variance are plotted against the grid spacing.

```{r MOKVvsSpacingEthiopia, echo=FALSE, fig.asp=0.7, fig.cap="Mean, median (P50) and 0.90 quantile (P90) of the ordinary kriging variance of predictions of SOM in three woredas of Ethiopia, as a function of the spacing of a square grid."}
names(dfKV_OK)[c(3,4,5)] <- c("Mean","P50","P90")
df <- dfKV_OK %>% pivot_longer(.,cols=c("Mean","P50","P90"))

ggplot(df) +
  geom_point(mapping=aes(x=spacing, y=value, shape=name), size=2) +
  scale_shape_manual(values=c(0,1,2), name="Criterion") +
  scale_x_continuous(name="Spacing (km)") +
  scale_y_continuous(name="Mean, median, P90 of kriging variance", limits=c(0.7,1))
```

The tolerable grid spacing for the three quality indices can be computed with function `approx` of the **base** package, as shown below for the median kriging variance\index{Median kriging variance}.

```{r}
spacing_tol_P50 <- approx(
  x=dfKV_OK$P50, y=dfKV_OK$spacing, xout=0.8)$y
```

```{r, echo=FALSE}
spacing_tol_Mean <- approx(x=dfKV_OK$Mean, y=dfKV_OK$spacing, xout=0.8)$y
spacing_tol_P90 <- approx(x=dfKV_OK$P90, y=dfKV_OK$spacing, xout=0.8)$y
```

For a mean kriging variance of 0.8 the tolerable grid spacing is `r round(spacing_tol_Mean,1)` km, for the median kriging variance this is `r round(spacing_tol_P50,1)`, which is somewhat larger, leading to a smaller sample size. The smaller grid spacing for the mean can be explained by the right-skewed distribution of the kriging variance, so that the mean is larger than the median. For the 0.90 quantile of the kriging variance the tolerable grid spacing is much smaller: `r round(spacing_tol_P90,1)`, leading to a much larger sample size.

#### Exercises {-}

1. Write an **R** script to determine the tolerable grid spacing so that the 0.50, 0.80 and 0.95 quantiles of the variance of ordinary kriging predictions of SOM in the three woredas of Ethiopia do not exceed 0.8. Estimate the semivariogram by the method-of-moments.   
2. In practice we are uncertain about the semivariogram. For that reason it can be wise to explore the sensitivity of the tolerable grid spacing for the semivariogram parameters. Increase the nugget parameter of the method-of-moments semivariogram by 5\%, and change the partial sill parameter so that the sill (nugget + partial sill) is unchanged. Compute the mean kriging variance for grid spacings of $5, 6, \dots, 12$ km.   
    +  Do the same by reducing the range of the method-of-moments semivariogram by 5\%. Reset the nugget and partial sill to their original values.  
    +  Plot the mean kriging variance with the original semivariogram, semivariogram with increased nugget and semivariogram with smaller range against the grid spacing. Explain the difference in tolerable grid spacings obtained with the three semivariograms.    
    +  Compute the tolerable grid spacings for the three semivariograms for a mean kriging variance of 0.85, and the corresponding expected sample sizes.  
    
## Optimal grid spacing for block-kriging

In the previous section the tolerable grid spacing is derived from a constraint on the mean, P50 or P90 of the error variances of predictions at points. The alternative is to put a constraint on the mean (P50, P90) of the error variances of the predicted means of blocks. These means can be predicted with block-kriging\index{Kriging!block-kriging} (Section \@ref(BlockKriging)). Block-kriging predictions can be obtained with function `krige` of package **gstat**, using argument `block`. In the code chunk below the means of 100 m $\times$ 100 m blocks are predicted by ordinary block-kriging. 

```{r}
MKV_OBK <- P50KV_OBK <- P90KV_OBK <-
  numeric(length=length(spacing))
for (i in 1:length(spacing)) {
  mygridxy <- spsample(
    x=grdEthiopia, cellsize=spacing[i],
    type="regular", offset=c(0.5,0.5))
  mygrid<-data.frame(s1=mygridxy$x1, s2=mygridxy$x2, dummy=1)
  samplesize[i] <- nrow(mygrid)
  coordinates(mygrid) <- ~s1+s2
  predictions  <- krige(
    formula=dummy~1,
    locations=mygrid,
    newdata=mysample,
    model=vgm_ML_gstat,
    block=c(0.1,0.1),
    nmax=100,
    debug.level=0)
  MKV_OBK[i] <- mean(predictions$var1.var)
  P50KV_OBK[i] <- quantile(predictions$var1.var,probs=0.5)
  P90KV_OBK[i] <- quantile(predictions$var1.var,probs=0.9)
}
dfKV_OBK <- data.frame(spacing, MKV_OBK, P50KV_OBK, P90KV_OBK)
```

Figure \@ref(fig:MOBKVvsSpacingEthiopia) shows that the mean, P50 and P90 of the block-kriging predictions are substantially smaller than those of the point-kriging predictions (Figure \@ref(fig:MOKVvsSpacingEthiopia)). This can be explained by the large nugget of the semivariogram (Table \@ref(tab:VariogramEstimatesEthiopia)). The side length of a prediction block (100 m) is much smaller than the range of the variogram (`r round(vgm_ML$phi,1)` km), so that in this case the mean semivariance within a prediction block is about equal to the nugget. Roughly speaking, given a grid spacing the mean point-kriging variance is reduced by an amount about equal to this means semivariance, to yield the mean block-kriging variance for this spacing (Section \@ref(BlockKriging)). Recall that the mean semivariance within a block is a model-based prediction of the variance within a block (Equation \@ref(eq:meansemivariance)).

```{r MOBKVvsSpacingEthiopia, echo=FALSE, fig.asp=0.7, fig.cap="Mean, median (P50) and 0.90 quantile (P90) of the ordinary block-kriging variance of predictions of the mean SOM of blocks of 100 m by 100 m, in three woredas of Ethiopia, as a function of the spacing of a square grid."}
names(dfKV_OBK)[c(2,3,4)] <- c("Mean","P50","P90")
df <- dfKV_OBK %>% pivot_longer(.,cols=c("Mean","P50","P90"))

ggplot(df) +
  geom_point(mapping=aes(x=spacing, y=value, shape=name), size=2) +
  scale_shape_manual(values=c(0,1,2), name="Criterion") +
  scale_x_continuous(name="Spacing (km)") +
  scale_y_continuous(name="Mean, median, P90 of block-kriging variance")
```

## Optimal grid spacing for kriging with an external drift {#MBgridspacingKED}

In the previous section I assumed a constant mean for the study variable. I now consider the case where covariates that are related to the study variable are available. A model is calibrated that is the sum of a linear combination of the covariates (spatial trend) and a spatially structured residual, see Equation \@ref(eq:KEDmodel2). Predictions at the nodes of a fine grid are obtained by kriging with an external drift (KED).

The SOM data of the three woredas of Ethiopia are used to estimate the parameters (regression coefficients and residual semivariogram parameters) of the model by restricted maximum likelihood\index{Restricted maximum likelihood estimation} (REML), see Section \@ref(REML).

```{r}
library(geoR)
dGeoR <- as.geodata(
  obj = priordata, header=TRUE,
  coords.col=13:14, data.col=1,
  covar.col=c(3,9,10,11))
vgm_REML <- likfit(
  geodata=dGeoR, trend=~dem+rfl_NIR+rfl_red+lst,
  cov.model="spherical", ini.cov.pars=c(1,5),
  nugget=0.2, lik.method="REML", messages=FALSE)
```
```{r VariogramREMLEthiopia, echo=FALSE}
tbl <- data.frame(Parameter=c("nugget","partial sill", "range"),ML=c(round(vgm_ML_gstat$psill,2),round(vgm_ML_gstat$range[2],1)),REML=c(round(vgm_REML$nugget,2),round(vgm_REML$sigmasq,2),round(vgm_REML$phi,1)))

knitr::kable(
  tbl, caption = 'Maximum likelihood estimates of parameters of spherical semivariogram of SOM, and restricted maximum likelihood estimates of residual semivariogram of SOM in Ethiopia.',
  booktabs = TRUE
) %>%
  kable_classic()
```

The total sill (partial sill + nugget) of the residual semivariogram equals `r as.character(round(tbl$REML[1]+tbl$REML[2], 2))`, which is considerably smaller than that of the ML semivariogram of SOM (Table \@ref(tab:VariogramREMLEthiopia)). A considerable part of the variance of SOM is explained by the covariates. Note the much smaller range of the residual semivariogram. So the spatial structure of SOM is largely captured by the covariates. The residuals of the mean, which is a linear combination of the covariates, do not show much spatial structure anymore.

The mean kriging variance as obtained with KED is used as the evaluation criterion. With KED the kriging variance is also a function of the values of the covariates at the sampling locations and prediction location (Section \@ref(IntroKED)). Compared to the procedure above for ordinary kriging, in the code chunk below a slightly different procedure is used. The square grid of a given spacing is randomly placed on the area (option `offset` in function `spsample` is not used), and this is repeated several times.

```{r, eval=FALSE}
r <- 10
MKV_KED <- matrix(nrow=length(spacing), ncol=r)
vgm_REML_gstat <- vgm(
  model="Sph", nugget=vgm_REML$nugget,
  psill=vgm_REML$sigmasq, range=vgm_REML$phi)
set.seed(314)
for (i in 1:length(spacing)) {
  for (j in 1:r) {
    mygridxy <- spsample(x=grdEthiopia, cellsize=spacing[i],
                         type="regular")
    mygrid <- data.frame(s1=mygridxy$x1, s2=mygridxy$x2, dummy=1)
    coordinates(mygrid) <- ~s1+s2
    mygrd <- data.frame(over(mygrid, grdEthiopia), mygrid)
    coordinates(mygrd) <- ~s1+s2
    predictions <- krige(
      formula=dummy~dem+rfl_NIR+rfl_red+lst,
      locations=mygrd,
      newdata=mysample,
      model=vgm_REML_gstat,
      nmax=100,
      debug.level=0)
    MKV_KED[i,j] <- mean(predictions$var1.var)
  }
}
dfKV_KED <- data.frame(spacing,MKV_KED)
```

```{r, eval=FALSE, echo=FALSE}
save(dfKV_KED,file="results/MKEDVarvsGridspacing_Ethiopia.RData")
```

Figure \@ref(fig:MKEDVvsSpacingEthiopia) shows the mean kriging variances obtained with kriging with an external drift and with ordinary kriging, as a function of the grid spacing.

```{r MKEDVvsSpacingEthiopia, echo=FALSE, fig.asp=0.7, fig.cap="Mean kriging variance of SOM predictions with KED and OK, in three woredas of Ethiopia, as a function of the spacing of a square grid. With KED for each spacing ten MKV values are shown corresponding with ten randomly placed grids."}
load(file="results/MKEDVarvsGridspacing_Ethiopia.RData")
dfKV_KED$OK <- dfKV_OK$Mean
df <- dfKV_KED %>% pivot_longer(.,cols=names(dfKV_KED)[-1])
df$name <- as.factor(df$name)
library(forcats)
df$name <- fct_collapse(df$name, KED=c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10"))

ggplot(data=df) +
  geom_point(mapping=aes(x=spacing, y=value, shape=name), size=2, alpha=0.5) +
  scale_shape_manual(values=c(1,2), name="Prediction") +
  scale_x_continuous(name="Spacing (km)") +
  scale_y_continuous(name="Mean kriging variance",limits=c(0.7,0.9))
```

Interestingly for grid spacings smaller than about nine km, the mean kriging variance with KED is larger than with OK. So in this case only for larger grid spacings KED outperforms OK in terms of the mean kriging variance, and only for a mean kriging variances larger than about 0.8, we can afford with KED a larger grid spacing (smaller sample size) than with OK. 

```{r}
MMKV_KED <- apply(dfKV_KED[,-1], MARGIN=1, FUN=mean)
spacing_tol_KED <- approx(x=MMKV_KED, y=dfKV_KED$spacing, xout=0.8)$y
```

The tolerable grid spacing for a mean kriging variance of 0.8, using KED, equals `r round(spacing_tol_KED,1)` km.

#### Exercises {-}

3. Given a grid spacing the mean kriging variance varies among randomly selected grids, especially for large spacings. Explain why.   
4. Write an **R** script to compute the tolerable grid spacing for kriging with an external drift of natural logarithms of the electrical conductivity of the soil (ECe150) in the Cotton Research Farm of Uzbekistan, using natural logarithms of EMv100cm measurements as a covariate. Use the estimated parameters of an exponential semivariogram of the residuals, as shown  in Table \@ref(tab:TableVariogramsCRF4). Select a simple random sample of size 1,000 of evaluation points from the discretisation grid with interpolated lnEMv1m values (available in file `data/CottonResearchFarm.RData`) to compute the mean kriging variance. Do this by selecting 100 grid cells by simple random sampling with replacement, and jittering the centers of the selected grid cells  by an amount equal to half the size of the grid cell. Use as grid spacings 70, 75, $\dots$, 100 m. With a spacing of 100 m the number of grid points is about 100 (the farm has an area of about 97 ha). What is the tolerable grid spacing for a mean kriging variance of lnECE150 of 0.1605?

## Bayesian approach {#BayesianGridSpacing}

In practice we do not know the semivariogram. In the best case we have prior data that can be used to estimate the semivariogram. However, even in this case we are uncertain about the semivariogram type (spherical, exponential, etc.) and the semivariogram parameters. @Lark2017 showed how in a Bayesian approach\index{Bayesian approach!to grid spacing determination} we can account for uncertainty about the semivariogram parameters when we must decide on the grid spacing. In this approach a prior distribution of the semivariogram parameters is updated with the sample data to a posterior distribution [@Gelman2013]:

\begin{equation}
f(\boldsymbol{\theta}|\mathbf{z}) = \frac{f(\boldsymbol{\theta}) f(\mathbf{z}|\boldsymbol{\theta})} {f(\mathbf{z})}\;,
(\#eq:BayesRule)
\end{equation}

with $f(\boldsymbol{\theta}|\mathbf{z})$ the posterior distribution function, i.e. the probability density function of the semivariogram parameters given the sample data, $f(\boldsymbol{\theta})$ our prior belief\index{Prior belief} in the parameters specified by a probability density function, $f(\mathbf{z}|\boldsymbol{\theta})$ the likelihood\index{Likelihood} of the data, and $f(\mathbf{z})$ the probability density function of the data. This probability density function $f(\mathbf{z})$ is hard to obtain.

Problems with analytical derivation of the posterior distribution are avoided by selecting a large sample of units (vectors with semivariogram parameters) from the posterior distribution  through Markov chain Monte Carlo (MCMC) sampling\index{Markov chain Monte Carlo sampling}, see Section \@ref(MBpredSamplingVarBayes). 

In a Bayesian approach we must define the likelihood function of the data, see Section \@ref(MLestimationVariogram). I assume that the SOM data in the Ethiopia case study have a multivariate normal distribution, and that the spatial covariance of the data can be modelled by a spherical function, see  Section \@ref(MLestimationVariogram). The likelihood function is already defined in Section \@ref(MBpredSamplingVarBayes). The likelihood is a function of the semivariogram parameters. Given a vector of semivariogram parameters, the variance-covariance matrix of the data is computed from the matrix with geographic distances between the sampling points. Function `spDists` of package **sp** is used to compute this distance matrix.

```{r, echo=FALSE}
library(mvtnorm)
ll <-function(thetas) {
  sill <- 1/thetas[1]
  psill <- thetas[2]*sill
  nugget <- sill-psill
  vgmodel <- vgm(
    model=model, psill=psill, range=thetas[3],
    nugget=nugget)
  C <- variogramLine(vgmodel, dist_vector=D, covariance=TRUE)
  Cinv <- chol2inv(chol(C))
  XC <- crossprod(X, Cinv)
  XCz <- XC%*%z
  XCX <- XC%*%X
  betahat <- solve(XCX, XCz)
  mu <- as.numeric(X%*%betahat)
  logLik <- dmvnorm(x=z, mean=mu, sigma=C, log=TRUE)
  logLik
}
```

```{r}
D <- spDists(priordataEthiopia)
```

Besides the likelihood function, in a Bayesian approach we must define prior distributions for the semivariogram parameters. Here we combine the partial sill and nugget into *ratio of spatial dependence*\index{Ratio of spatial dependence}, i.e. the proportion of the total sill attributable to the partial sill.  This terminology is because the proportion attributable to the nugget has no spatial structure. For the ratio of spatial dependence $\xi$ and the distance parameter $\phi$ I chose  uniform distributions as priors, with lower bounds equal to 0 and $10^{-6}$, respectively, and upper bounds of one for the ratio of spatial dependence and 100 km for the range. A uniform distribution for the sill is not recommended [@Gelman2013]. Instead, I assume a uniform distribution for the *inverse* of the sill, with a lower bound of $10^{-6}$ wt\%$^2$, and an upper bound of 2 wt\%$^2$.

These priors can be defined by function `createUniformPrior`  of package **BayesianTools** [@Hartig2018]. There are also functions to define a beta density function (commonly used as a prior for proportions) and a truncated normal distribution as a prior. The function `createBayesianSetup` is then used to define the setup of the MCMC sampling, specifying the likelihood function, the prior, and the vector with best prior estimates of the model parameters, specified with argument `best`. The maximum likelihood estimates computed in Section \@ref(GridspacingOK) are used as starting values for the inverse of the sill parameter, the ratio of spatial dependence, and the range.

```{r}
library(BayesianTools)
priors <- createUniformPrior(
  lower = c(1E-6,0,1E-6), upper = c(2,1,100))
sill_ML <- vgm_ML$psill[1]+vgm_ML$psill[2]
thetas_ML <- c(1/sill_ML,vgm_ML$psill[2]/sill_ML,vgm_ML$range[2])
model <- "Sph"
setup <- createBayesianSetup(
  likelihood=ll, prior=priors,
  best=thetas_ML, names=c("lambda","xi","range"))
```

A sample from the posterior distribution of the semivariogram parameters is then obtained with function `runMCMC`. Various sampling algorithms are implemented in package **BayesianTools**. The algorithm can be specified with argument `sampler`. I used the default sampler `Dezs`, which is based on differential evolution Markov chain [@terBraak2008]. It is common not to use all sampled units, but to discard the units of the burn-in period that are possibly influenced by the initial arbitrary settings, and to thin the series of units after this period. The extraction of the ultimate sample is done with function `getSample`. Argument `start` specifies the unit where the extraction starts, and argument `numSamples` specifies how many units are selected through systematic sampling of the full MCMC sample. The alternative is to use argument `thin` which defines the thinning interval.

```{r, eval=FALSE}
set.seed(314)
res <- runMCMC(setup, sampler="DEzs")
mcmcsample <- getSample(res, start=1000, numSamples=1000) %>%
  as.data.frame(.)
```

```{r, eval=FALSE, echo=FALSE}
save(mcmcsample, file="results/MCMC_Ethiopia.RData")
```

Table \@ref(tab:MCMCSampleVariogram) shows the first ten units of the MCMC sample from the posterior distribution of the semivariogram parameters.

```{r MCMCSampleVariogram, echo=FALSE}
load(file="results/MCMC_Ethiopia.RData")
tbl <- mcmcsample[1:10,]
tbl$lambda <- round(tbl$lambda,3)
tbl$xi <- round(tbl$xi,3)
tbl$range <- round(tbl$range,1)

knitr::kable(
  tbl, caption = 'First ten units of MCMC sample from posterior distribution of  parameters of spherical semivariogram for SOM.',
  col.names=c("Inverse of sill", "Ratio of spatial dependence", "Range"),
  booktabs = TRUE
) %>%
  kable_classic()
```

The units of the MCMC sample (vectors with semivariogram parameters) are used one-by-one to compute the average of the kriging variances at the simple random sample of evaluation points.  

```{r, echo=FALSE, eval=FALSE}
spacing <- 1:12
MKV <- matrix(nrow=length(spacing),ncol=nrow(mcmcsample))
for (i in 1:length(spacing)) {
  mygridxy <- spsample(x=grdEthiopia,cellsize=spacing[i],type="regular",offset=c(0.5,0.5))
  mygrid <- data.frame(s1=mygridxy$x1,s2=mygridxy$x2,dummy=1)
  coordinates(mygrid) <- ~s1+s2
  for (j in 1:nrow(mcmcsample)) {
    sill <- 1/mcmcsample$lambda[j]
    vgm_ML$psill[2] <- mcmcsample$xi[j]*sill
    vgm_ML$psill[1] <- sill-vgm_ML$psill[2]
    vgm_ML$range[2] <- mcmcsample$range[j]
    predictions  <- krige(
      formula=dummy~1,
      locations=mygrid,
      newdata=mysample,
      model=vgm_ML,
      nmax=100,
      debug.level=0)
    MKV[i,j] <- mean(predictions$var1.var)
  }
}
save(MKV,file="results/MOKV_Bayesian_Ethiopia.RData")
```

```{r, echo=FALSE}
grdEthiopia <- as(grdEthiopia,"data.frame")
```

```{r, echo=FALSE}
load(file="results/MOKV_Bayesian_Ethiopia.RData")
spacing <- 1:12
MKV_target <- 0.8
spacing_tol <- numeric(length=ncol(MKV))
for (i in 1:ncol(MKV)) {
  spacing_tol[i] <- approx(x=MKV[,i], y=spacing, xout=MKV_target)$y
}
```

For each unit in the MCMC sample the tolerable grid spacing is computed for a target MKV of 0.8. Figure \@ref(fig:HistogramTolerableSpacing) shows that the grid spacing with the largest number of MCMC samples equals 8 km, which corresponds with the tolerable grid spacing derived above for ordinary kriging. For `r as.character(sum(is.na(spacing_tol)))` units in the MCMC sample the tolerable grid spacing exceeds 12 km. However this grid spacing leads to a sample size that is too small for estimating the semivariogram and kriging.

```{r HistogramTolerableSpacing, echo=FALSE, fig.asp=0.7, fig.cap="Histogram of tolerable grid spacings for a targeted MKV of 0.8."}
spacing_tol <- spacing_tol[!is.na(spacing_tol)]

ggplot() +
   geom_histogram(mapping=aes(spacing_tol), binwidth=1, fill="black", alpha=0.5, colour="black") +
   scale_x_continuous(name="Tolerable grid spacing", breaks=1:12) +
   scale_y_continuous(name="# MCMC samples")
```

Finally, for each grid spacing, the proportion of MCMC samples with a MKV smaller or equal to the target MKV of 0.8 is computed. Figure \@ref(fig:ProportionMCMCSamples) shows, for instance, that if we require a probability of 80\% that the MKV does not exceed the target MKV of 0.8, the tolerable grid spacing is about 6.25 km. With a grid spacing of 8 km as determined before, the probability that the MKV exceeds 0.8 is about 57\%.

```{r ProportionMCMCSamples, echo=FALSE, fig.asp=0.7, fig.cap="Proportion of MCMC samples with a MKV smaller than or equal to a target MKV of 0.8."}
CF <- numeric(length=length(spacing))
for (i in 1:length(spacing)) {
  CF[i] <- sum(MKV[i,] < MKV_target)
}
CF <- CF/ncol(MKV)
df <- data.frame(spacing,CF)
ggplot(df) +
  geom_line(mapping=aes(x=spacing,y=CF),colour="red") +
  scale_x_continuous(breaks=spacing,name="Grid spacing") +
  scale_y_continuous(limits=c(0,1),breaks=seq(from=0,to=1,by=0.2),name="Proportion of MCMC samples")
```

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:28-ModelBasedGridSpacing.Rmd-->

# Model-based optimisation of sampling pattern {#MBSamplePattern}

In Chapter \@ref(MBgridspacing) a model of the spatial variation was used to optimise the spacing of a regular  grid. The grid spacing determines the number of grid points within the study area, so optimisation of the grid spacing is equivalent to optimisation of the sample size.

This chapter is about optimisation of the spatial coordinates of the sampling units *given the sample size*. So we are searching for the optimal locations of a fixed number of sampling units. The constraint of sampling on a regular grid is dropped. In general, the optimal spatial pattern is irregular. Similar to spatial coverage sampling (Chapter \@ref(SpatialCoverage)), we search for the optimal sampling locations through minimisation of an explicit criterion. In spatial coverage sampling the minimisation criterion is the mean squared shortest distance (MSSD), which was minimised by *k*-means. In this chapter the minimisation criterion is the mean kriging variance (MKV). *k*-means cannot be used for minimising MKV as it uses (standardised) distances between cluster centers (the sampling locations) and the nodes of a discretisation grid, and the kriging variance is not a simple linear function of these distances. The kriging system also takes into account the separation between sampling points. A different optimisation algorithm is needed. Here spatial simulated annealing\index{Simulated annealing} (SSA) is used. This is an optimisation approach that mimics the gradual cooling of metal alloys, resulting in an optimum or near-optimum structure of the atoms in the alloy.

## Spatial simulated annealing {#SSA}

Inspired by the potentials of optimisation through simulated annealing [@Kirkpatrick1983], @vgr98 proposed to optimise the sampling locations by spatial simulated annealing (SSA), see also @vgr99 and @vgr00. This is an iterative, random search procedure, in which a sequence of samples is generated. A new sample (proposed sample) is obtained by slightly modifying the current sample. One sampling location of the current sample is randomly selected, and this location is shifted to a random location within the neighbourhood of the selected location.

The minimisation criterion is computed for the proposed sample and compared wth that of the current sample. If the criterion of the proposed sample is smaller, it is accepted. If the criterion is larger, the proposed sample is accepted with a probability equal to

\begin{equation}
P = e^{\frac{-\Delta}{T}}\;,
(\#eq:AcceptanceProb)
\end{equation}

with $\Delta$ the increase of the criterion, and $T$ the "temperature" which is one of the annealing schedule parameters^[The name of this parameter shows the link with annealing in metallurgy. Annealing is a heat treatment of a material above its recrystalisation temperature.]. The larger the value of $T$, the larger the probability that a proposed sample with a given increase of the criterion is accepted (Figure \@ref(fig:AcceptanceProbabilitySSA)). The temperature $T$ is stepwise decreased during the optimisation: $T_{k+1} = \alpha T_k$. In Figure \@ref(fig:AcceptanceProbabilitySSA) $\alpha$ equals 0.9. The effect of decreasing the temperature is that the acceptance probability of worse samples decreases during the optimisation and approaches 0 towards the end of the optimisation. Note that the temperature remains constant during a number of iterations, referred to as the chain length\index{Chain length}. In Figure \@ref(fig:AcceptanceProbabilitySSA) this chain length equals 100 iterations. Finally, a stopping criterion is required. Various stopping criteria are possible; one option is to set the maximum numbers of chains with no improvement. 

```{r AcceptanceProbabilitySSA, echo=FALSE, out.width='100%', fig.asp=0.4, fig.cap="Acceptance probability as a function of the change in the mean kriging variance (MKV) which is used as a minimisation criterion, and cooling schedule in spatial simulated annealing. For negative changes (MKV of proposed sample smaller than of current sample) the acceptance probability equals 1."}
dMKV <- seq(from=0.0001, to=0.05, by=0.0001)
T1 <- 0.01
pr01 <- exp(-dMKV / T1)
T2 <- 0.001
pr001 <- exp(-dMKV / T2)
df <- data.frame(dMKV,pr01,pr001)

plt1 <- ggplot(data=df) +
    geom_line(mapping=aes(x=dMKV, y=pr01)) +
    geom_line(mapping=aes(x=dMKV, y=pr001), colour="red") +
    scale_x_continuous(name="MKV-proposal - MKV-current") +
    scale_y_continuous(name="Acceptance probability") +
    annotate("text", label="T=0.01", x=0.015, y=0.375, size=3) +
    annotate("text", label="T=0.001", x=0.005, y=0.125, size=3, colour="red")

iter <- 1:1000
chain <- rep(1:10,each=100)
alpha <- 0.9
t <- numeric(length=10)
t[1] <- 1
for (i in 2:10) {
  t[i] <- t[i-1]*alpha
}
Tmp <- rep(t,each=100)
df <- data.frame(iter=iter,Tmp=Tmp)

plt2 <- ggplot(df) +
  geom_point(mapping=aes(x=iter ,y=Tmp) ,size=1) +
  scale_x_continuous(name="Iteration", breaks=seq(from=0, to=1000, by=100)) +
  scale_y_continuous(name="Temperature (T)", limits=c(min(df$T),1), breaks=round(unique(df$T),3))

grid.arrange(plt1, plt2, nrow=1)
```

## Optimising the sample pattern for ordinary kriging {#SamplePatternOK}

In ordinary kriging we assume a constant mean. No covariates are available that are related to the study variable. Optimisation of the sampling locations for ordinary kriging is illustrated with the Cotton Research Farm in Uzbekistan, which was used before to illustrate spatial response surface sampling (Chapter \@ref(SpatialResponseSurface)). The spatial coordinates of 50 sampling locations are optimised for mapping of the electrical conductivity (ECe) of the soil by ordinary kriging. In this section the coordinates of the sampling points are optimised for ordinary kriging. In Section \@ref(SamplePatternKED) hereafter this is done for kriging with an external drift, and a map of electromagnetic induction (EM) is used to further optimise the coordinates of the sampling points. 

Model-based optimisation of the sampling locations for ordinary kriging requires as input a semivariogram of the study variable. For the Cotton Research Farm I used the ECe data collected in eight surveys in the years 2008 - 2011 at 142 points to estimate this semivariogram. The ECe data are natural log transformed. The sample semivariogram is shown in Figure \@ref(fig:variogramlnECe). The **R** code below shows how I fitted the semivariogram model with function `nls` ("non-linear least squares") of the **stat** package. I did not use function `fit.variogram` of the **gstat** package, because this function requires the output of the function `variogram` as input, whereas the sample semivariogram is here computed in a different way^[The sample semivariogram is computed by first estimating sample semivariograms for each of the eight surveys separately, followed by computing weighted averages of semivariances and distances per lag, using the numbers of pairs as weights.]. The semivariogram parameters as estimated by `nls` are then used to define a semivariogram model of class `variogramModel` of package **gstat**, using function `vgm`. This is done because the function `optimMKV` requires a semivariogram model of this class, see hereafter. As already mentioned before in Chapter \@ref(MBgridspacing), in practice we often do not have legacy data from which we can estimate the semivariogram, and a best guess of the semivariogram then must be made.


```{r variogramlnECe, echo=FALSE, fig.asp=0.7, fig.cap="Sample semivariogram and fitted exponential model of natural logarithms of soil salinity (ECe) for the Cotton Research Farm in Uzbekistan."}
library(gstat)
#read calibration data
clbdat <- read.csv(file="data/ECEM_CRF.csv", header=TRUE)

#estimate semivariogram of ln(ECe)
clbdat$lnECe <- log(clbdat$ECe150)
coordinates(clbdat) <- ~ x * y
proj4string(clbdat) <- CRS("+proj=longlat +datum=WGS84")
clbdat <- spTransform(clbdat, CRS=CRS("+proj=tmerc +lat_0=0.000000000 +lon_0=63.000000000 +k=1.000000 +x_0=500000.000 +y_0=0.000 +ellps=krass +units=m"))
clbdat <- as.data.frame(clbdat)
minx <- min(clbdat$x)
miny <- min(clbdat$y)
clbdat$x <- clbdat$x-minx
clbdat$y <- clbdat$y-miny

timesteps <- unique(clbdat$t)
boundaries <- seq(from=0, to=500, by=50)

np <- d <- gamma <- matrix(nrow=length(boundaries)-1, ncol=length(timesteps))
for (i in 1:length(timesteps)) {
    # take subset
    sdat <- clbdat[clbdat$t == timesteps[i], ]
    coordinates(sdat) <- ~x+y
    variogram <- variogram(sdat$lnECe ~ 1, data=sdat, boundaries=boundaries)

    id <- findInterval(x=variogram$dist, vec=boundaries, rightmost.closed=TRUE, all.inside=TRUE)
    np[id,i] <- variogram$np
    d[id,i] <- variogram$dist
    gamma[id,i] <- variogram$gamma
}

#Pool the time-specific spatial variograms into 1 spatial variogram
somnp <- rowSums(np,na.rm=TRUE)

npd <- np*d
h <- rowSums(npd,na.rm=TRUE)/somnp

npgamma <- np*gamma
semivar <- rowSums(npgamma,na.rm=TRUE)/somnp
res <- nls(semivar~nugget+psill*(1-exp(-h/range)), start=list(nugget=0.1, psill= 0.4, range=200), weights=somnp)

fitted <- coef(res)[1]+coef(res)[2]*(1-exp(-h/coef(res)[3]))
df <- data.frame(h,semivar,fitted)
ggplot(data=df) +
  geom_point(mapping=aes(x=h ,y=semivar), size=3) +
  geom_smooth(mapping=aes(x=h, y=fitted), colour="red") +
  scale_x_continuous(name= "Distance (m)") +
  scale_y_continuous(name= "Semivariance", limits=c(0,0.55))
```

```{r}
library(gstat)
res <- nls(
  semivar~nugget+psill*(1-exp(-h/range)),
  start=list(nugget=0.1, psill=0.4, range=200),
  weights=somnp)
vgm_lnECe <- vgm(
  model="Exp", nugget=coef(res)[1],
  psill=coef(res)[2], range=coef(res)[3])
```

The estimated semivariogram parameters are shown in Table \@ref(tab:TableVariogramsCRF4). The nugget-to-sill ratio\index{Nugget-to-sill ratio} is about 1/4, and the effective range\index{Effective range} is about 575 m (three times the distance parameter of an exponential model).

The coordinates of the sampling points are optimised with function `optimMKV` of package **spsann** [@Alessandro2016]. First, the candidate sampling points are specified by the nodes of a grid discretising the population. As explained hereafter, this does not necessarily imply that the population is treated as a finite population. Next, the parameters of the annealing schedule are set. Note that both the initial acceptance rate and the initial temperature are set, which may seem weird as the acceptance rate is a function of the initial temperature, see Equation \@ref(eq:AcceptanceProb). The initial acceptance rate is used as a threshold value. If an initial temperature is chosen that leads to an acceptance rate smaller than the chosen value for the initial acceptance rate, then the optimisation stops. In this case a larger value for the initial temperature must be chosen. The arguments `chain.length` and `stopping` of function `scheduleSPSANN` are multipliers. So for a chain length of five, the number of iterations equals $5\; n$, with $n$ the sample size. During the optimisation a sample is perturbed by replacing one randomly selected point of the current sample by a new point. This is done by two-stage cluster sampling. In the first stage one node of the selected sampling grid (specified with argument `candi`) is randomly selected. Only the nodes within a neighbourhood defined by `x.min`, `x.max`, `y.min` and `y.max` can be selected. The nodes within this neighbourhood have equal probability of being selected. In the second stage one point is selected within a grid cell with the selected node at its center, and a side length specified by argument `cellsize`. So it is natural to set `cellsize` to the spacing of the sampling grid. Only with `cellsize=0` the population is finite, and the sampling points are restricted to the nodes of the sampling grid.

```{r}
library(spsann)
load(file="data/CottonResearchFarm.RData")
candi <- EM_CRF[,c(1,2)]
names(candi) <- c("x","y")
schedule <- scheduleSPSANN(
  initial.acceptance=0.8,
  initial.temperature=0.002, temperature.decrease=0.95,
  chains=500, chain.length=5, stopping=20,
  x.min=0, y.min=0, cellsize=25)
```

The **R** code for optimising the coordinates of the sampling points is as follows.

```{r, eval=FALSE}
set.seed(314)
rslt <- optimMKV(
  points=50, candi=candi,
  vgm=vgm_lnECe, eqn=z~1,
  schedule=schedule,
  plotit=FALSE, track=TRUE)
mysample <- candi[rslt$points$id,]
trace <- rslt$objective$energy
```

```{r, eval=FALSE, echo=FALSE}
save(mysample, trace, file="results/MBSample_OK_Uzbekistan.RData")
```

The spatial pattern of the sample in Figure \@ref(fig:ModelBasedSampleOK) and the trace of the MKV in Figure \@ref(fig:TraceMOKV) suggest that we are close to the global optimum.

```{r ModelBasedSampleOK, echo=FALSE, out.width='100%', fig.cap="Sample optimised with the mean variance of ordinary kriging predictions of lnECe (Model-based), and spatial coverage sample (SCS) from the Cotton Research Farm in Uzbekistan."}
library(spcosa)
load(file="results/MBSample_OK_Uzbekistan.RData")

s0 <- EM_CRF #this grid is constructed in SpatialResponseSurface.Rmd
gridded(s0) <- ~x1+x2
set.seed(314)
myStrata <- stratify(s0, nStrata=50, equalArea=FALSE, nTry=10)
myspcsample <- spsample(myStrata) %>% as(.,"data.frame")

names(mysample) <- names(myspcsample)
mysamples <- rbind(mysample,myspcsample)
mysamples$design <- rep(c("Model-based","SCS"))

ggplot(data=mysamples) +
  geom_raster(data=EM_CRF, mapping=aes(x=x1/1000, y=x2/1000), fill="grey") +
  geom_point(data=mysample, mapping=aes(x=x1/1000, y=x2/1000), size=1, colour="black") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  facet_wrap(~ design) +
  coord_fixed()
  
myspcsample$dummy <- 1
coordinates(myspcsample)<- ~x1+x2
#compute mean kriging variance of spatial coverage sample
predictions  <- krige(
  formula=dummy ~ 1,
  locations=myspcsample,
  newdata=s0,
  model=vgm_lnECe,
  nmax=50,
  debug.level=0)
MKV <- mean(predictions$var1.var)
myspcsample <- as(myspcsample, "data.frame")
```

```{r TraceMOKV, echo=FALSE, fig.asp=0.6, fig.cap="Trace of mean ordinary kriging variance."}
ggplot(trace) +
  geom_line(mapping=aes(x=1:nrow(trace), y=obj)) +
  scale_x_continuous(name="Iteration") +
  scale_y_continuous(name="Mean kriging variance")
```

For comparison I also computed a spatial coverage sample of the same size. The spatial patterns of the two samples are quite similar (Figure \@ref(fig:ModelBasedSampleOK)). The MKV of the spatial coverage sample equals `r as.character(round(MKV,4))`, whereas for the model-based sample this MKV equals `r as.character(round(trace$obj[nrow(trace)],4))`. So a small gain in precision is achieved only by the model-based optimisation of the sampling locations compared to spatial coverage sampling. This result is in agreement with the results reported by @bru07c.

Instead of the mean of the ordinary kriging variance (MOKV), we may prefer to use some quantile of the frequency distribution of the ordinary kriging variance as a minimisation criterion. For instance, if we use the 0.90 quantile as criterion, we are searching for the sampling locations so that the 90th percentile (P90) of the ordinary kriging variance is minimal. This can be done with function `optimUSER` of package **spsann** [@Alessandro2016]. This function has an argument `fun` that can be used to specify the objective function\index{Objective function} to be minimised. In this case the objective function is as follows.

```{r}
QOKV <- function(points, esample, model, nmax, prob) {
  points <- as.data.frame(points)
  coordinates(points) <- ~x+y
  points$dum=1
  res <- krige(
    formula=dum~1,
    locations=points,
    newdata=esample,
    model=model,
    nmax=nmax,
    debug.level=0)
  quantile(res$var1.var, probs=prob)
}
```

The next code chunk shows how this objective function can be minimised.

```{r, eval=FALSE}
myevalsample <- candi
coordinates(myevalsample) <- ~x+y
set.seed(314)
rslt <- optimUSER(
  points=50, candi=candi,
  fun=QOKV,
  esample=myevalsample,
  model=vgm_lnECe,
  nmax=20, prob=0.9,
  schedule=schedule)
```

Argument `esample` specifies a `SpatialPoints` object with the evaluation points\index{Evaluation point}, i.e. the points at which the kriging variance is computed. Here I used all candidate sampling points as evaluation points. Computing time can be reduced by selecting a coarser square grid with evaluation points, see Chapter \@ref(Regulargrid). Argument `nmax` specifies the number of points used in kriging, and `prob` is the cumulative probability of the kriging variance quantile. As we will see in the next exercise, the nugget of the residual semivariogram has a strong effect on the optimised sample pattern\index{Sample pattern}, stressing the importance of a reliable prior estimate this semivariogram parameter. 

#### Exercises {-}

1. Write an **R** script to optimise the coordinates of sixteen points in a square for ordinary kriging. First create a discretisation grid of 20 $\times$ 20 nodes. Use an exponential semivariogram without nugget, with a sill of 2 and a distance parameter of four times the spacing of the discretisation grid. Optimise the locations with spatial simulated annealing (using functions `scheduleSPSANN` and `optimMKV` of package **spsann**).  
    + Check whether the optimisation has converged by plotting the trace of the optimisation criterion MKV.  
    + Based on the coordinates of the sampling points, do you think this is the global optimum, i.e. the sample with the smallest possible MKV?  
2. Write an **R** script to optimise the coordinates of 50 points, using the P90 of the variance of ordinary kriging predictions of lnECe on the Cotton Research Farm as a minimisation criterion. Use the semivariogram parameters of Table  \@ref(tab:TableVariogramsCRF4). 
    + Compare the optimised sample with the sample optimised with the mean ordinary kriging variance (shown in Figure \@ref(fig:ModelBasedSampleOK)).  

## Optimising the sample pattern for kriging with an external drift {#SamplePatternKED}

If we have one or more covariates that are linearly related to the study variable, the study variable can be mapped by kriging with an external drift\index{Kriging!kriging with an external drift} (KED). A requirement is that we have maps of the covariate so that, once we have estimated the parameters of the model for KED from the data collected at the optimised sample, these covariate maps can be used to map the study variable.

Optimisation of the sampling locations for KED requires as input the semivariogram of the residuals. Besides, we must decide on the covariates for the mean. Note that we do not need as input estimates of the regression coefficients associated with the covariates, just which combination of covariates we want to use for modelling the mean of the study variable, and as said before, the values of these covariates at the prediction locations.

Optimisation of the sampling locations for KED is illustrated with the Cotton Research Farm. The interpolated natural logarithm of the EM data is used as a covariate, see Figure \@ref(fig:EMdataUzbekistan). The data for fitting the model are in data file `clbdat`. The parameters of the residual semivariogram are estimated by REML, see Section \@ref(REML). 

At several points multiple observations have been made; these data have exactly the same spatial coordinates. This leads to problems with REML estimation (covariance matrix not positive definite so that it cannot be inverted). To solve this problem I jittered the coordinates of the sampling points by a very small amount.

<!-- Note that in the next chunk I use EM as measured at the calibration sites (ECEM_CRF.csv) to fit the regression model and to compute the residuals. Ideally the interpolated EM values in data/CottonResearchFarm.RData (obtained by ordinary kriging of EM data in TransectsData_EM_CRF.csv) at the calibration sites are used as a covariate. However, the EM measurements in  the transects are at one time only, whereas the calibration data consist of simultaneous EM and EC measurements at multiple times. Therefore, to keep it simple, I used the EM data at the calibration sites -->

```{r}
library(geoR)
clbdat$lnEM100 <- log(clbdat$EMv1m)
clbdat$x <- jitter(clbdat$x, amount=0.001)
clbdat$y <- jitter(clbdat$y, amount=0.001)
dGeoR <- as.geodata(
  obj=clbdat, header=TRUE,
  coords.col=17:18, data.col=16, covar.col=19)
vgm_REML <- likfit(
  geodata=dGeoR, trend=~lnEM100,
  cov.model="exponential", ini.cov.pars=c(0.1,200),
  nugget=0.1, lik.method="REML", messages=FALSE)
```

The REML estimates of the parameters of the residual semivariogram\index{Residual semivariogram}  are shown in Table \@ref(tab:TableVariogramsCRF4). The estimated sill of the residual semivariogram is substantially smaller than that of lnECe and the range is somewhat shorter, showing that the linear model explains a considerable part of the spatial variation.

```{r TableVariogramsCRF4, echo=FALSE}
nugget <- c(round(coef(res)[1], 3), round(vgm_REML$nugget, 3))
psill <- c(round(coef(res)[2], 3), round(vgm_REML$sigmasq, 3))
range <- c(round(coef(res)[3], 0), round(vgm_REML$phi, 0))

variable <- c("lnECe","residuals")
coefs <- data.frame(variable,nugget,psill,range)
rownames(coefs)<-c()

knitr::kable(
  coefs, caption='Fitted parameters of exponential semivariogram for natural logarithm of ECe (estimated by MoM) and of residuals (estimated by REML).',
  booktabs=TRUE,col.names=c("Variable","Nugget","Partial sill", "Distance parameter (m)")
) %>%
  kable_classic()
```


```{r, echo=FALSE}
schedule <- scheduleSPSANN(
  initial.acceptance=0.8,
  initial.temperature=0.0006,
  temperature.decrease=0.9,
  chains=500,
  chain.length=10,
  stopping=10,
  x.min=0,y.min=0,
  cellsize=25)

vgm_REML_gstat <- vgm(
  nugget=vgm_REML$nugget,
  psill=vgm_REML$sigmasq,
  model="Exp",
  range=vgm_REML$phi)
```

To optimise the locations for KED, using the mean KED variance as a minimisation criterion, a data frame with the covariates at the candidate sampling locations must be assigned to the argument `covars`. The argument `eqn` specifies the KED model as a formula.

```{r, eval=FALSE}
covars <- EM_CRF
set.seed(314)
rslt <- optimMKV(
  points=50, candi=candi, covars=covars,
  vgm=vgm_REML_gstat, eqn=z~lnEM100cm,
  schedule=schedule,
  plotit=FALSE, track=FALSE)
```

```{r, echo=FALSE, eval=FALSE}
mysample <- candi[rslt$points$id,]
ids <- as.integer(rownames(mysample))
mysample$lnEM100cm <- covars[ids,3]
trace <- rslt$objective$energy
save(mysample,trace,file="results/MBSample_KED_Uzbekistan.RData")
```

Figure \@ref(fig:ModelBasedSampleKED) shows the optimised locations of a sample of 50 points. This clearly shows the irregular spatial pattern of the sampling points induced by the covariate. 

```{r ModelBasedSampleKED, echo=FALSE, fig.cap="Optimised sampling locations for kriging with an external drift of lnECe at the Cotton Research Farm in Uzbekistan, using lnEM as a covariate."}
load(file="results/MBSample_KED_Uzbekistan.RData")

covars <- EM_CRF

ggplot(data=covars) +
  geom_raster(mapping=aes(x=x1/1000, y=x2/1000,fill=lnEM100cm)) +
  geom_point(data=mysample, mapping=aes(x=x/1000, y=y/1000), size=2,colour="black") +
  scale_fill_continuous(name="lnEM100cm",type= "viridis") +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()
```

Comparing the population and sample histograms of the covariate clearly shows that locations with either small or large values for the covariate are preferentially selected (Figure \@ref(fig:histogramslnEM)). The optimised sample pattern is a compromise between spreading in geographic space and feature space, see also @heu07 and @bru07. More precisely, locations are selected by spreading them out throughout the study area, while accounting for the values of the covariates at the selected locations, in a way that locations with covariate values near the minimum and maximum are preferred. This can be explained by noting that the variance of the KED prediction error can be decomposed into two components: the variance of the interpolated residuals and the variance of the predictor of the mean, see Section \@ref(IntroKED). The contribution of the first variance component is minimised through geographical spreading, that of the second component by selecting locations with covariate values near the minimum and maximum.

```{r histogramslnEM, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap="Sample and population histograms of lnEM, used as covariate in model-based optimisation of sampling locations for mapping with KED."}
plt1 <- ggplot(data=mysample) +
  geom_histogram(mapping=aes(x=lnEM100cm), breaks=seq(from=2.75, to=5, by=0.25), fill="black", alpha=0.5, color="black") +
  ggtitle("Sample")+
  theme(plot.title=element_text(size=10, hjust=0.5))

plt2 <- ggplot(data=EM_CRF) +
  geom_histogram(mapping=aes(x=lnEM100cm), breaks=seq(from=2.75,to=5, by=0.25), fill="black", alpha=0.5, color="black") +
  ggtitle("Population") +
  theme(plot.title=element_text(size=10, hjust=0.5))

grid.arrange(plt1, plt2, nrow=1)
```

When one or more covariates are used in sample optimisation, but not used in KED once the data are collected, the sample is suboptimal for the model used in prediction. Inversely, ignoring a covariate in sample optimisation while using this covariate as a predictor also leads to suboptimal samples.

Further, note that a sample with covariate values close to the minimum and maximum only is not desirable if we do not want to rely on the assumption of a linear relation between the study variable and the covariates. To identify a non-linear relation, locations with intermediate covariate values are needed. Optimisation using a semivariogram with clear spatial structure leads to geographical spreading of the sampling units, so that most likely also locations with intermediate covariate values will be selected.

#### Exercises {-}

3. Write an **R** script to optimise the coordinates of sixteen points in a square for kriging with an external drift. Use the $x$-coordinate as a covariate. First create a discretisation grid of 20 $\times$ 20 nodes. Use an exponential residual semivariogram without nugget, with a sill of 2 and a distance parameter of four times the spacing of the discretisation grid. Optimise the locations with spatial simulated annealing (using functions `scheduleSPSANN` and `optimMKV` of package **spsann**)  
    + What do you think of the spatial coverage of the optimised sample?  Compare the sample with the optimised sample for ordinary kriging, see exercise of Section \@ref(SamplePatternOK)   
    + Repeat the optimisation using a residual semivariogram, with a nugget of 1.5 and a partial sill of 0.5. Note that the sill is again 2, as before  
    + Compare the optimised sample with the previous sample. What is the most striking difference? 
    + How will the optimised sample look like with a pure nugget semivariogram? Check your assumption by using such semivariogram in spatial simulated annealing. 

## Model-based infill sampling

Similar to spatial infill sampling using MSSD as a minimisation criterion (Section \@ref(SpatialInfill)), we may design a model-based infill sample\index{Model-based infill sampling}. Package **spsann** can be used for this, using argument `points` of function `optimMKV`. 

The legacy data are used to estimate the parameters of a spherical semivariogram by maximum likelihood, see Section \@ref(MLestimationVariogram).

```{r}
library(geoR)
load(file="data/CovariatesThreeWoredasEthiopia.RData")
load(file="data/ThreeWoredasEthiopia.RData")
priordata <- as(priordataEthiopia, "data.frame")
dGeoR <- as.geodata(
   obj=priordata, header=TRUE, 
   coords.col=13:14, data.col=1)
vgm_ML <- likfit(
  geodata=dGeoR, trend="cte", cov.model="spherical",
  ini.cov.pars=c(0.4,40), nugget=0.6,
  lik.method="ML", messages=FALSE)
```

In the next code chunk a list is created, containing a data frame (or matrix) with the coordinates of the fixed points (specified with sub-argument `fixed`), and an integer of the number of additional points to be selected (specified with sub-argument `free`). The list is assigned to argument `points` of function `optimMKV`. For kriging I slightly reduced the number of legacy points by keeping one point only per grid cell of  1 km $\times$ 1 km. This is done with function `remove.duplicates` of package **sp**.

```{r}
library(sp)
load(file="data/ThreeWoredasEthiopia.RData")
legacy <- remove.duplicates(
  priordataEthiopia, zero=1, remove.second=TRUE)
pnts <- list(fixed=coordinates(legacy), free=100)
candi <- grdEthiopia[,c(1,2)]
names(candi) <- c("x","y")
```


```{r, echo=FALSE}
schedule <- scheduleSPSANN(
  initial.acceptance=0.8, initial.temperature=0.0025,
  temperature.decrease=0.9, chains=300, chain.length=2,
  stopping=5, x.min=0, y.min=0, cellsize=1)
```

With numerous legacy points computing time can be reduced with argument `nmax`, which is passed to **gstat** function `krige`.

```{r, eval=FALSE}
set.seed(314)
vgm_ML_gstat <- vgm(
  model="Sph", psill=vgm_ML$sigmasq,
  range=vgm_ML$phi, nugget=vgm_ML$nugget)
rslt <- optimMKV(
  points=pnts, candi=candi,
  vgm=vgm_ML_gstat, eqn=z~1,
  nmax=20, schedule=schedule, track=FALSE)
ids <- which(rslt$points$free==1)
infillSample <- rslt$points[ids,]
```

```{r, eval=FALSE, echo=FALSE}
save(rslt, file="results/MBInfillSample_OK_Ethiopia.RData")
```

Figure \@ref(fig:ModelBasedInfill) shows a model-based infill sample of 100 points for ordinary kriging of SOM across the three woredas in Ethiopia. Comparison of the model-based infill sample with the spatial infill sample of Figure \@ref(fig:spatialinfillEthiopia) shows that in a wider zone on both sides of the roads no new sampling points are selected. This can be explained by the large range of `r round(vgm_ML$phi,1)` km of the semivariogram.

```{r ModelBasedInfill, echo=FALSE, fig.cap="Model-based infill sample for ordinary kriging of SOM across three woredas of Ethiopia."}
load("results/MBInfillSample_OK_Ethiopia.RData")
load(file="data/CovariatesThreeWoredasEthiopia.RData")
df <- data.frame(x=rslt$points$x, y=rslt$points$y, free=rslt$points$free)
df$free <- as.factor(df$free)
ggplot() +
  geom_raster(grdEthiopia, mapping=aes(x=s1,y=s2), fill="grey") +
  geom_point(data=df, mapping=aes(x=x, y=y, shape=free)) +
  coord_fixed()
```

### Model-based infill sampling for kriging with an external drift

For the study area in Ethiopia maps of covariates are available that can be used in kriging with an external drift (KED), see Section \@ref(MBgridspacingKED). The prediction error variance with KED is partly determined by the covariate values, and therefore when filling in the undersampled areas, locations with extreme values for the covariates are preferably selected. The legacy data are used to estimate the residual semivariogram by restricted maximum likelihood (REML), see Section \@ref(REML).

```{r}
library(geoR)
dGeoR <- as.geodata(
   obj=priordata, header=TRUE, 
   coords.col=13:14, data.col=1, covar.col=c(3,9,10,11)
 )
vgm_REML <- likfit(
  geodata=dGeoR, trend=~dem+rfl_NIR+rfl_red+lst,
  cov.model="spherical", ini.cov.pars=c(1,5), nugget=0.2,
  lik.method="REML", messages=FALSE)
```

```{r, echo=FALSE}
schedule <- scheduleSPSANN(
  initial.acceptance=0.8,
  initial.temperature=0.0025,
  temperature.decrease=0.9,
  chains=300,
  chain.length=2, stopping=5,
  x.min=0, y.min=0,
  cellsize=1)
```

```{r, eval=FALSE}
covars <- grdEthiopia[,c("dem","rfl_NIR","rfl_red","lst")]
vgm_REML_gstat <- vgm(
  model="Sph", psill=vgm_REML$sigmasq, 
  range=vgm_REML$phi, nugget=vgm_REML$nugget)
set.seed(314)
rslt <- optimMKV(
  points=pnts, candi=candi, covars=covars,
  vgm=vgm_REML_gstat,
  eqn=z~dem+rfl_NIR+rfl_red+lst,
  nmax=20, schedule=schedule, track=TRUE)
```

```{r, eval=FALSE, echo=FALSE}
save(rslt, file="results/MBInfillSample_KED_Ethiopia.RData")
```

Figure \@ref(fig:ModelBasedInfillKED) shows the optimised sample for KED using as covariates elevation, NIR-reflectance, red-reflectance and land surface temperature. Again the legacy points are avoided, but the infill sampling of the under-sampled areas is less uniform compared to Figure \@ref(fig:ModelBasedInfill). Spreading in geographical space is less important than with ordinary kriging because the residual semivariogram has a much smaller range (Table \@ref(tab:VariogramREMLEthiopia)). Spreading in covariate space does not play any role with ordinary kriging, whereas with KED selecting locations with extreme values for the covariates is important to minimise the uncertainty about the estimated mean.

```{r ModelBasedInfillKED, echo=FALSE, fig.cap="Model-based infill sample for kriging with an external drift of SOM across three woredas of Ethiopia, plotted on a map of one of the covariates."}
load("results/MBInfillSample_KED_Ethiopia.RData")
df <- data.frame(x=rslt$points$x, y=rslt$points$y, free=rslt$points$free)
df$free <- as.factor(df$free)

ggplot() +
  geom_raster(grdEthiopia, mapping=aes(x=s1, y=s2, fill=rfl_NIR)) +
  geom_point(data=df, mapping=aes(x=x, y=y, shape=free)) +
  scale_fill_continuous(name="NIR", type="viridis") + 
  coord_fixed()
```

```{r, echo=FALSE}
load("results/MBInfillSample_KED_Ethiopia.RData")
MKV_KED_opt <- as.numeric(tail(rslt$objective$energy,1))

#compute KED variance for model-based infill sample for ordinary kriging
load("results/MBInfillSample_OK_Ethiopia.RData")
ids <- which(rslt$points$free==1)
infillSampleOK <- rslt$points[ids,]
coordinates(infillSampleOK) <- ~x+y

#add covariates
load(file="data/CovariatesThreeWoredasEthiopia.RData")
covariates <- c("dem","rfl_NIR","rfl_red","lst")
grid <-grdEthiopia[,c("s1","s2",covariates)]
coordinates(grid) <- ~s1+s2
gridded(grid) <- TRUE
infillSampleOK <- SpatialPointsDataFrame(coords=infillSampleOK, data=over(infillSampleOK, grid))

load(file="data/ThreeWoredasEthiopia.RData")
legacy <- remove.duplicates(priordataEthiopia, zero=1, remove.second=TRUE)

legacy <- legacy[,c(covariates)]
#coordinates(legacy) <- ~s1+s2
proj4string(legacy) <- NA_character_

alldata <- rbind(legacy,infillSampleOK)

#add dummy variable to sampling points
alldata$dummy <- 1

# Create prediction grid 's0'
s0 <- spsample(x=grid, n=5000, type="regular", offset=c(0.5, 0.5))
s0 <- SpatialPointsDataFrame(coords=s0, data=over(s0, grid))

predictions  <- krige(
  formula=dummy~dem+rfl_NIR+rfl_red+lst,
  locations=alldata,
  newdata=s0,
  model=vgm_REML_gstat,
  nmax=20,
  debug.level=0
)
MKV_KED_OKsample <- mean(predictions$var1.var)
```

The mean kriging variance of the optimised sample equals `r as.character(round(MKV_KED_opt,3))`. This is considerably smaller than the mean kriging variance obtained when the model-based infill sample for ordinary kriging (Figure \@ref(fig:ModelBasedInfill)) is used in kriging with an external drift: `r as.character(round(MKV_KED_OKsample,3))`.

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:29-ModelBasedSamplePattern.Rmd-->

# Sampling for estimating the semivariogram {#SamplingVariogram}

For model-based sampling as described in Chapters \@ref(MBgridspacing) and \@ref(MBSamplePattern) we must specify the (residual) semivariogram. In case we do not have a reasonable prior estimate from a similar study, we may decide to collect first data with the specific aim of estimating the semivariogram. This semivariogram is subsequently used to design a model-based sample for mapping. This chapter is about how to design a reconnaissance sample survey\index{Reconnaissance sample survey} for estimating the semivariogram.

The first question is how many observations we need for this. @web92 gave as a rule of thumb that 150 to 225 points are needed to obtain a reliable semivariogram when estimated by the method-of-moments. @lar00b showed that with maximum likelihood (ML) estimation two-third to only half of the observations are needed to achieve equal precision of the estimated semivariogram parameters. Once we have decided on the sample size, we must select the locations of the sampling units. Two random sampling designs for semivariogram estimation are described in this chapter, nested sampling and independent sampling of pairs of points. A following section is devoted to model-based optimisation of the sample pattern for semivariogram estimation. The final section is about how to design a single sample that can be used both for estimating the semivariogram and prediction (mapping).

## Nested sampling

Nested sampling can be used to estimate the semivariance at several chosen separation distances, see  @Oliver1986 and @Webster2006. We must first decide on these separation distances. We need point-pairs at various separations, and especially for small separations so that we get reliable estimates of this part of the semivariogram, which has a strong effect on the kriging weights. Usually separation distances are chosen in a geometric progression, for instance 2, 8, 32, 128 and 512 m. The multiplier, which is four in this example, should be not too small; as a rule of thumb use three or larger.

There are two versions of nested sampling\index{Nested sampling}. In the first version, in the first stage several main stations are selected in a way that they cover the study area well, for instance by spatial coverage sampling. In the second stage each of the main stations is used as a starting point to select one point at a distance equal to the largest chosen separation distance (512 m in the example), in a random direction from the main station. This doubles the sample size. In the third stage all points selected in the previous stages (main stations of stage 1 plus the points of stage 2) are used as starting points to select one point at a distance equal to the second largest separation distance, and so on. All points selected in the various stages are included in the nested sample. The code chunk below shows the function for random selection of one point at distance $h$ from a starting point. Note the while loop which continues until a point is found that is inside the area. this is checked with function `over` of package **sp**.

```{r}
SelectPoint <- function(start, h, area){
  dxy <- numeric(length=2)
  inArea <- NA
  while(is.na(inArea)) {
    angle <- runif(n=1, min=0, max=2*pi)
    dxy[1] <- h*sin(angle); dxy[2] <- h*cos(angle)
    xypnt <- start+dxy
    coordinates(xypnt) <- ~s1+s2
    inArea <- as.numeric(over(x=xypnt, y=area))[1]
  }
  xypoint <- as.data.frame(xypnt)
  xypoint
}
```

The first stage of the second version is equal to that of the first version. In the second stage each of the main stations serves as a starting point for randomly selecting a *pair of points* with a separation distance equal to the largest chosen separation distance, with the main station halfway. In the third stage each of the substations is used to select in the same way a pair of points separated by the second largest chosen distance, and so on. Only the points selected in the final stage are used as sampling points. The **R** code below shows the function for random selection of two points separated by $h$ distance units, with a starting point halfway the pair of points. Note that the while loop continues until both points of a pair are inside the area.

```{r}
SelectPair <- function(start, h, area){
  dxy <- numeric(length=2)
  xypoints <- NULL
  inArea1 <- inArea2 <- NA
  while(is.na(inArea1) | is.na(inArea2)) {
    angle <- runif(n=1, min=0, max=2*pi)
    dxy[1] <- h*sin(angle)/2; dxy[2] <- h*cos(angle)/2
    xypnt1 <- start+dxy
    coordinates(xypnt1) <- ~s1+s2
    inArea1 <- as.numeric(over(x=xypnt1, y=area))[1]
    dxy[1] <- -dxy[1]; dxy[2] <- -dxy[2]
    xypnt2 <- start+dxy
    coordinates(xypnt2) <- ~s1+s2
    inArea2 <- as.numeric(over(x=xypnt2, y=area))[1]
  }
  xypoints <- rbind(as.data.frame(xypnt1), as.data.frame(xypnt2))
  xypoints
}
```

The **R** code below shows the selection of a nested sample from the Hunter Valley using both versions. Only one main station is selected. In total sixteen points are selected in four stages. The separation distances are 2000, 1000, 500 and 250 m. Note that the separation distances are in descending order. The largest separation distance should not be chosen too large, because then, when the main station is somewhere in the middle of the study area, it may happen that using the first version no pair can be found with that separation distance. A similar problem may occur with the second version when in subsequent stages a station is selected near the border of the study area. A copy of the data frame `grd` is made because both the original data frame is needed as well as a gridded version of this data frame.   

```{r}
library(sp)
load(file="data/HunterValley.RData")
grd <- grdHunterValley
names(grd)[c(1,2)] <- c("s1","s2")
#make a copy of grd (class of grd is changed)
grid <- grd
gridded(grd) <- ~s1+s2
lags <- c(2000,1000,500,250)
```

The next code chunk is an implementation of the first version of nested sampling.

```{r NestedSampling1}
set.seed(614)
id <- sample.int(nrow(grid),1)
mainstation <- grid[id,c(1,2)]
newpnt <- SelectPoint(start=mainstation, h=lags[1], area=grd)
mynestedsample <- rbind(mainstation, newpnt)
for (j in 2:length(lags)) {
  newpnts <- NULL
  for (i in 1:nrow(mynestedsample)) {
    pnts <- SelectPoint(
      start=mynestedsample[i,], h=lags[j], area=grd)
    newpnts <- rbind(newpnts, pnts)
  }
  mynestedsample <- rbind(mynestedsample, newpnts)
}
```

**R** code for the second version is in the next code chunk.

```{r NestedSampling2}
id <- sample.int(nrow(grid), 1)
mainstation <- grid[id,c(1,2)] 
pnt <- SelectPoint(start=mainstation, h=lags[1], area=grd)
stations <- rbind(mainstation, pnt)
allstations <-  rbind(mainstation, pnt)
for (j in 2:length(lags)) {
  newstations <- NULL
  for (i in 1:nrow(stations)) {
    pnts <- SelectPair(start=stations[i,], h=lags[j], area=grd)
    newstations <- rbind(newstations, pnts)
    allstations <- rbind(allstations, pnts)
  }
  stations <- newstations
}
mynestedsample_2 <- stations
```

Figure \@ref(fig:BalancedNestedSample) shows the two selected nested samples. For the sample selected with the second version also the stations that served as starting point for the selection of the pairs of points are plotted.

```{r BalancedNestedSample, echo=FALSE, out.width='100%', fig.cap="Balanced nested samples from Hunter Valley, selected with the two versions. In the subfigure of the second version the selected sampling points (symbol x) are plotted together with the selected stations (halfway the two points of a pair)."}
mynestedsample$stage <- as.factor(c(1,1,2,2, rep(3,4), rep(4,8)))

plt1 <- ggplot(mynestedsample) +
  geom_tile(data=grid, mapping=aes(x=s1/1000, y=s2/1000), fill="grey") +  
  geom_point(aes(x=s1/1000, y=s2/1000, shape=stage), size=1) +
  ggtitle("First version") +
  theme(plot.title=element_text(size=10, hjust=0.5)) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()

nrstations <- nrow(allstations)-nrow(mynestedsample_2)
allstations <- allstations[1:nrstations,]
allstations$station <- as.factor(c(rep(1,2), rep(2,4), rep(3,8)))

plt2 <- ggplot(mynestedsample_2) +
  geom_tile(data=grid,mapping=aes(x=s1/1000, y=s2/1000), fill="grey") +  
  geom_point(data=allstations, aes(x=s1/1000, y=s2/1000, shape=station), size=1) +
  geom_point(aes(x=s1/1000, y=s2/1000), shape=4, size=1) +
  ggtitle("Second version") +
  theme(plot.title=element_text(size=10, hjust=0.5)) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()

grid.arrange(plt1, plt2, nrow=1)

#remove column stage
mynestedsample <- mynestedsample [,-3]
```

The sample of Figure \@ref(fig:BalancedNestedSample) is an example of a *balanced* nested sample: in all stages all stations selected in the previous stage are used to select a pair of points. If in the first version of nested sampling all points selected in all previous stages are used to select a new point, then this also results in a balanced nested sample\index{Nested sampling!balanced nested sampling}. The number of pairs of points separated by a given distance doubles with every stage. As a consequence, the estimated semivariances for the smallest separation distance are much more precise than for the largest distance. We are most uncertain about the estimated semivariances for the largest separation distances. If in the first stage only one pair of points is selected separated by the largest distance, then we have only one degree of freedom for estimating the variance component associated with this stage. It is more efficient to select more than one main station, say about ten, and to select fewer points in the final stages. For instance, with the second version we may decide to select a pair of points at only half the number of stations selected in the one-but-last stage. The nested sample then becomes unbalanced.

The model for nested sampling with four stages is a hierarchical ANOVA model\index{Hierarchical ANOVA model} with random effects:

\begin{equation}
Z_{ijk}=\mu+A_i+B_{ij}+C_{ijk}+\epsilon_{ijkl} \;.
(\#eq:ANOVAmodelnested)
\end{equation}

with $\mu$ the mean, $A_i$ the effect of the $i$th first stage station, $B_{ij}$ the effect of the $j$th second stage station within the $i$th first stage station, and so on. $A_i$, $B_{ij}$, $C_{ijk}$ and $\epsilon_{ijkl}$ are random quantities (random effects), all with zero mean, and variances $\sigma^2_1$, $\sigma^2_2$, $\sigma^2_3$ and $\sigma^2_4$ respectively.

For balanced designs the variance components\index{Variance component} can be estimated by the method-of-moments from a hierarchical ANOVA. The first step is to assign factors to the sampling points that indicate the grouping of the sampling points in the various stages. The number of factors needed is the number of stages minus one. All factors have two levels. Figure \@ref(fig:FactorLevelsBalancedNestedSample) shows the levels of the three factors. The levels of the first factor show the strongest spatial clustering, those of the second factor the one-but strongest, and so on.

```{r FactorLevelsBalancedNestedSample, echo=FALSE, out.width='100%', fig.asp=0.30, fig.cap="The levels of the three factors assigned to the sampling points of the balanced nested sample selected with the first version."}
mynestedsample$factor1 <- rep(1:2)
mynestedsample$factor2 <- rep(1:2, each=2)
mynestedsample$factor3 <- rep(1:2, each=4)

df <- mynestedsample %>% pivot_longer(.,cols=c("factor1","factor2","factor3"))
ggplot(df) +
  geom_tile(data=grid, mapping=aes(x=s1/1000, y=s2/1000), fill="grey") +
  geom_point(aes(x=s1/1000,y=s2/1000), shape=4, size=0.8) +
  geom_text(aes(x=(s1-100)/1000,y=s2/1000, label=value), size=1.5) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed() +
  facet_wrap(~name)
```

The **R** code below shows the construction of the three factors for the second version of nested sampling.

```{r}
mynestedsample_2$factor1 <- rep(1:2, each=8)
mynestedsample_2$factor2 <- rep(1:2, each=4)
mynestedsample_2$factor3 <- rep(1:2, each=2)
```

```{r FactorLevelsBalancedNestedSample2, echo=FALSE, out.width='100%', fig.asp=0.30, fig.cap="The levels of the three factors assigned to the sampling points of the balanced nested sample selected with the second version."}
df <- mynestedsample_2 %>% pivot_longer(.,cols=c("factor1","factor2","factor3"))
ggplot(df) +
  geom_tile(data=grid, mapping=aes(x=s1/1000, y=s2/1000), fill="grey") +
  geom_point(aes(x=s1/1000,y=s2/1000), shape=4, size=0.8) +
  geom_text(aes(x=(s1-100)/1000,y=s2/1000, label=value), size=1.5) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  coord_fixed()+
  facet_wrap(~name)
```

For unbalanced nested designs\index{Nested sampling!unbalanced nested sampling} the variance components can be estimated by restricted maximum likelihood\index{Restricted maximum likelihood estimation} (REML) [@Webster2006]. REML estimation is also recommended if in Equation \@ref(eq:ANOVAmodelnested) instead of a constant mean $\mu$ the mean is a linear combination of one or more covariates (fixed effects). The semivariances at the chosen separation distances are obtained by cumulating the estimated variance components.

The **R** code below shows how the variance components and semivariances can be estimated, once the data are collected and added to the data frame, with the function `lme` of the package **nlme** [@Pinheiro2014]. This function fits linear mixed-effects models and allows for nested random effects. It can be used both for balanced and unbalanced nested samples, and for a constant mean or a mean that is a linear combination of covariates. The argument `fixed` is a formula describing the fixed effects, with the response variable on the left of the  ~ operator, and the covariates for the mean on the right. If a constant mean is assumed, as in our example, this is indicated by a 1 on the right of the  ~ operator. The argument `random` is a one-sided formula (no response variable is on the left of the ~ operator). On the right of the $|$ separator, the nested structure of the data is specified using the factors of Figure \@ref(fig:FactorLevelsBalancedNestedSample). The 1 on the left of the $|$ separator means that we assume that all regression coefficients associated with the covariates are fixed (non-random) quantities.

```{r EstimateVarianceComponents, eval=FALSE}
library(nlme)
lmodel <- lme(fixed=z~1, data=mynestedsample,
              random=~1|factor1/factor2/factor3)
res <- as.matrix(VarCorr(lmodel))
sigmas <- as.numeric(res[c(2,4,6,7),1])
sigma <- rev(sigmas)
semivar <- cumsum(sigmas)
```

Random sampling of the points is not strictly needed because a model-based approach is followed here. The model of Equation \@ref(eq:ANOVAmodelnested) is a superpopulation model, i.e. we assume that the population is generated by this model. @Papritz2011, for instance, selected the points (using the second version) non-randomly to improve the control of the nested subareas and the average separation distances.

@Lark2011CAGEO describes a method for optimisation of a nested design, given the total number of points and the chosen separation distances.

#### Exercises {-}

1. Write an **R** script to select with the first version a balanced nested sample from the Hunter Valley. Use as separation distances 1,000, 500, 200, 100 and 50 m.  
    + Add the factors that are needed for estimating the variance components to the `data.frame` with the selected sampling points.        
    + Overlay the sampling points with the `SpatialPixelsDataFrame`, and estimate the semivariances for the attribute compound topographic index (cti).    

## Independent sampling of pairs of points

With the nested design the estimated semivariances for the different separation distances are not independent. Independent estimated semivariances can be obtained by independent random selection of pairs of points (IPP sampling)\index{Independent sampling of point-pairs}. Independence hear means design-independence, see Section  \@ref(i.i.d.). Similar to a regression model, a semivariogram can be defined as a superpopulation model or as a population model. In this section a semivariogram is defined at the population level. Such a semivariogram is referred to as a non-ergodic semivariogram\index{Non-ergodic semivariogram} or local semivariogram\index{Local semivariogram} [@bru94b]. For simple random sampling of pont-pairs\index{Simple random sampling of point-pairs|(} this method is very straightforward. For each separation distance a pont-pair is selected by first selecting fully randomly one point from the study area. Then the second point is randomly selected from the circle with the first point at its center and a radius equal to the chosen separation distance. If this second point is outside the study area, both points are ignored. This is repeated until we have the required pont-pairs for this separation distance.

```{r SIPairs}
SIpairs <- function(h, n, area) {
  topo <- as(getGridTopology(area), "data.frame")
  cellsize <- topo$cellsize[1]
  xy <- coordinates(area)
  dxy <- numeric(length=2)
  xypnts1 <- xypnts2 <- NULL
  i <- 1
  while (i <= n) {
    id1 <- sample.int(n=length(area), size=1)
    xypnt1 <- xy[id1,]
    xypnt1[1] <- jitter(xypnt1[1], amount=cellsize/2)
    xypnt1[2] <- jitter(xypnt1[2], amount=cellsize/2)
    angle <- runif(n=1, min=0, max=2*pi)
    dxy[1] <- h*sin(angle); dxy[2] <- h*cos(angle)
    xypnt2 <- as.data.frame(t(xypnt1+dxy))
    coordinates(xypnt2) <- ~s1+s2
    inArea <- as.numeric(over(x=xypnt2, y=area))[1]
    if (!is.na(inArea)) {
      xypnts1 <- rbind(xypnts1, xypnt1)
      xypnts2 <- rbind(xypnts2, as.data.frame(xypnt2))
      i <- i+1
    }
    rm(xypnt1, xypnt2)
  }
  cbind(xypnts1, xypnts2)
}
```

IPP sampling is illustrated below with the compound topographic index (cti) data of the Hunter Valley. Five separation distances are chosen, collected in numeric `h`, and for each distance $n=100$ pont-pairs are selected by simple random sampling. 

```{r, echo=FALSE}
grd <- grdHunterValley
names(grd)[c(1,2)] <- c("s1","s2")
gridded(grd) <- ~ s1+s2
```

```{r IPPSampling}
library(sp)
h <- c(50,100,200,500,1000)
n <- 100
set.seed(123)
allpairs <- NULL
for (i in 1:length(h)){
  pairs <- SIpairs(h=h[i], n=n, area=grd)
  allpairs <- rbind(allpairs, pairs, make.row.names=FALSE)
}
```

The data frame file `allpairs` has four columns: the spatial coordinates of the first and of the second point of a pair. An overlay is made of the selected points with the `SpatialPixelsDataFrame` and the cti values are extracted.

```{r Allpairs}
pnt1 <- allpairs[,c(1,2)]
coordinates(pnt1) <- ~s1+s2
z1 <- over(x=pnt1, y=grd)[4]
pnt2 <- allpairs[,c(3,4)]
coordinates(pnt2) <- ~s1+s2
z2 <- over(x=pnt2, y=grd)[4]
mysample <- data.frame(h=rep(h, each=n), z1, z2)
names(mysample)[c(2,3)] <- c("z1","z2")
```

The semivariances for the chosen separation distances are estimated, as well as the variance of these estimated semivariances.

```{r}
gammah <- vgammah <- numeric(length=length(h))
for (i in 1:length(h)){
  units <- which(mysample$h==h[i])
  pairsh <- mysample[units,]
  gammah[i] <- mean((pairsh$z1-pairsh$z2)^2, na.rm=TRUE)/2 
  vgammah[i] <- var((pairsh$z1-pairsh$z2)^2, na.rm=TRUE)/(n*4)
}
```

A spherical model with nugget is fitted to the sample semivariogram, using function `nls`, with weights equal to the reciprocal of the estimated variances of the estimated semivariances.

```{r}
samplevariogram <- data.frame(h, gammah, vgammah)
SphNug <- function(h, range, psill, nugget) {
  h <- h/range
  nugget+psill*ifelse(h<1, (1.5*h-0.5*h^3), 1)
}
fit.var <- nls(
  gammah~SphNug(h, range, psill, nugget),
  data=samplevariogram,
  start=list(psill=4, range=200, nugget=1),
  weights=1/vgammah, algorithm="port", lower=c(0,0,0))
print(pars <- signif(coef(fit.var),3))
```

Figure \@ref(fig:variogramCTI) shows the sample semivariogram and the fitted model.

```{r variogramCTI, echo=FALSE, fig.asp=0.7, fig.cap="Sample semivariogram obtained by independent sampling of pairs of points, and fitted spherical model of cti in Hunter Valley."}
#Compute fitted values
dist <- seq(from=0.1, to=1000, by=0.1)
fitted <- SphNug(h=dist, range=pars["range"], psill=pars["psill"], nugget=pars["nugget"])
#Plot sample semivariogram and fitted model
df <- data.frame(h=dist, fitted=fitted)
ggplot(data=samplevariogram) +
  geom_point(mapping=aes(x=h, y=gammah), size=3) +
  geom_line(data=df, mapping=aes(x=dist,y=fitted), colour="red") +
  scale_x_continuous(name="Separation distance") +
  scale_y_continuous(name="Semivariance", limits=c(0,NA))
```

The covariances of the estimated semivariances at different separation distances are 0, as the pont-pairs are selected independently. This keeps estimation of the variances and covariances of the estimated semivariogram parameters simple. In the next code chunk this is done by bootstrapping\index{Bootstrap sample}. In bootstrapping for each separation distance a simple random sample *with replacement* of pont-pairs is drawn. The number of draws is equal to the total number of pairs per separation distance. So a pair can be selected more than once. Every run of the bootstrap results in as many bootstrap samples as there are separation distances. These bootstrap samples are used to fit a semivariogram model. This whole procedure is repeated a large number of times, say $R$ times, resulting in $R$ vectors with model parameters, from which we can estimate the variances and covariances of the semivariogram parameters.

```{r bootstrap}
allpars <- NULL
R <- 500
for (j in 1:R) {
  gammah <- vgammah <- numeric(length=length(h))
  for (i in 1:length(h)) {
    units <- which(mysample$h==h[i])
    pairs <- mysample[units,]
    ids <- sample.int(n, size=n, replace=TRUE)
    mybtps <- pairs[ids,]
    gammah[i] <- mean((mybtps$z1-mybtps$z2)^2, na.rm=TRUE)/2 
    vgammah[i] <- var((mybtps$z1-mybtps$z2)^2, na.rm=TRUE)/(n*4)
  }
  samplevariogram <- data.frame(h, gammah, vgammah)
  tryCatch({fittedvariogram <- nls(
    gammah~SphNug(h, range, psill, nugget), 
    data=samplevariogram, 
    start=list(psill=4, range=200, nugget=1), 
    weights=1/vgammah, algorithm="port", lower=c(0,0,0))
  pars <- coef(fittedvariogram)
  allpars <- rbind(allpars,pars)}, error=function(e){})
}
#compute variance-covariance matrix
signif(var(allpars),3)
```

Note the large variance for the range parameter (standard deviation is 215 m), and the negative covariance of the nugget and partial sill parameter (Pearson correlation coefficient is -0.62). Histograms of the three estimated semivariogram parameters are shown in Figure \@ref(fig:histogramsvariogramparameters)\index{Simple random sampling of point-pairs|}.

```{r histogramsvariogramparameters, echo=FALSE, out.width='100%', fig.asp=0.6, fig.cap="Sampling distribution of the estimators of the parameters of a spherical semivariogram with nugget of cti in Hunter Valley.", }
df <- as.data.frame(allpars)
names(df) <- c("PartialSill","Range","Nugget")

plt1 <- ggplot(data=df) +
  geom_histogram(aes(x=Nugget), fill="black", alpha=0.5, colour="black", binwidth=0.25)
plt2 <- ggplot(data=df) +
  geom_histogram(aes(x=PartialSill), fill="black", alpha=0.5, colour="black", binwidth=0.5)
plt3 <- ggplot(data=df) +
  geom_histogram(aes(x=Range), fill="black", alpha=0.5, colour="black", binwidth=150)

grid.arrange(plt1, plt2, plt3, nrow=2)
```

@Marcelli2019 show how a probability sample of *points* (instead of pairs of points) can be used in design-based estimation of the semivariogram. From the $n$ randomly selected points $n (n-1)/2$ pont-pairs are constructed, and the *second-order inclusion probabilities* of these pont-pairs are used in estimating the mean semivariance for separation distance classes. This sampling strategy makes better use of the data, and therefore is potentially more efficient than IPP sampling.

#### Exercises {-}

2. Write an **R** script to select simple random samples of pairs of points for estimating the semivariogram of cti in Hunter Valley. Use as separation distances 25, 50, 100, 200 and 400 m. Note that these separation distances are smaller than used above. Select 100 pairs per separation distance.
    + Compute the sample semivariogram and estimate a spherical model with nugget using function `nls`.  
    + Compare the estimated semivariogram parameters with the estimates obtained with the larger separation distances.  
    + Estimate the variance-covariance matrix of the estimated semivariogram parameters by bootstrapping.  
    + Compare the variances of the estimated semivariogram parameters with the variances obtained with the larger separation distances. Which variance is changed most?  

## Model-based optimisation of sample pattern for semivariogram estimation {#samplingforvariogram}

There is rich literature on model-based optimisation of the sampling locations for semivariogram estimation. Several design criteria (minimisation criteria) have been proposed for optimising the sampling locations. Various authors have proposed a measure of the uncertainty about the semivariogram parameters as a minimisation criterion. This is because the kriging variance, which could be used as an optimisation criterion, is sensitive to errors in the estimated semivariogram. @lar02 proposed to use a measure of the uncertainty about the kriging variance as a minimisation criterion.

### Uncertainty about semivariogram parameters {#UncertainSemivariogramParameters}

@mul99 and @bog99 proposed the determinant of the variance-covariance matrix\index{Determinant of variance-covariance matrix} of semivariogram parameters, estimated by generalised least squares to fit the experimental method-of-moments semivariogram. For instance, if we have two semivariogram parameters, $\theta_1$ and $\theta_2$, the determinant of the $2\times2$ variance-covariance matrix equals $var(\theta_1) var(\theta_2) - (covar(\theta_1,\theta_2))^2$. So, if the two estimated parameters are correlated, the determinant of the matrix is smaller than if they are uncorrelated and the covariance term is 0. The determinant is a measure of our *joint* uncertainty about the semivariogram parameters.

@zhu05 proposed as a minimisation criterion the logarithm of the  determinant of the inverse Fisher information matrix\index{Fisher information matrix} in maximum likelihood (ML) estimation\index{Maximum likelihood estimation} of the semivariogram, hereafter shortly denoted by logdet. The Fisher information about a semivariogram parameter is a function of the likelihood of the semivariogram parameter; the likelihood of a semivariogram parameter is the probability of the data as a function of the semivariogram parameter. The logarithm of this likelihood can be plotted against values of the parameter. The flatter the log-likelihood surface\index{Log-likelihood surface}, the less information is in the data about the parameter. The flatness of the surface can be measured by the first derivative of the log-likelihood to the semivariogram parameter. Strong negative or positive derivative values indicate a steep surface. The Fisher information for a model parameter is defined as the expectation of the *square* of the first derivative of the log-likelihood to that semivariogram parameter, see @Ly2017 for a nice tutorial on this subject. The more information, the less uncertain we are about the parameter, which explains why the inverse of the Fisher information can be used as a measure of uncertainty. The inverse Fisher information matrix contains the variances and covariances of the estimated semivariogram parameters.

The code chunks hereafter show how logdet can be computed. It makes use of the result of @Kitanidis87 who showed that each element of the Fisher information matrix $\mathbf{I}(\theta)$ can be obtained with (see also @lar02)

\begin{equation}
[\mathbf{I}(\theta)]_{ij}=\frac{1}{2}\mathrm{Tr}\left[\mathbf{A}^{-1}\frac{\partial\mathbf{A}}{\partial\theta_i}\mathbf{A}^{-1}\frac{\partial\mathbf{A}}{\partial\theta_j}\right]\;,
(\#eq:FisherInformation)
\end{equation}

with $\mathbf{A}$ the correlation matrix of the sampling points, $\frac{\partial\mathbf{A}}{\partial\theta_i}$ the partial derivative of the correlation matrix to the $i$th semivariogram parameter, and Tr[$\cdot$] the trace of a matrix.

As an illustration I selected a simple random sample of 100 points from Hunter valley. A matrix with distances between the points of a sample is computed. Preliminary values for the semivariogram parameters $\xi$ (ratio of spatial dependence\index{Ratio of spatial dependence}) and $\phi$ (distance parameter\index{Distance parameter}) are specified by visual inspection of the sample semivariogram, and the  **gstat** function `variogramLine` is used to compute the correlation matrix.

```{r, echo=FALSE}
grd <- grdHunterValley
```

```{r}
library(sp)
library(gstat)
n <- 100
set.seed(314)
units <- sample.int(nrow(grd), n)
mysample0 <- grd[units,]
coordinates(mysample0) <- ~Easting+Northing
D <- spDists(mysample0)
xi <- 0.8; phi <- 200
thetas <- c(xi,phi)
vgmodel <- vgm(
  model="Exp", psill=thetas[1],
  range=thetas[2], nugget=1-thetas[1])
A <- variogramLine(vgmodel, dist_vector=D, covariance=TRUE)
```

In the next step the semivariogram parameters are slightly changed one-by-one. The changes, referred to as perturbation\index{Perturbation}, are a small fraction of the preliminary semivariogram parameter values. The perturbed semivariogram parameters are used to compute the perturbed correlation matrices (`pA`) and the partial derivatives of the correlation matrix (`dA`) for each perturbation.

```{r}
perturbation <- 0.01
pA <- dA <- list()
for (i in 1:length(thetas)) {
  thetas_pert <- thetas
  thetas_pert[i] <- (1+perturbation)*thetas[i]
  vgmodel_pert <- vgm(
    model="Exp", psill=thetas_pert[1], 
    range=thetas_pert[2], nugget=1-thetas_pert[1])
  pA[[i]] <- variogramLine(
    vgmodel_pert, dist_vector=D, covariance=TRUE)
  dA[[i]] <- (pA[[i]]-A)/(thetas[i]*perturbation)
}
```

Finally the Fisher information matrix is computed, using Equation \@ref(eq:FisherInformation), the matrix is inverted, and the determinant is computed.

```{r}
library(matrixcalc)
invA <- chol2inv(chol(A))
I <- matrix(0, length(thetas), length(thetas))
for (i in 1:length(thetas)){
  for (j in i:length(thetas)){
    I[i,j] <- I[j,i] <- 
      0.5*matrix.trace(invA%*%dA[[i]]%*%invA%*%dA[[j]])
  }
}
(invI <- chol2inv(chol(I)))
logdet0 <- determinant(invI, logarithm=TRUE)$modulus
```

Note the large variance of the distance parameter, equal to `r as.character(round(invI[2,2],0))`. The standard error of the ratio of spatial dependence parameter $\xi$ equals `r signif(sqrt(invI[1,1]),2)` (the square root of the value in the first column and first row of the inverse Fisher information matrix), and for the distance parameter $\phi$ it is  `r signif(sqrt(invI[2,2]),3)` m (the square root of the value in the second row and second column). The joint uncertainty about the semivariogram parameters as quantified by the logarithm of the determinant of the matrix equals `r round(logdet0,3)`. Hereafter we will see how much this joint uncertainty can be reduced by optimising the locations of the sample used for semivariogram estimation, compared to the simple random sample used in the above calculation.

Function `optimUSER` of package **spsann** can be used to search for the locations with the minimum value of logdet. This function has been used before in Section \@ref(SamplePatternOK). This package cannot deal with the `r nrow(grdHunterValley)` candidate grid nodes of Hunter Valley, these are too many. I therefore selected a subgrid of 50 m $\times$ 50 m. Note that the argument `cellsize` is also set to this number. The objective function `logdet` is defined in **R** script [ObjectiveFunctions4MBSamplingVariogram.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Rscripts/ObjectiveFunctions4MBSamplingVariogram.R)^[https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Rscripts/ObjectiveFunctions4MBSamplingVariogram.R]. Argument `points` specifies the size of the sample for variogram estimation. A simple random sample of size 100 is used as an initial sample by  function `optimUSER`. Argument `model` specifies the model *type*, using the characters of **gstat**. Argument `thetas` specifies the preliminary semivariogram parameter values. `Argument` perturbation specifies how much the variogram parameters are changed to compute the perturbed correlation matrices (`pA`) and the partial derivatives of the correlation matrix (`dA`).

```{r, echo=FALSE}
grd <- grdHunterValley
```

```{r, eval=FALSE}
source ("Rscripts/ObjectiveFunctions4MBSamplingVariogram.R")
gridded(grd) <- ~Easting+Northing
candi <- spsample(grd, type="regular", cellsize=c(50,50))
candi <- as.data.frame(candi)
names(candi) <- c("x","y")
schedule <- scheduleSPSANN(
  initial.acceptance=0.8,
  initial.temperature=0.03, temperature.decrease=0.8,
  chains=500, chain.length=2, stopping=5,
  x.min=0, y.min=0, cellsize=50)
set.seed(314)
rslt <- optimUSER(
  points=100, candi=candi,
  fun=logdet,
  model="Exp", thetas=thetas, perturbation=0.01,
  schedule=schedule, track=TRUE)
```

```{r, eval=FALSE, echo=FALSE}
save(rslt, file="results/MBSample_logdet_phi200nug02_HunterValley.RData")
```

```{r, echo=FALSE}
load(file="results/MBSample_logdet_phi200nug02_HunterValley.RData")
logdetopt <- tail(rslt$objective$energy$obj,1)
```

Figure \@ref(fig:MBVariogram) shows the optimised sample of 100 points.  The logdet of the optimised sample equals `r round(logdetopt,3)` which is `r round(100*logdetopt/logdet0,0)`\% of the value of the simple random sample used above to illustrate the computations. The optimised sample shows strong spatial clustering. Connecting neighbouring points of the sample by lines results in  a sort of mycelium.

### Uncertainty about the kriging variance

@lar02 proposed as a minimisation criterion the estimation variance of the kriging variance due to uncertainty in the ML estimates of the semivariogram parameters (hereafter denoted by VKV). This variance is approximated by a first order Taylor series\index{First order Taylor series}, requiring the partial derivatives of the kriging variance with respect to the semivariogram parameters:

\begin{equation}
VKV(\mathbf{s}_0) = \sum_{i=1}^p \sum_{j=1}^p \mathrm{Cov}(\theta_i,\theta_j) \frac{\partial V_{\mathrm{OK}}(\mathbf{s}_0)} {\partial \theta_i} \frac{\partial V_{\mathrm{OK}}(\mathbf{s}_0)} {\partial \theta_j}\;,
(\#eq:varkrigingvar)
\end{equation}

with $p$ the number of semivariogram parameters, $\mathrm{Cov}(\theta_i,\theta_j)$ the covariances of the semivariogram parameters $\theta_i$ and $\theta_j$ (elements of the inverse of the Fisher information matrix $\mathbf{I}^{-1}(\boldsymbol{\theta})$) (Equation \@ref(eq:FisherInformation)), and $\frac{\partial V_{\mathrm{OK}}(\mathbf{s}_0)} {\partial \theta_i}$ the partial derivative of the kriging variance to the $i$th semivariogram parameter at prediction location $\mathbf{s}_0)$.

The first step is to select a sample for the second sampling round in which data are collected for mapping. For this a spatial coverage sample is selected, using function `stratify` of package **spcosa**, see Chapter \@ref(SpatialCoverage). The observations on this sample are used for prediction by kriging. The population mean of VKV (MVKV) is used as a minimisation criterion. This population mean is estimated from a centred square grid of 101 points, the evaluation sample. (In the code chunk below `n=100` is used in function `spsample`, but actually 101 locations are selected.) 

```{r}
library(spcosa)
grd <- grdHunterValley
names(grd)[c(1,2)] <- c("s1","s2")
gridded(grd) <- ~s1+s2
n <- 100
set.seed(314)
myStrata <- stratify(grd, nStrata=n, equalArea=FALSE, nTry=10)
mySCsample <- as(spsample(myStrata), "SpatialPoints")
myevalsample <- spsample(
  x=grd, n=100, type="regular", offset=c(0.5,0.5))
```

The following code chunks show how the estimation variance of the kriging variance at the evaluation point is computed. First the correlation matrix of the spatial coverage sample (`A`), and the correlation matrix of the spatial coverage sample and the evaluation points (`A0`) is computed. Correlation matrix `A` is extended with a column and row with ones, see Equation \@ref(eq:krigingeqsmatrix).

```{r}
D <- spDists(mySCsample)
vgmodel <- vgm(model="Exp", psill=thetas[1], range=thetas[2],
               nugget=1-thetas[1])
A <- variogramLine(vgmodel, dist_vector=D, covariance=TRUE)
nobs <- length(mySCsample)
B <- matrix(data=0, nrow=nobs+1, ncol=nobs+1)
B[1:nobs,1:nobs] <- A
B[1:nobs,nobs+1] <- 1
B[nobs+1,1:nobs] <- 1
D0 <- spDists(x=myevalsample, y=mySCsample)
A0 <- variogramLine(vgmodel, dist_vector=D0, covariance=TRUE)
```

Next the semivariogram parameters are perturbed one-by-one, and the perturbed correlation matrices `pA` and `pA0` are computed.

```{r}
pA  <- pA0 <- list()
for (i in 1:length(thetas)) {
  thetas_pert <- thetas
  thetas_pert[i] <- (1+perturbation)*thetas[i]
  vgmodel_pert <- vgm(
    model="Exp", psill=thetas_pert[1], 
    range=thetas_pert[2], nugget=1-thetas_pert[1]) 
  pA[[i]] <- variogramLine(
    vgmodel_pert, dist_vector=D, covariance=TRUE)
  pA0[[i]] <- variogramLine(
    vgmodel_pert, dist_vector=D0, covariance=TRUE)
}
pB <- pb <- list()
for (i in 1:length(thetas)) {
  pB[[i]] <- B
  pB[[i]][1:nobs,1:nobs] <- pA[[i]]
  pb[[i]] <- cbind(pA0[[i]],1)
}
```

Next the kriging variance and perturbed kriging variances are computed, and the partial derivatives of the kriging variance with respect to the semivariogram parameters are approximated. See Equations \@ref(eq:krigingweights) and \@ref(eq:OKvariance) for how the kriging weights `l` and the kriging variance `var` are computed.

```{r}
var <- numeric(length=length(myevalsample))
pvar <- matrix(nrow=length(myevalsample), ncol=length(thetas))
for (i in 1:length(myevalsample)) {
  b <- c(A0[i,],1)
  #compute kriging weights and Lagrange multiplier
  l <- solve(B,b) 
  var[i] <- 1-l[1:nobs]%*%A0[i,]-l[nobs+1]
  for (j in 1:length(thetas)){
    pl <- solve(pB[[j]], pb[[j]][i,])
    pvar[i,j] <- 1-pl[1:nobs]%*%pA0[[j]][i,]-pl[nobs+1]
  }
}
dvar <- list()
for (i in 1:length(thetas)) {
  dvar[[i]] <- (pvar[,i]-var)/(thetas[i]*perturbation)
}
```

Finally the partial derivatives of the kriging variance are used to approximate the estimation variance of the kriging variance. For this the variances and covariances of the estimated semivariogram parameters are needed, estimated by the inverse of the Fisher information matrix (`invI`), see Equation \@ref(eq:varkrigingvar). Matrix `invI` computed in the previous Section \@ref(UncertainSemivariogramParameters) for the simple random sample of 100 points is used for this. Note that this variance-covariance matrix is computed from the sample for variogram estimation, not from the spatial coverage sample of the second sampling round used for prediction. 

```{r}
VKV <- numeric(length=length(var))
for (i in 1:length(thetas)){
  for (j in 1:length(thetas)){
    VKVij <- invI[i,j]*dvar[[i]]*dvar[[j]]
    VKV <- VKV+VKVij
  }
}
MVKV0 <- mean(VKV)
```

For the simple random sample of 100 points the square root of the estimation variance of the kriging variance at the evaluation point equals `r round(sqrt(MVKV0),3)`. The mean kriging variance at these points equals `r round(mean(var),3)`, so the uncertainty about the kriging variance is substantial. Hereafter we will see how much this estimation variance can be reduced by optimising the sample with spatial simulated annealing.

As for logdet the sample with minimum value for MVKV can be searched for using **spsann** function `optimUSER`. The objective function `varkrigvar` is defined in **R** script [ObjectiveFunctions4MBSamplingVariogram.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Rscripts/ObjectiveFunctions4MBSamplingVariogram.R)^[https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Rscripts/ObjectiveFunctions4MBSamplingVariogram.R]. Argument `points` specifies the size of the sample for variogram estimation. A simple random sample of size 100 is used as an initial sample. The argument `psample` is used to  specify the sample used for prediction at the evaluation points (after the second round of sampling). The argument `esample` is to specify the sample with evaluation points, used to estimate the population mean of VKV.

```{r, eval=FALSE}
source ("Rscripts/ObjectiveFunctions4MBSamplingVariogram.R")
schedule <- scheduleSPSANN(
  initial.acceptance=0.8,
  initial.temperature=0.0004, temperature.decrease=0.8,
  chains=500, chain.length=2, stopping=5,
  x.min=0, y.min=0, cellsize=50)
set.seed(314)
rslt <- optimUSER(
  points=100, candi=candi,
  fun=varkrigvar,
  psample=mySCsample, esample=myevalsample,
  model= "Exp", thetas=thetas,
  perturbation=0.01, schedule=schedule, track=TRUE)
```

```{r, eval=FALSE, echo=FALSE}
save(rslt,file="results/MBSample_VV_phi200nug02_HunterValley.RData")
```

```{r, echo=FALSE}
load(file="results/MBSample_VV_phi200nug02_HunterValley.RData")
MVKVopt <- tail(rslt$objective$energy$obj,1)
```

Figure \@ref(fig:MBVariogram) shows the optimised sample. The minimised value of MVKV is `r round(100*MVKVopt/MVKV0,0)` \% of the value of the simple random sample used to illustrate the computations. As for logdet the optimised sample shows strong spatial clustering. However, the shape is quite different. The sample minimised for MVKV is more a spatial coverage sample of an ellipse.

```{r MBVariogram, echo=FALSE, out.width='100%', fig.cap="Optimised pattern of 100 sampling points for semivariogram estimation, using the logarithm of the determinant of the inverse Fisher information matrix (logdet) or the mean estimation variance of the kriging variance (MVKV) as minimisation criterion."}
load(file="results/MBSample_logdet_phi200nug02_HunterValley.RData")
mysample_logdet <- rslt$points

load(file="results/MBSample_VV_phi200nug02_HunterValley.RData")
mysample_MVKV <- rslt$points

mysamples <- rbind(mysample_logdet,mysample_MVKV)
mysamples$criterion <- rep(c("logdet","MVKV"),each=100)

ggplot(mysamples) +
  geom_raster(data=grdHunterValley, mapping=aes(x=Easting/1000, y=Northing/1000), fill="grey") +
  geom_point(mapping=aes(x=x/1000, y=y/1000), shape =1, size=1.5 ) +
  scale_x_continuous(name="Easting (km)") +
  scale_y_continuous(name="Northing (km)") +
  facet_wrap(~ criterion) +
  coord_fixed()
```

Both minimisation criteria, logdet and MVKV, are a function of the semivariogram parameters $\boldsymbol{\theta}$, showing that the problem is circular. Using a preliminary estimate of the semivariogram parameters, $\hat{\boldsymbol{\theta}}$, leads to a locally optimal design at $\hat{\boldsymbol{\theta}}$. For that reason @bog99 and @zhu05 proposed a Bayesian approach in which a multivariate prior distribution for the semivariogram parameters is postulated, and the expected value over this distribution of the criterion is minimised. @lar02 computed the average of the estimation variance of the kriging variance over a number of semivariograms.

Both methods for sample optimisation rely on, amongst others, the assumption that the mean and variance are constant throughout the area. Under this assumption it is no problem that the sampling units are spatially clustered. So we assume that the semivariogram estimated from the data collected in a small portion of the study area is representative for the whole study area. If we do not feel comfortable with this assumption, spreading out the sampling units by the sampling methods described in the next two sections can be a good option.   

#### Exercises {-}

3. Write an **R** script to design a model-based sample of 100 points for the Hunter Valley, to estimate the semivariogram for a study variable. Use logdet as a minimisation criterion. Optimisation with this criterion requires a prior estimate of the semivariogram.  Use for this an exponential semivariogram with a distance parameter of 200 m and a ratio of spatial dependence of 0.5. Compare the sample with the optimised sample in Figure \@ref(fig:MBVariogram), which was obtained with a spatial dependence ratio of 0.8. 
4. Repeat this for MVKV as a minimisation criterion. 

## Model-based optimisation of a single sample pattern for both semivariogram estimation and prediction {#SamplingEstimationandPrediction}

In practice, often a reconnaissance survey for semivariogram estimation is not feasible, and a single sample must be designed that is suitable both for estimating the model parameters and prediction with the estimated model parameters. Another reason is that in a reconnaissance survey we seldom can afford a sample size large enough to obtain reliable estimates of the model parameters. @Papritz2011 found that for a sample size of 192 points the estimated variance components with balanced and unbalanced nested designs were highly uncertain. For this reason it is attractive to use also the sampling points designed for spatial prediction (mapping) for estimating the semivariogram. From this it follows that designing two samples, one for estimating the semivariogram and one for spatial prediction, is suboptimal. Designing one sample that can be used both for estimation of the model parameters and for prediction potentially is more efficient.

Finally, with nested sampling and sampling of independent pairs of points we aim at estimating the semivariogram of the residuals of a constant mean (see Equation \@ref(eq:ANOVAmodelnested)). In other words, with these designs we aim at estimating the parameters of a semivariogram model used in ordinary kriging. In situations where we have covariates that can partly explain the spatial variation of the study variable, kriging with an external drift is more appropriate. In these situations the reconnaissance survey should be tailored at estimating both the regression coefficients associated with the covariates and the parameters of the residual semivariogram.

Model-based methods for designing a single sample for estimating the model parameters and for prediction with the estimated model parameters are proposed, amongst others, by @zim06, @zhu06, @zhu06b and @Marchant2007. The methods use a different minimisation criterion. @zim06 proposed to minimise the kriging variance (at the center of a square grid) that is augmented by an amount that accounts for the additional uncertainty in the kriging predictions due to uncertainty in the semivariogram parameters, hereafter referred to as the *augmented kriging variance*\index{Augmented kriging variance} (AKV):

\begin{equation}
AKV(\mathbf{s}_0) = V_\mathrm{OK}(\mathbf{s}_0) + \mathrm{E}[\tau^2(\mathbf{s}_0)]\;,
(\#eq:augmentedvar)
\end{equation}

with $V_\mathrm{OK}(\mathbf{s}_0)$ the ordinary kriging variance, see Equation \@ref(eq:OKvariance), and $\mathrm{E}[\tau^2(\mathbf{s}_0)]$ the expectation of the additional variance component due to uncertainty about the semivariogram parameters estimated by ML. The additional variance component is approximated by a first order Taylor series):

\begin{equation}
\mathrm{E}[\tau^2(\mathbf{s}_0)]=\sum_{i=1}^p \sum_{j=1}^p \mathrm{Cov}(\theta_i,\theta_j) \frac{\partial \lambda^{\mathrm{T}}} {\partial \theta_i} \mathbf{A}\frac{\partial \lambda} {\partial \theta_j}\;,
(\#eq:tausq)
\end{equation}

with $\frac{\partial \lambda} {\partial \theta_j}$ the vector of partial derivatives of the kriging weights with respect to the $j$th semivariogram parameter. As before in Chapter \@ref(MBSamplePattern) I use the mean of the AKV over the nodes of a prediction grid (evaluation grid) as a minimisation criterion (MAKV). The same criterion can also be used in situations where we have maps of covariates that we want to use in prediction. In that case the aim is to design a single sample that is used both for estimating the *residual* semivariogram and for prediction by kriging with an external drift. The ordinary kriging variance $V_\mathrm{OK}(\mathbf{s}_0)$ in Equation \@ref(eq:augmentedvar) is then replaced by the prediction error variance with kriging with an external drift $V_\mathrm{KED}(\mathbf{s}_0)$, see Equation \@ref(eq:KEDvariance).

@zhu06 proposed as a minimisation criterion a linear combination of the augmented kriging variance (Equation \@ref(eq:augmentedvar) and the estimation variance of the kriging variance (Equation \@ref(eq:varkrigingvar), the *estimation adjusted criterion*\index{Estimation adjusted criterion} (EAC):

\begin{equation}
EAC(\mathbf{s}_0) = AKV(\mathbf{s}_0) + \frac{1}{2V_{\mathrm{OK}}(\mathbf{s}_0)} VKV(\mathbf{s}_0))\;.
(\#eq:EAC)
\end{equation}

Again, the mean of the EAC values (MEAC) over the nodes of a prediction grid (evaluation) is used as a minimisation criterion.

Computing time for optimisation of the coordinates of a large sample, say $> 50$ points, can become prohibitively long. To reduce computing time @zhu06 proposed a two-step approach. In the first step, for a fixed proportion $p \in (0,1)$ the locations of $(1-p) \cdot n$ points are optimised for prediction with given parameters, for instance by minimising MKV. This 'prediction sample' is supplemented with $p\cdot n$ points, so that the two combined samples of size $n$ minimise logdet or MVKV. This is repeated for different values of $p$. In the second step MEAC is computed for the combined samples of size $n$, and the proportion and associated sample with minimum MEAC is selected.

A simplification of this two-step approach is to select in the first step a square grid or a spatial coverage sample (Chapter \@ref(SpatialCoverage)), and to supplement this sample by a fixed number of points whose coordinates are optimised by spatial simulated annealing (SSA), using either MAKV or MEAC computed from both samples (grid sample or spatial coverage sample plus supplemental sample) as a minimisation criterion. In SSA the grid or spatial coverage sample is fixed, i.e. the locations are not further optimised. @Lark2018 recommended as a rule of thumb to add about 10\% of the fixed sample as short distance points.

The following code chunks show how the AKV and EAC can be computed. First a spatial coverage sample of 90 points is selected using function `stratify` of package **spcosa**, see Chapter \@ref(SpatialCoverage). In addition, a simple random sample of ten points is selected. This sample is the initial supplemental sample, whose locations are optimised. A square grid of approximately 100 points is selected for evaluation of the minimisation criterion.

```{r, echo=FALSE}
grd <- grdHunterValley
names(grd)[c(1,2)] <- c("s1","s2")
```

```{r}
library(spcosa)
gridded(grd) <- ~s1+s2
n <- 90
set.seed(314)
myStrata <- stratify(grd, nStrata=n, equalArea=FALSE, nTry=10)
mySCsample <- as(spsample(myStrata), "SpatialPoints")
nsup <- 10
units <- sample.int(nrow(grd), nsup)
mysupsample0 <- as(grd[units,], "SpatialPoints")
myevalsample <- spsample(
  x=grd, n=100, type="regular", offset=c(0.5,0.5))
```

The next step is to compute the inverse of the Fisher information matrix, given a preliminary semivariogram model, which is used as the variance-covariance matrix of the estimated semivariogram parameters. Contrary to Section \@ref(samplingforvariogram) now *all* sampling locations are used to compute this matrix. The locations of the spatial coverage sample and the supplemental sample are merged into one `SpatialPoints` object.  

```{r}
mysample <- rbind(mysupsample0, mySCsample)
```

For how the inverse of the Fisher information matrix is computed, I refer to the code chunks in Section \@ref(samplingforvariogram). 

```{r, echo=FALSE}
D <- spDists(mysample)
vgmdl <- vgm(model="Exp", psill=thetas[1], range=thetas[2], nugget=1-thetas[1])
A <- variogramLine(vgmdl, dist_vector=D, covariance=TRUE)
pA <- dA <- list()
for (i in 1:length(thetas)) {
  thetas_pert <- thetas
  thetas_pert[i] <- (1+perturbation)*thetas[i]
  vgmdl <- vgm(model="Exp", psill=thetas_pert[1],
               range=thetas_pert[2], nugget=1-thetas_pert[1]) 
  pA[[i]] <- variogramLine(vgmdl, dist_vector=D, covariance=TRUE)
  dA[[i]] <- (pA[[i]]-A)/(thetas[i]*perturbation)
}

invA <- chol2inv(chol(A))

I <- matrix(0, length(thetas), length(thetas))
for (i in 1:length(thetas)){
  for (j in i:length(thetas)){
    I[i,j]=I[j,i]=0.5*matrix.trace(invA%*%dA[[i]]%*%invA%*%dA[[j]])
  }
}
    
invI <- chol2inv(chol(I))

nobs <- length(mysample)
nrowB <- nobs + 1
B <- matrix(data=0, nrow=nrowB, ncol=nrowB)
B[1:nobs,1:nobs] <- A
B[1:nobs,(nobs+1):nrowB] <- 1
B[(nobs+1):nrowB,1:nobs] <- 1

#compute matrix with covariances between prediction nodes and sampling points
D0 <- spDists(x=myevalsample, y=mysample)
vgmodel <- vgm(model="Exp", psill=thetas[1], range=thetas[2], nugget=1-thetas[1])
A0 <- variogramLine(vgmodel, dist_vector=D0, covariance=TRUE)

#compute perturbed B and perturbed b
pB <- pA0 <- pb <- list()
for (i in 1:length(thetas)) {
  pB[[i]] <- B
  pB[[i]][1:nobs,1:nobs] <- pA[[i]]
    
  thetas_pert <- thetas
  thetas_pert[i] <- (1+perturbation)*thetas[i]
  vgmodel_pert <- vgm(model="Exp", psill=thetas_pert[1], range=thetas_pert[2], nugget=1-thetas_pert[1]) 
  pA0[[i]] <- variogramLine(vgmodel_pert, dist_vector=D0, covariance=TRUE)
  pb[[i]] <- cbind(pA0[[i]],1)
}
```

In the next code chunk for each evaluation point the kriging weights (`L`), the kriging variance (`var`), the perturbed kriging weights (`pL`) and perturbed kriging variances (`pvar`) are computed. In the final lines the partial derivatives of the kriging weights (`dL`) and of the kriging variances (`dvar`) with respect to the semivariogram parameters are computed. The partial derivatives of the kriging variances with respect to the semivariogram parameters are needed for computing the estimation variance of the kriging variance, see Equation \@ref(eq:varkrigingvar), which is needed for computing criterion EAC, see Equation \@ref(eq:EAC).

```{r}
L <- matrix(nrow=length(myevalsample), ncol=nobs)
pL <- array(
  dim=c(length(myevalsample),length(mysample),length(thetas)))
var <- numeric(length=length(myevalsample))
pvar <- matrix(nrow=length(myevalsample), ncol=length(thetas))
for (i in 1:length(myevalsample)) {
  b <- c(A0[i,],1)
  l <- solve(B,b)
  L[i,] <- l[1:nobs]
  var[i] <- 1-l[1:nobs]%*%A0[i,]-l[-(1:nobs)]
  for (j in 1:length(thetas)){
    pl <- solve(pB[[j]], pb[[j]][i,])
    pL[i,,j] <- pl[1:nobs]
    pvar[i,j] <- 1-pl[1:nobs]%*%pA0[[j]][i,]-pl[-(1:nobs)]
  }
}
dL <- dvar <- list()
for (i in 1:length(thetas)) {
  dL[[i]] <- (pL[,,i]-L)/(thetas[i]*perturbation)
  dvar[[i]] <- (pvar[,i]-var)/(thetas[i]*perturbation)
}         
```

In the next code the expected variance due to uncertainty about the semivariogram parameters (Equation \@ref(eq:tausq)) is computed.

```{r}
tausq <- numeric(length=length(myevalsample))
tausqk <- 0
for (k in 1:length(myevalsample)) {
  for (i in 1:length(dL)){
    for (j in 1:length(dL)){
      tausqijk <- invI[i,j]*t(dL[[i]][k,])%*%A%*%dL[[j]][k,] 
      tausqk <- tausqk+tausqijk
    }
  }
  tausq[k] <- tausqk
  tausqk <- 0
}
```

The AKVs are computed by adding the kriging variances and the extra variances due to semivariogram uncertainty (Equation \@ref(eq:augmentedvar)). The estimation variances of the kriging variances are computed (`VKV`), and the EAC values. Both the AKV and EAC differ among the evaluation points. As a summary, the mean of the two variables is computed.

```{r}
augmentedvar <- var+tausq
MAKV0 <- mean(augmentedvar)
VKV <- numeric(length=length(var))
for (i in 1:length(dvar)){
  for (j in 1:length(dvar)){
    VKVij <- invI[i,j]*dvar[[i]]*dvar[[j]]
    VKV <- VKV+VKVij
  }
}
EAC <- augmentedvar+(VKV/(2*var))
MEAC0 <- mean(EAC)
```

For the spatial coverage sample of 90 points supplemented by a simple random sample of ten points MAKV equals `r round(MAKV0,3)`, MEAC equals `r round(MEAC0,3)`.

The sample can be optimised with **spsann** function `optimUSER`. The argument `points` is a list containing a data frame (or matrix) with the coordinates of the fixed points (specified with sub-argument `fixed`), and an integer of the number of supplemental points of which the locations are optimised (specified with sub-argument `free`). Recall that an important difference with Section \@ref(samplingforvariogram) is that the free and fixed sample are merged, and are used together, both for estimating the semivariogram and for prediction. The objective functions `augvar` and `EAC` are defined in **R** script [ObjectiveFunctions4MBSamplingVariogram.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Rscripts/ObjectiveFunctions4MBSamplingVariogram.R)^[https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Rscripts/ObjectiveFunctions4MBSamplingVariogram.R].

```{r, eval=FALSE}
source ("Rscripts/ObjectiveFunctions4MBSamplingVariogram.R")
schedule <- scheduleSPSANN(
  initial.acceptance=0.8,
  initial.temperature=0.008, temperature.decrease=0.8,
  chains=500, chain.length=20, stopping=10,
  x.min=0, y.min=0, cellsize=50)
fixed <- coordinates(mySCsample)
names(fixed) <- c("x","y")
pnts <- list(fixed=fixed, free=10)
set.seed(314)
rslt <- optimUSER(
  points=pnts, candi=candi,
  fun=augvar,
  esample=myevalsample,
  model="Exp", thetas=thetas, perturbation=0.01,
  schedule=schedule, track=TRUE)
```

```{r, eval=FALSE, echo=FALSE}
save(rslt,mySCsample,myStrata,file="results/MBSample_augvar_phi200nug02_HunterValley.RData")
```


```{r, echo=FALSE, eval=FALSE}
source ("Rscripts/ObjectiveFunctions4MBSamplingVariogram.R")
schedule <- scheduleSPSANN(
  initial.acceptance=0.8,
  initial.temperature=0.01,
  temperature.decrease=0.8,
  chains=500,
  chain.length=20,
  stopping=10,
  x.min=0,y.min=0,
  cellsize=50)
set.seed(314)
rslt <- optimUSER(
  points=pnts,
  candi=candi,
  fun=EAC,
  esample=myevalsample,
  model= "Exp",
  thetas=thetas,
  perturbation=0.01,
  schedule=schedule,
  track=TRUE)
save(rslt,mySCsample,myStrata,file="results/MBSample_EAC_phi200nug02_HunterValley.RData")
```

Figure \@ref(fig:FigMBEK) shows for the Hunter Valley spatial coverage samples of 90 points, supplemented by ten points optimised by SSA, using MAKV and MEAC as a minimisation criterion.

```{r FigMBEK, echo=FALSE, out.width='100%', fig.cap="Optimised sample of ten points supplemented to spatial coverage sample, for semivariogram estimation and prediction, using the mean augmented kriging variance (MAKV) or the mean estimation adjusted criterion (MEAC) as minimisation criterion."}
load(file="results/MBSample_augvar_phi200nug02_HunterValley.RData")
mysample <- rslt$points
MAKVopt <- tail(rslt$objective$energy$obj,1)

units <-which(mysample$free==1)
mysupsample_AKV <- mysample[units,c("x","y")]
myscsample_AKV <- mysample[-units,c("x","y")]

#compute shortest distance from supplemental point to spatial coverage points
D <- spDists(x=as(mysupsample_AKV,"matrix"), y=as(myscsample_AKV,"matrix"))
DminAV <- apply(D, MARGIN=1, FUN=min)

#compute distance between neighbouring spatial coverage points
DSC <- spDists(x=as(myscsample_AKV,"matrix"), y=as(myscsample_AKV,"matrix"))
diag(DSC) <- NA
DSCmin <- apply(DSC,MARGIN=1, FUN=min, na.rm=T)
mDSCmin <- mean(DSCmin)

load(file="results/MBSample_EAC_phi200nug02_HunterValley.RData")
mysample <- rslt$points
MEACopt <- tail(rslt$objective$energy$obj,1)

units <-which(mysample$free==1)
mysupsample_EAC <- mysample[units,c("x","y")]
myscsample_EAC <- mysample[-units,c("x","y")]

#compute shortest distance from supplemental point to spatial coverage points
D <- spDists(x=as(mysupsample_EAC,"matrix"), y=as(myscsample_EAC,"matrix"))
DminEAC <- apply(D,MARGIN=1, FUN=min)

mysupsamples <- rbind(mysupsample_AKV,mysupsample_EAC)
mysupsamples$criterion <- rep(c("AKV","EAC"), each=10)

myscsamples <- rbind(myscsample_AKV,myscsample_EAC)
myscsamples$criterion <-  rep(c("AKV","EAC"), each=90)

plot(myStrata) +
  geom_point(data=myscsamples, mapping=aes(x=x, y=y), shape=1, size=1.5 ) +
  geom_point(data=mysupsamples, mapping=aes(x=x, y=y), shape=3, size=1.5, colour="red") +
  coord_fixed() +
  facet_wrap(~ criterion)
```

Figure \@ref(fig:FigMBEK) shows that with MAKV as a minimisation criterion there is one point that is very close to a spatial coverage sample point (distance $<2$ m.). A histogram of the shortest distance to the spatial coverage sample is shown in Figure \@ref(fig:HistogramShortestDistance). With MEAC two points are at very short distance of the spatial coverage sample ($< 3$ m). The average distance between neighbouring spatial coverage sampling points equals `r round(mDSCmin,0)`. 

```{r HistogramShortestDistance, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap="Shortest distance of supplemental sample, optimised with mean augmented kriging variance (AKV) and mean estimation adjusted criterion (EAC), to spatial coverage sample."}

df <- data.frame(AKV=DminAV, EAC=DminEAC)

dflf <- df %>% pivot_longer(cols=c("AKV","EAC"))
ggplot(data=dflf) +
  geom_histogram(aes(x=value), fill="black", alpha=0.5, colour="black", binwidth=25) +
  xlab("Minimum distance") +
  facet_grid(~ name)
```

The MAKV of the optimised sample equals `r round(MAKVopt,3)` which is `r round(MAKVopt/MAKV0*100,0)`\% of the MAKV of the initial sample. The MEAC of the optimised sample equals `r round(MEACopt,3)` which is `r round(MEACopt/MEAC0*100,0)`\% of the MEAC of the initial sample. The reduction of these two criteria through the optimisation is much smaller than for logdet and MVKV in Section \@ref(samplingforvariogram). This can be explained by the small number of sampling units that is optimised: only the locations of ten units are optimised, 90 are fixed. In Section \@ref(samplingforvariogram) all 100 locations were optimised.

#### Exercises {-}
5. Write an **R** script to select from the Hunter Valley a spatial coverage sample of 90 points supplemented by 10 points. Use MEAC as a minimisation criterion, an exponential semivariogram with a distance parameter of 200 m and a ratio of spatial dependence of 0.5. Compare the sample with the optimised sample in Figure \@ref(fig:FigMBEK), which was obtained with a spatial dependence ratio of 0.8. 

## A practical solution

Based on the optimised samples shown above, a very straightforward, simple sampling design for estimating the model parameters and for prediction is a spatial coverage sample supplemented with randomly selected points in between the points of the spatial coverage sample at some chosen, fixed distances. Figure \@ref(fig:SpatialCoveragePlus) shows an example. A subsample of ten points is selected from the 90 points of the spatial coverage sample, using simple random sampling without replacement. These points are used as a starting point to select a point at a distance of 20 m in a random direction.

```{r, echo=FALSE}
mySCsample <- myscsample_AKV
```

```{r}
h <- 20
m <- 10
set.seed(314)
units <- sample.int(nrow(mySCsample), m, replace=FALSE)
mySCsubsample <- mySCsample[units,]
dxy <- matrix(nrow=m, ncol=2)
angle <- runif(n=m, min=0, max=2*pi)
dxy[,1]=h*sin(angle); dxy[,2]=h*cos(angle)
mysupsample <- mySCsubsample+dxy
```

```{r SpatialCoveragePlus, echo=FALSE, out.width='70%', fig.cap="Spatial coverage sample of 90 points supplemented by ten points at short distance (20 m) from randomly selected spatial coverage point."}
plot(myStrata) +
    geom_point(data=mySCsample, mapping=aes(x=x, y=y), shape=1, size=1.5) +
    geom_point(data=mysupsample, mapping=aes(x=x, y=y), shape=3, size=1.5, colour="red")
```

```{r, echo=FALSE}
mysample <- rbind(mysupsample, mySCsample)
coordinates(mysample) <- ~x+y
D <- spDists(mysample)
A <- variogramLine(vgm(model="Exp", psill=thetas[1], range=thetas[2], nugget=1-thetas[1]),
                   dist_vector=D, covariance=TRUE)
pA <- dA <- list()
for (i in 1:length(thetas)) {
  thetas_pert <- thetas
  thetas_pert[i] <- (1+perturbation)*thetas[i]
  vgmodel_pert <- vgm(model="Exp", psill=thetas_pert[1], range=thetas_pert[2], nugget=1-thetas_pert[1]) 
  pA[[i]] <- variogramLine(vgmodel_pert, dist_vector=D, covariance=TRUE)
  dA[[i]] <- (pA[[i]]-A)/(thetas[i]*perturbation)
}
  
invA <- chol2inv(chol(A))

I <- matrix(data=0, nrow=length(thetas), ncol=length(thetas))
for (i in 1:length(thetas)){
  for (j in i:length(thetas)){
    I[i,j]=I[j,i]=0.5*matrix.trace(invA%*%dA[[i]]%*%invA%*%dA[[j]])
  }
}
    
invI <- chol2inv(chol(I))

nobs <- length(mysample)
nrowB <- nobs + 1
B <- matrix(data=0, nrow=nrowB, ncol=nrowB)
B[1:nobs,1:nobs] <- A
B[1:nobs,(nobs+1):nrowB] <- 1
B[(nobs+1):nrowB,1:nobs] <- 1

#compute matrix with covariances between prediction nodes and sampling points
D0 <- spDists(x=myevalsample, y=mysample)
A0 <- variogramLine(vgm(model="Exp", psill=thetas[1], range=thetas[2], nugget=1-thetas[1]),
                    dist_vector=D0, covariance=TRUE)

#compute perturbed B and perturbed b
pB <- pA0 <- pb <- list()
for (i in 1:length(thetas)) {
  pB[[i]] <- B
  pB[[i]][1:nobs,1:nobs] <- pA[[i]]
  thetas_pert <- thetas
  thetas_pert[i] <- (1+perturbation)*thetas[i]
  vgmodel_pert <- vgm(model="Exp", psill=thetas_pert[1], range=thetas_pert[2], nugget=1-thetas_pert[1])
  pA0[[i]] <- variogramLine(vgmodel_pert, dist_vector=D0, covariance=TRUE)
  pb[[i]] <- cbind(pA0[[i]],1)
}
L <- matrix(nrow=length(myevalsample), ncol=nobs)
pL <- array(dim=c(length(myevalsample), length(mysample), length(thetas)))
var <- numeric(length=length(myevalsample))
pvar <- matrix(nrow=length(myevalsample), ncol=length(thetas))
for (i in 1:length(myevalsample)) {
  b <- c(A0[i,],1)
  l <- solve(B,b)
  L[i,] <- l[1:nobs]
  var[i] <- 1 - l[1:nobs] %*% A0[i,] - l[-(1:nobs)]
  for (j in 1:length(thetas)){
    pl <- solve(pB[[j]],pb[[j]][i,])
    pL[i,,j] <- pl[1:nobs]
    pvar[i,j] <- 1 - pl[1:nobs] %*% pA0[[j]][i,] - pl[-(1:nobs)]
  }
}
dL <- dvar <- list()
for (i in 1:length(thetas)) {
  dL[[i]] <- (pL[,,i] - L)/(thetas[i]*perturbation)
  dvar[[i]] <- (pvar[,i]-var)/(thetas[i]*perturbation)
}         
tausq <- numeric(length=length(myevalsample))
tausqk <- 0
for (k in 1:length(myevalsample)) {
  for (i in 1:length(dL)){
    for (j in 1:length(dL)){
      tausqijk <- invI[i,j]*t(dL[[i]][k,])%*%A%*%dL[[j]][k,] 
      tausqk <- tausqk+tausqijk
    }
  }
  tausq[k] <- tausqk
  tausqk <- 0
}
augmentedvar <- var+tausq
MAKVpract <- mean(augmentedvar)
VKV <- numeric(length=length(var))
for (i in 1:length(dvar)){
  for (j in 1:length(dvar)){
    VKVij <- invI[i,j]*dvar[[i]]*dvar[[j]]
    VKV <- VKV+VKVij
  }
}
EAC <- augmentedvar+(VKV/(2*var))
MEACpract <- mean(EAC)
```

The MAKV of this practical sample equals `r round(MAKVpract,3)`, and the MEAC equals `r round(MEACpract,3)`. For MAKV `r round(100*(MAKVpract-MAKVopt)/(MAKV0-MAKVopt),0)`\% of the maximal reduction is realised by this practical solution; for MEAC this is `r round(100*(MEACpract-MEACopt)/(MEAC0-MEACopt),0)`\%.


```{r, echo=FALSE}
rm(list=ls())
```



<!--chapter:end:30-Sampling4VariogramEstimation.Rmd-->

# Sampling for validation of maps {#Validation}

In the previous chapters of Part II various methods are described for selecting sampling units with the aim to map the study variable. Once the map has been made, we would like to know how good it is. It should come as no surprise that the value of the study variable at a randomly selected location as shown on the map differs from the value at that location in reality. This difference is a prediction error. The question is how large this error is on average, and how variable it is. In this chapter I describe and illustrate with a real world case study how to select sampling units at which we will confront the predictions with the true values, and how to estimate map quality indices from the prediction errors at these sampling locations.

If the map has been made with a statistical model, then the predictors are typically model-unbiased and the variance of the prediction errors can be computed from the model. Think for instance of kriging, which also results in a map of the kriging variance. In Chapters \@ref(MBgridspacing) and \@ref(MBSamplePattern) I showed how this kriging variance can be used to optimise the grid spacing (sample size) and the spatial coordinates of the sampling units for mapping. So, if we have a map of these variances, why do we still need to collect new data for estimating the map quality?

The problem is that these kriging variances rely on the validity\index{Validity} of the assumptions made in modelling the spatial variation of the study variable. Do we assume a constant mean, or a mean that is linear combination of some covariates? Which covariates? Or should we model the mean with a non-linear function, as in Random Forests? How good is our estimate of the semivariogram model form and parameters, either for the target variable or the residuals from some model of the covariates? If one or more of these modelling assumptions are violated, the variances of the prediction errors may become biased. For that reason, the quality of the map is preferably  determined through independent validation, i.e. by comparing predictions with observations not used in mapping, and followed by *model-free* design-based estimation of the map quality indices. This process is often referred to as validation\index{Validation}, perhaps better statistical validation, a subset of the more comprehensive term map quality evaluation\index{Map quality evaluation}, which includes the concept of fitness-for-use. 

Statistical validation of maps is often done through data-splitting\index{Data-splitting} or cross-validation\index{Cross-validation}. In data-splitting the data are split into two subsets, one for calibrating the model and mapping, one for validation. In cross-validation the data set is split into a number of disjoint subsets of equal size. Each subset is used one-by-one for calibration and prediction. The remaining subsets are used for validation. Leave-one-out-crossvalidation\index{Cross-validation!leave-one-out-crossvalidation} (LOOCV) is a special case of this, in which each sampling unit is left out one-by-one, and all other units are used for calibration and prediction of the study variable of the unit that is left out. The problem with data-splitting and cross-validation is that the data used for mapping typically are from non-probability samples. This makes model-free estimation of the map quality indices unfeasible [@brus2011d]. Designing a sampling scheme starts with a comprehensive description of the aim of the sampling project [@gru06]. Mapping and validation are different aims, which ask for different sampling approaches. For validation probability sampling is the best option, because then a  statistical model of the spatial variation of the prediction errors is not needed, and map quality indices defined as population parameters (see next section) can be estimated model-free by design-based inference (see also Section \@ref(DBvsMB)).

## Map quality indices

First I would like to emphasize that in validation we want to assess the accuracy of the map as a whole. We are not interested in the accuracy at a sample of population units only. For instance, we would like to know the prediction error averaged over all population units, and not merely the average prediction error at a sample of units. Map quality indices are therefore defined as population means. Because we cannot afford to determine the prediction error for each unit of the mapping area to calculate these population means (if we could do that there would be no need for a mapping model), we have to take a sample of units at a limited number of locations in the mapped area. This sample is then used to *estimate* the population means and our uncertainty about these estimated means, as quantified by their sampling standard errors.

For quantitative maps, i.e. maps depicting a quantitative study variable\index{Quantitative map} popular map quality indices\index{Map quality indices} are the population mean error\index{Population mean error} (ME), the population mean absolute error\index{Population mean absolute error} (MAE) and the population mean squared error\index{Population mean squared error}, defined as

\begin{align}
ME = \frac{1}{N}\sum_{k=1}^N (\hat{z}_k-z_k) \\
MAE = \frac{1}{N}\sum_{k=1}^N (|\hat{z}_k-z_k|) \\
MSE = \frac{1}{N} \sum_{k=1}^N (\hat{z}_k-z_k)^2\;,
(\#eq:mapqualityindices)
\end{align}

with $N$ the total number of units (e.g. pixels) in the population, $\hat{z}_k$ the predicted value for unit $k$, $z_k$ the true value of that unit, and $|\cdot|$ the absolute value operator. For infinite populations the sum must be replaced by an integral. The ME quantifies the systematic error\index{Systematic error}, and ideally  equals 0. It can be positive (in case of overprediction)  and negative (in case of underprediction). Positive and negative errors cancel out, and as a consequence the ME does not quantify the magnitude of the prediction errors. The MAE and RMSE do quantify the magnitude of the errors, they are nonnegative. Often the square root of MSE is taken, denoted by RMSE, so that the units are the same as of the study variable. The RMSE is strongly effected by outliers (large prediction errors), due to the squaring of the errors, and for that reason it is recommended to estimate both MAE and RMSE.

Two other important map quality indices are the population coefficient of determination\index{Population coefficient of determination} and the Nash-Sutcliffe model efficiency coefficient\index{Model efficiency coefficient} (MEC). The population coefficient  of determination $R^2$ is defined as the square of the Pearson correlation coefficient $r$ of the study variable and the predictions of the study variable, given by

\begin{equation}
r = \frac{\sum_{k=1}^{N}(z_k - \bar{z})(\hat{z}_k-\bar{\hat{z}})}{\sqrt{\sum_{k=1}^{N}(z_k- \bar{z})^2}\sqrt{(\hat{z}_k-\bar{\hat{z}})^2}}=\frac{S^2(z,\hat{z})}{S(z)S(\hat{z})}\;,
(\#eq:r)
\end{equation}

with $\bar{z}$ the population mean of the study variable, $\bar{\hat{z}}$ the population mean of the predictions, $S^2(z,\hat{z})$ the population covariance of the study variable and the predictions of $z$, $S(z)$ the population standard deviation of the study variable, and $S(\hat{z})$ the population standard deviation of the predictions. Note that $R^2$ is unaffected by bias, and therefore should not be used in isolation, but always accompanied by ME.

MEC is defined as [@Janssen1995]

\begin{equation}
MEC=1-\frac{\sum_{k=1}^{N}(\hat{z}_k - z_k)^{2}}{\sum_{k=1}^{N}(z_k -\bar{z})^{2}}=1-\frac{MSE}{S^2(z)} \;,
(\#eq:MEC)
\end{equation}

with $S^2(z)$ the population variance\index{Population variance} of the study variable. MEC quantifies the improvement made by the model over using the mean of the observations as prediction. A value of one (MEC = 1) indicates a perfect match between the measured and predicted values of the study variable, whereas a value of 0 indicates that the mean of the measured values is as good a predictor as the model. A negative value occurs when the mean of the measured values is a better predictor than the model, i.e.  when the residual variance is larger than the variance of the measurements.

For categorical maps\index{Categorical map} a commonly used map quality index is the overall purity\index{Overall purity}, which is defined as the proportion of units (finite population) or fraction of the area (infinite populations) that is correctly classified (mapped):

\begin{equation}
P = \frac{1}{N}\sum_{k=1}^N y_k\;,
(\#eq:Purity)
\end{equation}

with $y_k$ an indicator for unit $k$ having value 1 if the predicted class equals the true class, and 0 otherwise:

\begin{equation}
y_k = \left\{
\begin{array}{cc}
1 & \;\;\;\mathrm{if}\;\;\; \hat{c}_k = c_k\\
0 & \;\;\;\mathrm{otherwise}\;,
\end{array}
\right.
(\#eq:indfromy)
\end{equation}

with $c_k$ and $\hat{c}_k$ the true and predicted class of unit $k$, respectively.

The population ME, MSE, $R^2$, MEC and purity can also be defined for subpopulations. For categorical maps natural subpopulations are the classes depicted in the map, the map units. In that case the purity of map unit $u$ is defined as the fraction of the area of map unit $u$ that is correctly mapped as $u$.

A different subpopulation is the part of the population that is *in reality* class $u$ (but possibly not mapped as $u$). We are interested in the fraction of the area covered by this subpopulation that is correctly mapped as $u$. This is referred to as the class representation\index{Class representation} of class $u$, for which I use hereafter the symbol $R_u$.

### Estimation of map quality indices

The map quality indices are defined as population or subpopulation means. To estimate these (sub)population means a design-based sampling approach is most appropriate. Sampling units are selected by probability sampling, and the map quality indices are estimated by model-free, design-based inference. So the ME of a finite population can be estimated by the $\pi$ estimator (see Equation \@ref(eq:HTMean)):

\begin{equation}
\widehat{ME}_{\pi}=\frac{1}{N} \sum_{k \in \mathcal{S}} \frac{1}{\pi_k}e_k \;,
(\#eq:HTME)
\end{equation}

with $e_k = \hat{z}_k-z_k$ the prediction error for unit $k$. By taking the absolute value of the prediction errors, or by squaring the prediction errors $e_k$ in Equation \@ref(eq:HTME), the $\pi$ estimator for the MAE and MSE is obtained. By replacing $e_k$ by the indicator $y_k$ of Equation \@ref(eq:indfromy), the $\pi$ estimator for the overall purity is obtained.

With simple random sampling the square of the sample correlation coefficient, i.e. the correlation of the study variable and the predictions of the study variable in the sample, is an unbiased estimator of $R^2$. See @sar92 (p.486-491) for how to estimate $R^2$ for other sampling designs.

The population MEC can be estimated by

\begin{equation}
\widehat{MEC}=1-\frac{\widehat{MSE}}{\widehat{S^2}(z)}\;,
(\#eq:HTMEC)
\end{equation}

For simple random sampling the sample variance\index{Sample variance}, i.e. the variance of the observations of $z$ in the sample, is an unbiased estimator of the population variance $S^2(z)$. For other sampling designs this population variance can be estimated by Equation \@ref(eq:EstimatorPopulationVariance4AnyDesign).

Estimation of the class representations is slightly more difficult because the sizes of the classes (number of pixels or areas where in reality class $u$ is present) are unknown, and therefore must also be estimated from the sample. This leads to the estimator of a ratio [@brus2011d]:

\begin{equation}
\hat{R}_{u,\text{ratio}}=\frac{\sum_{k \in \mathcal{S}}\frac{y_k}{\pi_k}}{\sum_{k \in \mathcal{S}}\frac{x_k}{\pi_k}}\;,
\label{RatioEstimatorClassRepresentation}
\end{equation}

where $y_{u,k}$ denotes an indicator defined as

\begin{equation}
y_{u,k} = \left\{
\begin{array}{cc}
1 & \;\;\;\mathrm{if}\;\;\; \hat{c}_k = c_k =  u\\
0 & \;\;\;\mathrm{otherwise}\;,
\end{array}
\right.
(\#eq:indicatorfromy)
\end{equation}

and $x_k$ denotes an indicator defined as

\begin{equation}
x_k = \left\{
\begin{array}{cc}
1 & \;\;\;\mathrm{if}\;\;\; c_k = u\\
0 & \;\;\;\mathrm{otherwise}\;.
\end{array}
\right.
(\#eq:indicatorfromx)
\end{equation}

This estimator is also recommended in situations where the sample size is not fixed but varies among samples selected with the sampling design. This is the case, for instance, when estimating the mean error or purity of a given map unit from a simple random sample. The number of selected sampling units within the map unit is uncontrolled and varies between simple random samples. In this case we can either estimate the mean error or purity of a map unit $u$ by using the *known* size (area, number of pixels) of map unit $u$ in the denominator, or the *estimated* size. Interestingly, by dividing by the *estimated* size of the map unit instead of its known area, the estimator generally becomes more precise [@sar92]. See also Section \@ref(LargeDomainsDirectEstimator). 

In principle all probability sampling designs described in Part I are appropriate for validation. @steh99 and @brus2011d evaluated five basic probability sampling designs, and concluded that in general stratified random sampling is a good choice. For validation of categorical maps natural strata are the map units, i.e. the groups of polygons or grid cells assigned to each class. Systematic random sampling is less suitable as no unbiased estimator of the sampling variance of the estimator of the population mean exists for this design (see Chapter \@ref(SY)). For validation of maps of extensive areas, think of whole continents, travel time between sampling locations can become substantial. In this case sampling designs that lead to spatial clustering\index{Spatial clustering} of validation locations can become efficient, for instance two-stage cluster random sampling (Chapter \@ref(Twostage)) or cluster random sampling (Chapter \@ref(Cl)).

## Real-world case study

As an illustration two soil maps of the three northern counties of Xuancheng City (Anhui province, China), both depicting soil organic matter (SOM) concentration (g/kg) in the topsoil, are evaluated. In Section \@ref(Ospats) the data of three samples, including the stratified random sample, were merged to estimate the parameters of a spatial model for the natural log of SOM. Here only the data of the two non-random samples are used to map SOM. The stratified simple random sample is used for validation.

Two methods are used in mapping, kriging with an external drift\index{Kriging!kriging with an external drift} (KED) and a machine learning method, random forest\index{Random forest} (RF). For mapping with RF seven covariates are used: planar curvature, profile curvature, slope, temperature, precipitation, topographic wetness index and elevation. For mapping with KED only the two most important covariates in the RF model are used: precipitation and elevation. The two maps are evaluated by statistical validation with a stratified simple random sample of 62 units (points). The strata are the eight units of a geological map (Figure \@ref(fig:validationsample)).

```{r validationsample, echo=FALSE, fig.cap="Stratified simple random sample for validation of the map of soil organic map concentrations in topsoil of Xuancheng, China."}
load(file="data/Xuancheng_RFKED.RData")

library(raster)

rmap <- raster("data/Xuancheng_geo.tif")
grd <- as(rmap,"SpatialPixelsDataFrame")
gridded(grd) <- FALSE
grd <- as(grd,"data.frame")
units <- which(grd$Xuancheng_geo==99)
grd <- grd[-units,]
#1: granite and granodiorite
#2: pyroclastic rocks
#3: conglomerate
#4: sandstone
#5: limestone
#6: Quaternary siltstone, gravel and sandy clay
#7: Quaternary vermicule boulder and gravel clay
#8: shale

mysample <- read.csv(
  file="data/Xuancheng_Stratifiedrandomsample.csv",header=TRUE)

ggplot(data=grd) +
  geom_raster(mapping = aes(x = x/1000, y = y/1000,fill=factor(Xuancheng_geo))) +
  scale_fill_viridis_d(name = "Stratum") +
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  geom_point(data=mysample,mapping = aes(x=X/1000,y=Y/1000),size=2) +
coord_fixed()
```

The two maps that are to be validated are shown in Figure \@ref(fig:validatedmaps). Note that non-soil areas (built-up, water, roads) are not predicted. The maps are quite similar. The most striking difference between the maps is the highest and lowest predictions by KED that are not seen in the RF map.

```{r validatedmaps, echo=FALSE, fig.cap="Map of soil organic matter concentration (g/kg) in the topsoil of Xuancheng, obtained by kriging with an external drift (KED) and random forest (RF)."}

df <- grid[,c("x1","x2","KED","RF")]
df_lf <- df %>% pivot_longer(cols=c("KED","RF"))

ggplot(df_lf) +
  geom_raster(mapping = aes(x = x1/1000, y = x2/1000, fill=value)) +
  scale_fill_viridis_c(name="SOM", limits=c(5,90)) + 
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  facet_wrap(~ name, ncol=1, nrow=2) +
  coord_fixed()
```

### Estimation of the population Mean Error and Mean Squared Error

To estimate the population MSE of the two maps, first the squared prediction errors are computed. The name of the measured study variable at the validation sample\index{Validation sample} in the data frame `mysample` is `SOM_A_hori`. Four new columns are added to `mysample`, by computing the prediction errors for KED and RF, and squaring these errors. The next code chunks show the computations for KED only.

```{r}
mysample <- read.csv(
  file="data/Xuancheng_Stratifiedrandomsample.csv", header=TRUE)
mysample$eKED <- mysample$SOM_A_hori-mysample$KED
mysample$e2KED <- (mysample$eKED)^2
```

```{r, echo=FALSE}
mysample$eRF <- mysample$SOM_A_hori-mysample$RF
mysample$e2RF <- (mysample$eRF)^2
```

These four new variables now are our study variables, of which we would like to estimate the population means. These population means can be estimated as explained in Chapter \@ref(STSI). First the stratum weights are computed, that is the relative number of raster cells.

```{r}
strata <- read.csv(file="data/Xuancheng_StrataSize.csv")
w_h <- strata$Nh/sum(strata$Nh)
```

Now the stratum means of the prediction errors, obtained with KED and RF, are estimated by the sample means, and the populations mean of the errors are estimated by the weighted mean of the estimated stratum means.

```{r}
me_KED_h <- tapply(mysample$eKED, INDEX=mysample$stratum, FUN=mean)
me_KED <- sum(w_h*me_KED_h)
```

```{r, echo=FALSE}
me_RF_h <- tapply(mysample$eRF, INDEX=mysample$stratum, FUN=mean)
me_RF <- sum(w_h*me_RF_h)
```

This is repeated for the squared prediction errors.

```{r}
mse_KED_h <- tapply(mysample$e2KED, INDEX=mysample$stratum,
                   FUN=mean)
mse_KED <- sum(w_h*mse_KED_h)
```

```{r, echo=FALSE}
mse_RF_h <- tapply(mysample$e2RF, INDEX=mysample$stratum,
                  FUN=mean)
mse_RF <- sum(w_h*mse_RF_h)
```

#### Exercises {-}

1. The estimated MSE of the KED map equals `r as.character(round(mse_KED,1))`, that of the RF map `r as.character(round(mse_RF,1))`. Are you certain that the population MSE of the KED map is smaller than the population MSE of the RF map? 

### Estimation of the standard error of the estimated population ME and MSE

We are uncertain about both population MSE's, as we measured the squared errors at `r nrow(mysample)` sampling points only. So we would like to know how uncertain we are. This uncertainty is quantified by the standard error of the estimated population MSE. A problem is that in the second stratum we have only one sampling point. So for this stratum we cannot compute the variance of the squared errors. To compute the variance we need at least two sampling points. 

```{r}
table(mysample$stratum)
```

A solution is to merge stratum 2 with stratum 1, which is a similar geological map unit (we know this from the domain expert). This is referred to as collapsing the strata. A look-up table is constructed to add the collapsed strata identifiers to the `data.frame` `mysample` and `strata`, using function `merge` of the **base** R library.

```{r}
levels <- sort(unique(mysample$stratum))
collapsedstrata <- c(1,1,2,3,4,5,6,7)
# look-up table
lut <- data.frame(stratum=levels, collapsedstrata)
mysample <- merge(x=mysample, y=lut)
strata <- merge(x=strata, y=lut)
```

Now the collapsed strata\index{Collapsed strata} can be used to estimate the standard errors of the estimated population MSE's. As a first step the stratum weights and the sample sizes of the collapsed strata are computed.

```{r}
N_hc <- tapply(strata$Nh, INDEX=strata$collapsedstrata, FUN=sum)
w_hc <- N_hc/sum(N_hc)
n_hc <- table(mysample$collapsedstrata)
```

The sampling variance of the estimator of the mean of the (squared) prediction error can be estimated by Equation \@ref(eq:EstVarMeanSTSI). In the next code chunk this is shown for the RF predictions only.

```{r}
s2e_KED_hc <- tapply(
  mysample$eKED, INDEX=mysample$collapsedstrata, FUN=var)
se_me_KED <- sqrt(sum(w_hc^2*s2e_KED_hc/n_hc))
s2e2_KED_hc <- tapply(
  mysample$e2KED, INDEX=mysample$collapsedstrata, FUN=var)
se_mse_KED <- sqrt(sum(w_hc^2*s2e2_KED_hc/n_hc))
```

```{r, echo=FALSE}
s2e_RF_hc <- tapply(mysample$eRF, INDEX=mysample$collapsedstrata,
                   FUN=var)
se_me_RF <- sqrt(sum(w_hc^2*s2e_RF_hc/n_hc))
s2e2_RF_hc <- tapply(mysample$e2RF, INDEX=mysample$collapsedstrata,
                    FUN=var)
se_mse_RF <- sqrt(sum(w_hc^2*s2e2_RF_hc/n_hc))
```


```{r validationresults, echo=FALSE}
valres <- data.frame(KED=c(round(me_KED,2), round(mse_KED,1)), 
                     seKED=c(round(se_me_KED,2), round(se_mse_KED,1)),
                     RF=c(round(me_RF,2), round(mse_RF,1)),
                     seRF=c(round(se_me_RF,2), round(se_mse_RF,1)))
rownames(valres) <- c("ME","MSE")

knitr::kable(
  valres, caption = 'Estimated population mean error (ME) and mean squared error (MSE) of KED and RF map, and their standard errors.',
  booktabs = TRUE
) %>%
  kable_classic()
```

#### Exercises {-}

2. Do you think there is a systematic error in the KED and RF predictions?   
3. Do you think the difference between the two estimated population MSE's is statistically significant?  

### Estimation of MEC

To estimate MEC, we must first estimate the population variance of the study variable from the stratified simple random sample (the denominator in Equation \@ref(eq:HTMEC)). This population variance is estimated with function `s2` of package **surveyplanning** (Section \@ref(WhyStratify)).

```{r}
library(surveyplanning)
lut <- data.frame(collapsedstrata=1:7, weight=N_hc/n_hc)
mysample <- merge(x=mysample, y=lut)
s2z <- s2(mysample$SOM_A_hori, w=mysample$weight)
```

Now the MEC's for KED and RF can be estimated.

```{r}
mec_KED <- 1-(mse_KED/s2z)
mec_RF <- 1-(mse_RF/s2z)
```

The estimated MEC for KED equals `r round(mec_KED,3)`, and for RF `r round(mec_RF,3)`, showing that the two models used in mapping are no better than the estimated mean of SOM used as a predictor. This is quite a disappointing result.

### Statistical testing of hypothesis about population ME and MSE

The hypothesis that the population ME equals 0 can be tested by a one-sample $t$-test\index{One-sample $t$-test}. The alternative hypothesis is that ME is unequal to 0 (two-sided alternative). The number of degrees of freedom of the $t$ distribution is approximated by the total sample size minus the number of strata (Section \@ref(CISTSI)). Note that we have a two-sided alternative hypothesis\index{Two-sided alternative hypothesis}, so we must compute a two-sided *p*-value\index{\emph{p}-value of a test!Two-sided \emph{p}-value}.

```{r}
t_KED <- me_KED/se_me_KED
df <- nrow(mysample)-length(unique(mysample$collapsedstrata))
lowertail <- (t_KED<0)
p_KED <- 2*pt(t_KED, df=df, lower.tail=lowertail)
```

```{r,echo=FALSE}
t_RF <- me_RF/se_me_RF
lowertail <- (t_RF<0)
p_RF <- 2*pt(t_RF, df=df, lower.tail=lowertail)
```

The outcomes of the test statistics are `r as.character(round(t_KED,3))` and `r as.character(round(t_RF,3))` for KED and RF, respectively, with *p*-values `r as.character(round(p_KED,3))` and `r as.character(round(p_RF,3))`. So we clearly have not enough evidence for systematic errors, neither with KED, nor with RF mapping.

Now we test whether the two population MSE's  differ significantly. This can be done by a paired $t$-test\index{Paired $t$-test}. The first step in a paired t-test is to compute pairwise differences of squared predictions errors, and then we can proceed as in a one-sample t-test. 

```{r}
mysample$dife2 <- mysample$e2KED-mysample$e2RF
mdife2_h <- tapply(
  mysample$dife2, INDEX=mysample$stratum, FUN=mean)
mdife2 <- sum(w_h*mdife2_h)
vardife2_h <- tapply(
  mysample$dife2, INDEX=mysample$collapsedstrata, FUN=var)
sdmdife2 <- sqrt(sum(w_hc^2*vardife2_h/n_hc))
t <- mdife2/sdmdife2
lowertail <- (t<0)
p <- 2*pt(t, df=df, lower.tail=lowertail)
```

The outcome of the test statistic is `r as.character(round(t, 3))`, with a *p*-value of `r as.character(round(p,2))`, so we clearly do not have enough evidence that the population MSE's obtained with the two mapping methods are different.

```{r, echo=FALSE}
rm(list=ls())
```


<!--chapter:end:31-Validation.Rmd-->

# Design-based, model-based and model-assisted approach for sampling and inference {#Approaches}

In Section \@ref(DBvsMB) I already mentioned the design-based and model-based approach for sampling and statistical inference. In this chapter the fundamental differences between these two approaches are explained in more detail. Several misconceptions about the design-based approach\index{Design-based approach} for sampling and statistical inference, based on classical sampling theory\index{Classical sampling theory}, seem to be quite persistent.  These misconceptions are the result of confusion about basic statistical concepts such as independence,  expectation, and bias and variance of estimators or predictors. These concepts have a different meaning in the design-based and model-based approach\index{Model-based approach}. Besides, a population mean is still often confused with a model mean, and a population variance with a model variance, leading to invalid formulas for the variance of an estimator of the population mean. In this chapter the fundamental differences between these two approaches are illustrated with simulations, so that hopefully a better understanding of this subject is obtained. This Chapter has been published as part of a journal paper, see @Brus2021.

## Two sources of randomness

In my classes about spatial sampling I ask the participants the following question. Suppose we have measurements of a soil property, for instance soil organic carbon content, at two locations separated by 20 cm. Do you think these two measurements are correlated? I ask them to vote for one of three answers:  

1. Yes, they are (> 80\% confident)  
2. No, they are not (>80\% confident)  
3. I do not know  

Most students vote for answer 1, the other students vote for answer 3, nearly no one votes for answer 2. Then I explain that you cannot say, simply because for correlation we need two series of data, not just two numbers. The question then is how to generate these two series of data. We need some random process\index{Random process} for this. This random process differs between the design-based and model-based approach.

In the design-based approach the random process is the random selection of sampling units, whereas in the model-based approach randomness is introduced via the statistical model of the spatial variation (Table \@ref(tab:approach)). So, the design-based approach requires probability sampling, i.e. random sampling, using a random number generator\index{Random number generator}, in such way that all population units have a positive probability of being included in the sample, and that these inclusion probabilities are known for at least the selected population units[@sar92]. A probability sampling\index{Probability sampling} design can be used to generate an infinite number of samples in theory, although in practical applications only one is selected for sampling.

The spatial variation model\index{Spatial variation model} used in the model-based approach contains two terms, one for the mean (deterministic part), and an error, with a specified probability distribution. For instance, Equation \@ref(eq:OKmodel) in Chapter \@ref(Introkriging) describes the model used in ordinary kriging. This model can be used to simulate an infinite number of spatial populations. All these populations together are referred to as a superpopulation (@sar92, @loh99). Depending on the model of spatial variation, the simulated populations may show spatial structure\index{Spatial structure}, because the mean is a function of covariates, as in kriging with an external drift, and/or when the errors are spatially autocorrelated. A superpopulation\index{Superpopulation} is a construct, the populations do not exist in real world. The populations are similar, but not identical. For instance, the mean differs among the populations. The expectation of the population mean, i.e. the average over all possible simulated populations, equals the superpopulation mean\index{Superpopulation mean}, commonly referred to as the model mean\index{Model mean}, parameter $\mu$ in Equation \@ref(eq:OKmodel). The variance also differs among the populations. Contrary to the mean, the average of the population variance over all  populations generally is not equal to the model variance, parameter $\sigma^2$ in Equation \@ref(eq:OKmodel), but smaller. I will come to this later. The differences between the simulated spatial populations (see bottom row of Figure \@ref(fig:plotsimulationsDBMB), illustrate our uncertainty about the spatial variation of the study variable in the population that is sampled or will be sampled.

In the design-based approach only one population is considered, the one sampled, but all samples that can be generated by a probability sampling design are considered. The top row of Figure \@ref(fig:plotsimulationsDBMB) shows five simple random samples of size ten. The population is the same in all plots. Design-based proponents do not like to consider other populations than the one sampled. Their challenge is to characterize this one population from a probability sample.

On the contrary, in the model-based approach only one sample is considered, but all populations that can be generated with the spatial variation model. Model-based proponents do not like to consider other samples than the one selected. Their challenge is to get most out of the sample that is selected. The bottom row of Figure \@ref(fig:plotsimulationsDBMB) shows a spatial coverage sample, superimposed on five different populations simulated with an ordinary kriging model, using a spherical semivariogram with a nugget of 0.1, partial sill of 0.6 and a range of 75 m. Note that in the model-based approach there is no need to select a probability sample (see Table \@ref(tab:approach)), there are no requirements on how the units are selected.  

```{r, echo=FALSE}
library(rgdal)
library(gstat)
library(spcosa)
shpField <- readOGR(dsn="data", layer="Leest5", verbose=FALSE)
proj4string(shpField) <- NA_character_
grdField <- spsample(shpField, cellsize=1, type="regular", offset=c(0.5,0.5)) %>% as(.,"data.frame")
grdField$dummy <- 1
grdField$x1 <- grdField$x1/1000 - 597
grdField$x2 <- grdField$x2/1000 - 5654

coordinates(grdField) <- c("x1","x2")

#simulate 5 fields
set.seed(314)
# unconditional Gaussian simulation by means of simple kriging
vgmodel <- vgm(model="Sph", nugget=0.1, psill=0.6, range=0.075)
simulation  <- krige(
    formula=dummy ~ 1,
    locations=grdField,
    newdata=grdField,
    model=vgmodel,
    nmax=100,
    nsim=5,
    beta=0, #beta is model mean
    dummy=TRUE, #this is to enforce unconditional simulation
    debug.level=0
    )
grdField.df=as.data.frame(grdField)
cnst <- 5
grdField.df[["pop1"]] <- simulation[[1]] + cnst
grdField.df[["pop2"]] <- simulation[[2]] + cnst
grdField.df[["pop3"]] <- simulation[[3]] + cnst
grdField.df[["pop4"]] <- simulation[[4]] + cnst
grdField.df[["pop5"]] <- simulation[[5]] + cnst

#select 5 simple random samples of 10 points
set.seed(314)
n <- 10
sampleId <- sample(x=1:nrow(grdField.df), size=5*n)
samplesdf <- grdField.df[sampleId,c(1,2)]
samplesdf$sam <- rep(x=paste("sam", 1:5, sep=""), each=n)
samplesdf$sam <- factor(x=samplesdf$sam, levels=paste("sam", 1:5, sep=""), ordered=TRUE)

#select a spatial coverage sample of 10 points
mystrata <- stratify(shpField, nStrata=10, equalArea=F)
mySCsample <- spsample(mystrata) %>% as(.,"data.frame")
mySCsample$x1 <- mySCsample$x1/1000 - 597
mySCsample$x2 <- mySCsample$x2/1000 - 5654
```


```{r plotsimulationsDBMB, echo=FALSE, out.width='100%', fig.asp='0.4', fig.cap="Random process considered in the design-based (top row) and model-based approach (bottom row). In the design-based approach only the sampled population is considered, but all samples that can be generated by the sampling design. In the model-based approach all populations that can be generated by the model are considered, but only the sample that is selected."}
#Plot 5 times same simulated field 1 and 5 SI samples
plt1 <- ggplot(data=samplesdf) +
  geom_tile(data=grdField.df, mapping=aes(x=x1, y=x2, fill=pop1)) +
  geom_point(mapping=aes(x=x1, y=x2), size=1) +
  scale_x_continuous( name="", breaks=NULL) +
  scale_y_continuous(name="", breaks=NULL) +
  scale_fill_viridis_c(name="SOM") +
  coord_fixed() +
  theme(legend.position="none") +
  facet_wrap(~ sam, ncol=5, nrow=1)

#Plot 5 simulated fields and spatial coverage sample
grdF <- grdField.df %>% pivot_longer(.,cols=c("pop1","pop2","pop3","pop4","pop5"))
plt2 <- ggplot(data=grdF) +
  geom_tile(mapping=aes(x=x1,y=x2, fill=value)) +
  geom_point(data=mySCsample, mapping=aes(x=x1, y=x2), size=1) +
  scale_x_continuous(name="", breaks=NULL) +
  scale_y_continuous(name="", breaks=NULL) +
  scale_fill_viridis_c(name="SOM") +
  coord_fixed()+
  theme(legend.position="none") +
  facet_wrap(~name, nrow=1, ncol=5)

grid.arrange(plt1, plt2, nrow=2)
```

As stressed by @dgr90 and @bru97 both approaches have their strengths and weaknesses. Broadly speaking, the design-based approach is most appropriate if interest is in the population mean (toal proportion) or the population means (totals, proportions) of a restricted number of subpopulations (subareas). The model-based approach is most appropriate if our aim is to map the study variable. Further, the strength of the design-based approach is the strict validity\index{Validity} of the estimates. Validity means that an objective assessment of the uncertainty of the estimator is warranted, and that the coverage of confidence intervals is (almost) correct, provided that the sample is large enough to assume an approximately normal distribution of the estimator and design-unbiasedness of the variance estimator [@sar92]. The strength of the model-based approach is efficiency, i.e. more precise estimates of the (sub)population mean given the sample size, provided that a reasonably good model is used. So, if validity is more important than efficiency, the design-based approach is the best choice; in the reverse case, the model-based approach is preferable. For further reading I recommend @Cassel1977 and @han83.

## "Identically and independently distributed" (i.i.d.)

In a recent review paper on spatial sampling by @Wang2012 there is a section with the caption `Sampling of i.i.d populations’. Here i.i.d. stands for "identically and independently distributed\index{Identically and independently distributed}". In this section of @Wang2012 we can read: "In SRS (simple random sampling) it is assumed that the population is independent and identically distributed". This is one of the old misconceptions revitalized by this review paper. I will make clear that in statistics i.i.d is not a characteristic of populations, so the concept of i.i.d. populations does not make sense.  The same misconception can be found in @Plant2012: "There is considerable literature on sample size estimation, much of which is discussed by Cochran (1977, Chapter 4). This literature, however, is valid for samples of independent data but may not retain its validity for spatial data". Also according to @Wang2010 the classical formula for the variance of the estimator of the mean with simple random sampling, $V=\sigma^2/n$,  only holds when data are independent. They say: "However in the case of spatial data, although members of the sample are independent by construction, data values that are near to one another in space, are unlikely to be independent because of a fundamental property of attributes in space, which is that they show spatial structure or continuity (spatial autocorrelation)". According to @Wang2010 the variance should be approximated by

\begin{equation}
V(\hat{\bar{z}})=\frac{\sigma^2 - \overline{\mathrm{Cov}(z_i,z_j)}}{n} \;,
(\#eq:Wang2010)
\end{equation}

with $V(\hat{\bar{z}})$ the variance of the estimator of the regional mean (mean of spatial population), $\sigma^2$ the population variance, $n$ the sample size, and $\overline{\mathrm{Cov}(z_i,z_j)}$ the average autocovariance between all pairs of individuals $(i, j)$ in the population (sampled and unsampled). So according to this formula, ignoring the mean covariance within the population leads to an over-estimation of the variance of the estimator of the mean. In Section \@ref(effectivesamplesize) I will make clear that this formula is incorrect, and that the classical formula is still valid, also for populations showing spatial structure or continuity.

Remarkably, in other publications we can read that the classical formula for the variance of the estimator of the population mean with simple random sampling *underestimates* the true variance for populations showing spatial structure, see for instance @Griffith2005 and @Plant2012. The reasoning is that due to the spatial structure, there is less information in the sample data about the population mean. In  Section \@ref(effectivesamplesize) I explain that this is also a misconception. Do not get confused by these publications, and stick to the classical formulas which you can find in standard textbooks on sampling theory such as @coc77 and @loh99, and in Chapter \@ref(SI).

The concept of independence of random variables is illustrated with a simulation. The top row of Figure \@ref(fig:iid) shows five simple random samples of size two. The two points are repeatedly selected from the same population (showing clear spatial structure), so this top row represents the design-based approach. The bottom row shows two points, not selected randomly and independently, but at a fixed distance of 10 m. These two points are placed on different populations generated by the model described above, so the bottom row represents the model-based approach. 

```{r iid, echo=FALSE, out.width='100%', fig.asp='0.4', fig.cap="Illustration of independence in design-based and model-based approach. The top row shows five samples of two points selected randomly and independently from each other from one population (design-based approach). The bottom row shows two points not selected randomly, at a distance of 10 m from each other, from five model realisations (model-based approach)."}
set.seed(413)
n <- 2
sampleId <- sample(x=1:nrow(grdField.df), size=5*n)
samplesdf <- grdField.df[sampleId,]
samplesdf$sam <- rep(x=paste("sam", 1:5, sep=""), each=n)
samplesdf$sam <- factor(x=samplesdf$sam, levels=paste("sam", 1:5, sep=""), ordered=TRUE)

#select two points at fixed distance
h <- 0.010
xy <- coordinates(grdField)
xy1st <- c(0.405,0.738)
set.seed(314)
angle <- runif(n=1,min=0,max=2*pi)
dx<-numeric(length=2)
dx[1] <- h*sin(angle)
dx[2] <- h*cos(angle)
xy2nd <- xy1st+dx
onepair <- data.frame(x=c(xy1st[1],xy2nd[1]),y=c(xy1st[2],xy2nd[2]))

plt1 <- ggplot(data=samplesdf) +
  geom_tile( data=grdField.df, mapping=aes(x=x1,y=x2, fill=pop1)) +
  geom_point(mapping=aes(x=x1, y=x2), size=1) +
  scale_x_continuous(name="", breaks=NULL) +
  scale_y_continuous(name="", breaks=NULL) +
  scale_fill_viridis_c(name="SOM") +
  coord_fixed() +
  theme(legend.position="none") +
  facet_wrap(~ sam, ncol=5, nrow=1)

plt2 <- ggplot(data=grdF) +
  geom_tile(mapping=aes(x=x1, y=x2, fill=value)) +
  geom_point(data=onepair, mapping=aes(x=x, y=y), size=1) +
  scale_x_continuous(name="", breaks=NULL) +
  scale_y_continuous(name="", breaks=NULL) +
  scale_fill_viridis_c(name="SOM") +
  coord_fixed() +
  theme(legend.position="none") +
  facet_wrap(~ name, nrow=1, ncol=5)

grid.arrange(plt1, plt2, nrow=2)
```

```{r ScatterplotsTwopoints, echo=FALSE, out.width='100%', fig.cap="Scatter plot of the values at two randomly and independently selected points, 1000 times selected from one population (design-based approach), and at two fixed points with a separation distance of 10 m, selected non-randomly from 1000 model realisations (model-based approach)." }
#simulate 1000 values at two points seperated by distance h
c <- variogramLine(vgmodel,covariance=TRUE,dist_vector=c(0,h))
C <- matrix(nrow=2,ncol=2)
C[1,1] <- C[2,2] <- c$gamma[1]
C[1,2] <- C[2,1] <- c$gamma[2]

#cholesky decomposition
Upper<-chol(C)

set.seed(31415)
nsim <- 1000
Z <- matrix(nrow=nsim, ncol=2)
for (i in 1:nsim) {
  N <- rnorm(n=2,0,1)
  Z[i,] <- crossprod(Upper, N)
}
Z <- Z+cnst
Zdf_MB <- as.data.frame(Z)

units <- sample(x=1:nrow(grdField.df), size=nsim)
Zdf_DB <- NULL
Zdf_DB$V1 <- grdField.df$pop1[units]
units <- sample(x=1:nrow(grdField.df), size=nsim)
Zdf_DB$V2 <- grdField.df$pop1[units]

Zdf <- rbind(Zdf_MB, Zdf_DB)
Zdf$approach <- rep(c("Model-based","Design-based"), each=1000)
ggplot(data=Zdf) +
  geom_point(mapping=aes(x=V1,y=V2), size=1) +
  scale_x_continuous(name="SOM location 1", limits=c(0,10)) +
  scale_y_continuous(name="SOM location 2\n", limits=c(0,10)) +
  coord_fixed() +
  facet_wrap(~approach)
```
The values measured at the two points are plotted against each other in a scatter plot, but now not for just five simple random samples or five populations, but for 1,000 samples and populations (Figure \@ref(fig:ScatterplotsTwopoints)). As we can see there is no correlation between the two variables generated by the repeated random selection of the two points (design-based), whereas the two variables generated by the repeated simulation of populations (model-based) are correlated.

Instead of two points, we may select two series of probability samples independently from each other, for instance two series of simple random samples (SI) of size 10, or two series of systematic random samples with random origin (SY) with an average size of 10, see Figure \@ref(fig:TwoseriesSISY). 

```{r TwoseriesSISY, echo=FALSE, out.width='100%', fig.cap="Two series (a and b) of simple random samples of ten points (top), and two series of systematic random samples of, on average, ten points (bottom). The samples of series a and b are selected independently from each other."}
#select 10 SI samples of 10 points
set.seed(314)
n <- 10
sampleId <- sample(x=1:nrow(grdField.df),size=10*n)
sampleSI <- grdField.df[sampleId,c(1,2)]
sampleSI$sam <- rep(c("a1","a2","a3","a4","a5","b1","b2","b3","b4","b5"), each=n)

plt1 <- ggplot(data=sampleSI) +
  geom_tile(data=grdField.df, mapping=aes(x=x1, y=x2, fill=pop1)) +
  geom_point(mapping=aes(x=x1, y=x2), size=1) +
  scale_x_continuous(name="", breaks=NULL) +
  scale_y_continuous(name="", breaks=NULL) +
  scale_fill_viridis_c(name="SOM") +
  coord_fixed() +
  theme(legend.position="none") +
  coord_fixed() +
  facet_wrap(~ sam, ncol=5, nrow=2)

#select 10 systematic random samples of 10 points
sampleSize <- 10
gridded(grdField) <- TRUE
set.seed(143)
sampleSY <- NULL
for (i in 1:10) {
  sampleSYi <- as(spsample(x=grdField, n=sampleSize, type="regular", bb=bbox(grdField)),"data.frame")
  sampleSYi$sam <- i
  sampleSY<-rbind(sampleSY, sampleSYi)
}
sampleSY$sam[sampleSY$sam==1] <- "a1"
sampleSY$sam[sampleSY$sam==2] <- "a2"
sampleSY$sam[sampleSY$sam==3] <- "a3"
sampleSY$sam[sampleSY$sam==4] <- "a4"
sampleSY$sam[sampleSY$sam==5] <- "a5"
sampleSY$sam[sampleSY$sam==6] <- "b1"
sampleSY$sam[sampleSY$sam==7] <- "b2"
sampleSY$sam[sampleSY$sam==8] <- "b3"
sampleSY$sam[sampleSY$sam==9] <- "b4"
sampleSY$sam[sampleSY$sam==10] <- "b5"

#make plot of SY samples
plt2 <- ggplot(data=sampleSY) +
  geom_tile(data=grdField.df, mapping=aes(x=x1, y=x2, fill=pop1)) +
  geom_point(mapping=aes(x=x1, y=x2), size=1) +
  scale_x_continuous(name="", breaks=NULL) +
  scale_y_continuous(name="", breaks=NULL) +
  scale_fill_viridis_c(name="SOM") +
  coord_fixed() +
  theme(legend.position="none") +
  coord_fixed() +
  facet_wrap(~ sam, ncol=5, nrow=2)

grid.arrange(plt1, plt2, nrow=2)
```

Again, if we plot the sample means of pairs of simple random samples and pairs of systematic random samples against each other, we see that the two averages are not correlated (Figure \@ref(fig:ScatterplotsSISY)). Note that the variation of the averages of the systematic random samples is considerably smaller than that of the simple random samples. The sampled population shows spatial structure, and by spreading the sampling units out over the spatial population, the precision of the estimated population mean is increased, see Chapter \@ref(SY).

```{r ScatterplotsSISY, echo=FALSE, out.width='100%', fig.cap="Scatterplot of averages of 1000 pairs of simple random samples of ten points, and of averages of 1000 pairs of systematic random samples of ten points on average."}
#make scatter plot of means estimated from repeated SI samples
mz <- matrix(nrow=nsim,ncol=2)

for (i in 1:nsim){
  sampleId1 <- sample(x=1:nrow(grdField.df), size=10)
  mz[i,1] <- mean(grdField.df$pop1[sampleId1])
  sampleId2 <- sample(x=1:nrow(grdField.df), size=10)
  mz[i,2] <- mean(grdField.df$pop1[sampleId2])
}
mz_SI <- as.data.frame(mz)

#make scatter plot of means estimated from repeated SY samples
mz <- matrix(nrow=nsim,ncol=2)
spgrdField <- grdField.df[,c(1,2,4)]
gridded(spgrdField) <- ~x1+x2

for (i in 1:nsim){
  sampleSY1 <- spsample(x=grdField, n=sampleSize, type="regular", bb=bbox(grdField))
  sampleSY2 <- spsample(x=grdField, n=sampleSize, type="regular", bb=bbox(grdField))

#subsetting rows with overlay method
  z1 <- over(x=sampleSY1,y=spgrdField)
  z2 <- over(x=sampleSY2,y=spgrdField)

  mz[i,1] <- mean(z1$pop1)
  mz[i,2] <- mean(z2$pop1)
}
mz_SY <- as.data.frame(mz)

mz_both <- rbind(mz_SI, mz_SY)
mz_both$design <- rep(c("SI","SY"), each=1000)
ggplot(data=mz_both) +
  geom_point(mapping=aes(x=V1, y=V2), size=1) +
  scale_x_continuous(name="Sample average series a", limits=c(5,7)) +
  scale_y_continuous(name="Sample average series b\n", limits=c(5,7)) +
  coord_fixed() +
  facet_wrap(~design)
```

This sampling experiment shows that independence is not a characteristic of a population, as stated by @Wang2012, but of random variables (in the experiment the values at points, or the sample means) generated by a random process. As the random process differs between the design-based and model-based approach, independence has a different meaning in these two approaches. For that reason, it is imperative to be more specific when using the term independence, by saying that data are *design-independent*\index{Design-independent} or that you *assume* that the data are *model-independent*\index{Model-independent}.

## Bias and variance {#BiasandVariance}

Bias and variance are commonly used statistics to quantify the quality of an estimator. Bias quantifies the systematic error, variance the random error of the estimator. Both are defined as expectations. But expectations over the realisations of which random process? Over realisations of a probability sampling design (samples), or realisations of statistical model (populations)? Like independence, it is important to distinguish *design-bias*\index{Design-bias} from *model-bias*\index{Model-bias}, and *design-variance*\index{Design-variance} (commonly referred to as sampling variance) from *model-variance*\index{Model-variance}.

The concept of model-unbiasedness deserves more attention. Figure \@ref(fig:preferentialsample) shows a preferential sample\index{Preferential sample} from a population simulated by sequential Gaussian simulation with a constant mean of 10 and an exponential semivariogram without nugget, a sill of 5 and a distance parameter of 20. The points are selected by sampling with draw-by-draw selection probabilities proportional to size (pps sampling, Chapter \@ref(pps)), using the square of the simulated values as a size variable. We may have a similar sample that is collected for delineating soil contamination or detecting hot spots of soil bacteria, etc. Many samples are selected at locations with a large value, few points at locations with a small value. The sample data are used in ordinary kriging (Figure \@ref(fig:preferentialsample)). The prediction errors are computed by subtracting the kriged map from the simulated population. 

```{r, echo=FALSE}
s1 <- s2 <- 1:100 - 0.5
grd <- expand.grid(s1,s2)
N <- nrow(grd)
names(grd) <- c("s1","s2")
coordinates(grd) <- ~s1+s2
vgmodel <- vgm(model="Exp", psill=5, range=20)
set.seed(314)
nsim <- 1
sim <- krige(
  dummy ~ 1,
  locations=grd,
  newdata=grd,
  model=vgmodel,
  nmax=100,
  nsim=nsim,
  beta=10,
  dummy=TRUE,
  debug.level=0
)
sim<-as.data.frame(sim)
names(sim)[3] <- "z" 
sim$size <- sim$z^2

#select pps sample
set.seed(314)
units <- sample.int(N,100, prob=sim$size)
sam <- sim[units,]

maxsimz <- max(sim$z)
minsimz <- min(sim$z)

#now predict at nodes of grid using the simulated values at the pps sample
predgrd <- grd
coordinates(sam) <- ~s1+s2
preds <- krige(
  z ~ 1,
  locations=sam,
  newdata=predgrd,
  model=vgmodel,
  debug.level=0
)
preds <- as.data.frame(preds)
names(preds)[3] <- "zpred"

#map predicted values
#replace one value by the maximum another by the minimum of the simulated values
preds$zpred[which.max(preds$zpred)] <- maxsimz
preds$zpred[1] <- minsimz
```

```{r preferentialsample, echo=FALSE, out.width='100%', fig.cap="Preferential sample (size of open dots is proportional to value of study variable) and ordinary kriging predictions."}

df <- data.frame(s1=sim$s1, s2=sim$s2, z=sim$z, zpred=preds$zpred)
d <- df %>% pivot_longer(., cols=c("z","zpred"))

sam <- as(sam,"data.frame")

ggplot(data=d) +
  geom_tile(mapping=aes(x=s1, y=s2, fill=value)) +
  geom_point(data=sam, mapping=aes(x=s1, y=s2, size=z), shape=1) +
  scale_fill_viridis_c(name="z") +
  coord_fixed() +
  facet_grid(~ name)
```

Figure \@ref(fig:histogramerrorpreferentialsample) shows a histogram of the prediction errors. The population mean error equals 0.483, not 0. You may have expected a positive systematic error because of the overrepresentation of locations with large values, but on the other hand, kriging predictions are best linear unbiased predictions\index{Best linear unbiased predictor} (BLUP), so from that point of view, this systematic error might be unexpected. BLUP means that at individual locations the ordinary kriging predictions are unbiased. However, apparently this does not guarantee that the average of the prediction errors, averaged over all population units, equals 0. The reason is that unbiasedness is defined here over all realisations (populations) of the statistical model of spatial variation. So, the U in BLUP stands for model-unbiasedness. For other model realisations, sampled at the same points, we may have much smaller values, leading to a negative mean error of that population. On average, over all populations, the error at any point will be 0, and consequently also the average over all populations of the mean error.

```{r histogramerrorpreferentialsample, echo=FALSE, fig.cap="Histogram of errors of ordinary kriging predictions from a preferential sample."}
error <- preds$zpred - sim$z

ggplot() +
  geom_histogram(aes(x=error), binwidth=0.5, fill="black", alpha=0.5, colour="black") +
  scale_y_continuous(name="Frequency") +
  scale_x_continuous(name="Prediction error")
```

This experiment shows that model-unbiasedness does not protect us against selection bias\index{Selection bias}, i.e. bias due to preferential sampling.

## Effective sample size {#effectivesamplesize}

Another persistent misconception is that when estimating the variance of the estimator of the mean of a spatial population or the correlation of two variables of a population we must account for autocorrelation\index{Autocorrelation} of the sample data. This misconception occurs, for instance, in @Griffith2005 and in various sections (for instance, Sections 3.5, 10.1 and 11.2) of @Plant2012. The reasoning is that, due to the spatial autocorrelation in the sample data, there is less information in the data about the parameter of interest, and so the effective sample size\index{Effective sample size} is smaller than the actual sample size. An early example of this misconception is Barnes' publication on the required sample size for estimating nonparametric tolerance intervals  [@Barnes1988]. @dgr92 showed that a basic probability sampling design like simple random sampling requires fewer sampling points than the model-based sampling design proposed by Barnes.

The misconception is caused by confusing population parameters with model parameters. Recall that the population mean and the model mean are not the same; the model mean $\mu$ of Equation \@ref(eq:OKmodel) is the expectation of the population means over all populations that can be simulated with the model. The same holds for the variance of a variable, and the covariance and Pearson correlation coefficient of two variables. All these parameters can be defined as a parameter of a (finite or infinite) population or of random variables generated by a superpopulation model. Using an effective sample size to quantify the variance of an estimator is perfectly correct for model parameters, but not so for population parameters. For instance, when the correlation coefficient is defined as a population parameter and sampling units are selected by simple random sampling, there is no need to apply the method proposed by @Clifford1989 to correct the *p*-value in a significance test for the presence of spatial autocorrelation.

I elaborate on this for the mean as the parameter of interest. Suppose a sample is selected in some way (need not be random), and the sample mean is used as an estimator of the model mean. Note that for a model with a constant mean as in Equation \@ref(eq:OKmodel), the sample mean is a model-unbiased\index{Model-unbiased} estimator of the model mean, but in general not the best linear unbiased estimator\index{Best linear unbiased estimator} (BLUE) of the model mean. If the random variables are model-independent, the variance of the sample mean, used as an estimator of the model mean, can be computed by

\begin{equation}
V(\hat{\mu}) = \frac{\sigma^2}{n} \;,
(\#eq:VindModelMean)
\end{equation}

with $\sigma^2$ the model-variance of the random variable (see Equation \@ref(eq:OKmodel)). The variance presented in Equation \@ref(eq:VindModelMean) necessarily is a model-variance as it quantifies our uncertainty about the model mean, which only exists in the model-based approach. If the random variables are not model-independent, the model-variance of the sample mean can be computed by [@gru06]

\begin{equation}
    V(\hat{\mu}) = \frac{\sigma^2}{n} \{1+(n-1)\bar{\rho}\} \;,
(\#eq:VdepModelMean)
\end{equation}

with $\bar{\rho}$ the mean correlation within the sample (the average of the correlation of all pairs of sampling points). The term inside the curly brackets is larger than one, unless $\bar{\rho}$ equals 0. So the variance of the estimator of the model mean with dependent data is larger than when data are independent. The number of independent observations that is equivalent to a spatially autocorrelated data set's sample size $n$, referred to as the effective sample size, can be computed with [@gru06]

\begin{equation}
    n_{\mathrm{eff}}= \frac{n}{\{1+(n-1)\bar{\rho}\}} \;.
(\#eq:effectivesamplesize)
\end{equation}

So, if we substitute $n_{\mathrm{eff}}$ for $n$ in Equation \@ref(eq:VindModelMean), we obtain the variance presented in Equation \@ref(eq:VdepModelMean). Equation \@ref(eq:effectivesamplesize) is equivalent to Equation 2 in @Griffith2005. Figure \@ref(fig:effectivesamplesize) shows that the effective sample size decreases sharply with the mean correlation. With a mean correlation of 0 the effective sample size equals the actual sample size, with a mean correlation of one the effective sample size equals one.

```{r effectivesamplesize, echo=FALSE, fig.asp=.7, fig.cap="Effective sample sizes for samples of size 25 and 100, as a function of the mean correlation within the sample."}
meanrho <- seq(from=0, to=1, length.out=201)
n <- c(25,100)
n25 <- n[1]/(1+(n[1]-1)*meanrho)
n100 <- n[2]/(1+(n[2]-1)*meanrho)
df <- data.frame(meanrho,n25,n100)
df_lf <- df %>% pivot_longer(.,cols=c("n25","n100"))
df_lf$name <- factor(df_lf$name, levels=c("n25","n100"), ordered=TRUE)
ggplot(data=df_lf) +
  geom_line(mapping=aes(x=meanrho ,y=value, linetype=name), size=1) +
  scale_linetype_manual(values=c("twodash", "dotted"), name="") +
  scale_x_continuous(name="Mean correlation") +
  scale_y_continuous(name="Effective sample size", limits=c(1,100))
```

To illustrate the difference between the model-variance and design-variance of a sample mean, I simulated a finite population of 100 units, located at the nodes of a square grid, with a model mean of 10, an exponential semivariogram without nugget, an effective range of three times the distance between adjacent population units, and a sill of one (Figure \@ref(fig:finitepopulation)). The model-variance of the average of a simple random sample *without replacement* of size $n$ is computed using Equation \@ref(eq:VdepModelMean), as well as the design-variance of the sample mean, used as an estimate of the population mean, computed by (see Equation \@ref(eq:EstVarMeanSI))

\begin{equation}
V(\hat{\bar{z}})=\left(1-\frac{n}{N}\right)\frac{S^2}{n} \;,
(\#eq:varmeanSRSwithout)
\end{equation}

with $N$ the total number of population units ($N=100$). This is done for a range of sample sizes: $n = 10, 11, \dots ,100$. Note that for $n < 100$ the model-variance of the sample mean for a given $n$, differs between samples. For samples showing strong spatial clustering, the mean correlation is relatively large, and consequently the model-variance is relatively large (see Equation \@ref(eq:VdepModelMean)). There is less information in these samples about the model mean than in samples without spatial clustering of the points. Therefore, to estimate the expectation of the model-variance over repeated simple random sampling for a given $n$, I selected 200 simple random samples of that size $n$, and I averaged the 200 model-variances. Figure \@ref(fig:MBvarDBvar) shows the result. Both the model-variance and the design-variance of the sample mean decrease with the sample size. For all sample sizes the model-variance is larger than the design-variance. The design-variance goes to 0, for $n = 100$ (see Equation \@ref(eq:varmeanSRSwithout)), whereas the model-variance for $n = 100$ equals 0.0509. This can be explained as follows. Although with $n = 100$ we know the population mean without error, this population mean is only an estimate of the model mean. Recall that the model mean is the expectation of the population mean over all realisations of the model. 

```{r finitepopulation, echo=FALSE, fig.cap="Simple random sample without replacement of ten points from a  finite population simulated with a model with a model mean of 10, model-variance of 1 and an exponential semivariogram (without nugget) with a distance parameter equal to the distance between neighbours (effective range is three times this distance). The mean correlation within the sample equals 0.135, and the model-variance of the estimator of the model mean equals 0.222."}
s1 <- s2 <- 1:10 - 0.5
grd <- expand.grid(s1, s2)
N <- nrow(grd)
names(grd) <- c("s1","s2")

#simulate finite populations
sigmasq <- 1
vgmodel <- vgm(model="Exp", psill=sigmasq, range=1)
H <- as.matrix(dist(grd))
C <- variogramLine(vgmodel, dist_vector=H, covariance=TRUE)
Upper <- chol(C)

set.seed(314)
sim <- matrix(nrow=N,ncol=10000)
for (i in 1 :10000) {
  G <- rnorm(n=nrow(grd),0,1) 
  sim[,i] <- crossprod(Upper,G)+10
}
simdf <- as.data.frame(cbind(grd,sim))

#select one population, and select SRS without replacement 
names(simdf)[17] <- "z"

set.seed(314)
units <- sample.int(N,10, replace=FALSE)
SRS <- simdf[units,c(1,2)]
d <- spDists(as.matrix(SRS[,c(1,2)]))
C <- variogramLine(vgmodel, dist_vector=d, covariance=TRUE)
meanrho <- mean(C/sigmasq)
modelvar <- round(sigmasq/10*(1+(10-1)*meanrho),3)

ggplot(data=simdf) +
    geom_point(mapping=aes(x=s1, y=s2, colour=z), size=3) +
    geom_point(data=SRS, mapping=aes(x=s1, y=s2), size=6, shape=1, stroke=2) +
    scale_color_continuous(name="z", type= "viridis") +
    scale_x_continuous(name="", breaks=c(2,4,6,8)) +
    scale_y_continuous(name="", breaks=c(2,4,6,8)) +
    coord_fixed()
```


```{r, echo=FALSE, eval= FALSE}
n <- 10:100
DBvar <- (1-n/N)*var(simdf$z)/n
MBvar <- MBvarGriffith <- matrix(nrow=length(n), ncol=200)

set.seed(314)
for (i in 1:length(n)) {
  for (j in 1:200) {
    units <- sample.int(N,n[i], replace=FALSE)
    SRS <- simdf[units,c(1,2)]
    d <- spDists(as.matrix(SRS[,c(1,2)]))
    C <- variogramLine(vgmodel, dist_vector=d, covariance=TRUE)
    meanrho <- mean(C[lower.tri(C,diag=FALSE)]/sigmasq)
    MBvar[i,j] <- (sigmasq/n[i])*(1+(n[i]-1)*meanrho)
  }
}
save(n, DBvar, MBvar,file="results/MBvarDBvar.RData")
```

```{r MBvarDBvar, echo=FALSE, fig.asp=.7, fig.cap="Model variance (MB) and design-variance (DB) of the average of simple random sample without replacement as a function of the sample size."}
load(file="results/MBvarDBvar.RData")
meanMBvar <- apply(MBvar, MARGIN=1, FUN=mean)
df <- data.frame(n,DBvar,meanMBvar)
d <- df %>% pivot_longer(., cols=c("DBvar","meanMBvar"))
ggplot(data=d) +
  geom_point(mapping=aes(x=n, y=value, shape=name), size=2) +
  scale_shape_manual(values=c(3,4), name="Variance", labels=c("DB","MB")) +
  scale_x_continuous(name="Sample size", limits=c(10,100), breaks=c(10,30,50,70,100)) +
  scale_y_continuous(name="Variance")
```

In Figure \@ref(fig:HistogramsMeanVariance) we can see that the population mean shows considerable variation. The variance of 10,000 simulated population means equals 0.0513, which is nearly equal to the value of 0.0509 for the model-variance computed with Equation \@ref(eq:VdepModelMean).

In observational research I cannot think of situations in which interest is in estimation of the mean of a superpopulation model. This in contrast to experimental research. In experimental research we are interested in the effects of treatments, think for instance of the effects of different types of soil tillage on the soil carbon stock. These treatment effects are quantified by different model means. Also, in time-series analysis of data collected in observational studies we might be more interested in the model mean than in the mean over a bounded period of time.

```{r HistogramsMeanVariance, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap="Histograms of means and variances of 10,000 simulated populations."}
#compute population means
popmeans <- apply(simdf[,-c(1,2)],MARGIN=2,FUN=mean)

plt1 <- ggplot() +
  geom_histogram(aes(x=popmeans), fill="black", alpha=0.5, binwidth=0.1, colour="black") +
  scale_y_continuous(name="Frequency") +
  scale_x_continuous(name="Population mean")

#compute population variances
S2 <- apply(simdf[,-c(1,2)],MARGIN=2,FUN=var)
plt2 <- ggplot() +
  geom_histogram(aes(x=S2), fill="black", alpha=0.5, binwidth=0.1, colour="black") +
  scale_y_continuous(name="Frequency") +
  scale_x_continuous(name="Population variance")

grid.arrange(plt1, plt2, nrow=1)
```

Now let us return to Equation \@ref(eq:Wang2010). What is wrong with this variance estimator? Where @Griffith2005 confused the population mean and the model mean, @Wang2010 confused the population variance with the sill\index{Sill} (a priori variance) of the random process that has generated the population [@webster2007]. The parameter $\sigma^2$ in their formula is defined as the population variance, and in doing so the variance estimator is clearly wrong. However, if we define $\sigma^2$ in this formula as the sill, the formula makes more sense, but even then, the equation is not fully correct. The variance computed with this equation is not the design-variance of the average of a simple random sample selected from the sampled population, but the *expectation* of this design-variance over all realisations of the model. So, it is a model-based prediction of the design-variance of the estimator of the population mean, estimated from a simple random sample, see Chapter \@ref(MBpredictionofDesignVariance). For the population actually sampled, the design-variance is either smaller or larger than this expectation. Figure \@ref(fig:HistogramsMeanVariance) shows that there is considerable variation in the population variance among the 10,000 populations simulated with the model. Consequently, for an individual population the variance of the estimator of the population mean, estimated from a simple random sample, can largely differ from the model-expectation of this variance. Do not use Equation \@ref(eq:Wang2010) for estimating the design-variance of the estimator of the population mean, but simply use Equation \@ref(eq:varmeanSRSwithout) (for simple random sampling with replacement and simple random sampling of infinite populations the term $(1-n/N)$ can be dropped). Equation  \@ref(eq:Wang2010) is only relevant for comparing simple random sampling under a variety of models of spatial variation (@Ripley1981, @dom94).

## Exploiting spatial structure in design-based approach {#ExploitSpatialStructure}

Another misconception is that in the design-based approach the possibilities of exploiting our knowledge about the spatial structure of the study variable are limited, because the sampling units are selected randomly. This would indeed be a very serious drawback, but happily enough, this is not true. There are various ways of utilizing this knowledge. Our knowledge about the spatial structure can be used either at the stage of designing the sample, and/or at the stage of the statistical inference once the data are collected (Table \@ref(tab:TableExploitingSpatialStructure)). 

I distinguish the situation in which maps of covariates are available from the situation in which such maps are lacking. In the first situation, the covariate maps can be used, for instance, to stratify the population (Chapter \@ref(STSI)). With a quantitative covariate, optimal stratification methods are available. Other options are, for instance, pps sampling (Chapter \@ref(pps)), and balanced sampling  and well-spread sampling in covariate space with the local pivotal method (Chapter \@ref(BalancedSpreaded)). At the inference stage the covariate maps can be used in a model-assisted approach\index{Model-assisted approach}, using, for instance, a linear regression model to increase the precision of the design-based estimator (Chapter \@ref(Modelassisted), Section \@ref(ModelassistedvsModeldependent)). 

If no covariate maps are available, we may anticipate the presence of spatial structure by spreading out the sampling units throughout the study area. This spreading can be done in many ways, for instance by systematic random sampling (Chapter \@ref(SY)), compact geographical stratification (Section \@ref(geostrata)), well-spread sampling in geographical space with the local pivotal method (Section \@ref(LPM)), and generalized random tessellation stratified sampling (Section \@ref(GRTS)). At the inference stage, again a model-assisted approach can be advantageous, using the spatial coordinates in a regression model.

```{r TableExploitingSpatialStructure, echo=FALSE}
tabledf <- data.frame(stage=c("Sampling","","","","Inference"),with=c("Stratified random sampling","pps sampling","Balanced sampling","Covariate-space spreading with LPM","Model-assisted: regression model"),without=c("Systematic random sampling","Compact geographical stratification","Geographical spreading with LPM","GRTS sampling","Model-assisted: spatial spline"))
knitr::kable(
  tabledf, caption = 'Exploiting knowledge about the spatial structure of the study variable in the design-based approach. LPM: local pivotal method.',
  col.names = c("Stage","Covariates available","No covariates"),
  booktabs = TRUE
) %>%
  kable_classic(font_size=8)
```

## Model-assisted versus model-dependent {#ModelassistedvsModeldependent}

In this section the difference between the model-assisted approach and model-based approach is explained. The model-assisted approach is a hybrid approach in between the design-based and model-based approach. It tries to build the strength of the model-based approach, a potential increase of the accuracy of estimates, into the design-based approach. As in the design-based approach, sampling units are selected by probability sampling, and consequently bias and variance are defined as design-bias and design-variance (Table \@ref(tab:threeapproaches)). As in the model-based approach, a superpopulation model is used. However, the role of this model in the two approaches is fundamentally different. In both approaches we assume that the population of interest is a realisation of the superpopulation model. However, as explained above, in the model-based approach, the statistical properties of the estimators (predictors), such as bias and variance are defined over all possible realisations of the model (Table \@ref(tab:threeapproaches)). So unbiasedness and minimum variance of an estimator (predictor) means *model*-unbiasedness and minimum *model*-variance. On the contrary, in the model-assisted approach the model is used to derive an efficient estimator (Chapter \@ref(Modelassisted)). To stress its different role in the model-assisted approach, the model is referred to as a working model\index{Working model}.

```{r threeapproaches, echo=FALSE}
approach <- data.frame(Approach=c("Design-based","Model-assisted","Model-based"),Sampling=c("Prob. sampling","Prob. sampling","No requirement"),Inference=c("Design-based","Model-assisted","Model-depend."),Coefficients=c("No model","Population par.","Superpop. par."),Criteria=c("Design-bias, design-variance","Design-bias, design-variance","Model-bias, model-variance"))

knitr::kable(
  approach, caption = 'Three statistical approaches for sampling and inference.',
  col.names = c("Approach","Sampling","Inference","Regression coefficients","Quality criteria"),
  booktabs = TRUE
)%>%
  kable_classic(font_size=7)
```

An important property of model-assisted estimators is that, if a poor working model is used (our assumptions about how our population is generated are incorrect), then for moderate sample sizes the results are still valid, i.e. the empirical coverage rate\index{Empirical coverage rate} of a model-assisted estimate of the confidence interval of the population mean still is approximately equal to the nominal coverage rate. This is because the mismatch of the superpopulation model and the applied model-assisted estimator results in a large design-variance of the estimator of the population mean. This is illustrated with a simulation study, in which I compare the effect of using a correct vs. an incorrect model in estimation.

A population is simulated with a simple linear regression model with an intercept of 15 ($\beta_0 = 15$), a slope coefficient of 0.5 ($\beta_1 = 0.5$), and a constant residual standard deviation of 2 ($\sigma_{\epsilon}=2$). This is done by first simulating a population with covariate values with a model mean of 20 ($\mu(x)=20$), using an exponential semivariogram without nugget, a sill variance of 25, and a distance parameter of 20 distance units. This field with covariate values is then linearly transformed using the above mentioned regression coefficients. Finally, `white noise\index{White noise}' is added by drawing independently for each population unit a random number from a normal distribution with zero mean and a standard deviation of 2 (Figure \@ref(fig:plotsimulatedbivariatepopulation)).

```{r simulatebivariatepopulation, echo=FALSE}
s1 <- s2 <- 1:200 - 0.5
mypopulation <- expand.grid(s1,s2)
names(mypopulation) <- c("s1","s2")
N <- nrow(mypopulation)
vgmodel <- vgm(model="Exp", psill=25, range=20, nugget=0)
coordinates(mypopulation) <- ~s1+s2
set.seed(314)
sim <- krige(
  dummy ~ 1,
  locations=mypopulation,
  newdata=mypopulation,
  model=vgmodel,
  nmax=20,
  nsim=1,
  beta=20,
  dummy=TRUE,
  debug.level=0
)
mypopulation$x <- sim$sim1
mypopulation <- as(mypopulation,"data.frame")
mypopulation$z <- 15 + 0.5*mypopulation$x + rnorm(n=N,mean=0,sd=2)
```

The population mean of the study variable equals `r round(mean(mypopulation$z),3)`, which is pretty close to the known model mean $\mu(z)$: $\beta_0 + \beta_1 \mu(x)= 15 + 0.5 \cdot 20$.


```{r plotsimulatedbivariatepopulation, echo=FALSE, out.width='100%', fig.cap="Realisation of simple linear regression model."}

plt1 <- ggplot(data=mypopulation) +
  geom_raster(mapping=aes(x=s1, y=s2, fill=x)) +
#  ggtitle("Covariate")+
  theme(plot.title=element_text(size=16, hjust=0.5))+
  scale_fill_continuous(name="x",type= "viridis") +
  scale_y_continuous(name="Northing") +
  scale_x_continuous(name="Easting") +
  coord_fixed()

plt2 <- ggplot(data=mypopulation) +
  geom_raster(mapping=aes(x=s1, y=s2, fill=z)) +
#  ggtitle("Study variable")+
  theme(plot.title=element_text(size=16, hjust=0.5))+
  scale_fill_continuous(name="z",type= "viridis") +
  scale_y_continuous(name="Northing") +
  scale_x_continuous(name="Easting") +
  coord_fixed()

grid.arrange(plt1, plt2, nrow=1)
```


```{r scatterplotbivariatepopulation, echo=FALSE, fig.cap="Exhaustive scatter plot of simulated population, with population fit of simple linear regression model (green line), and ratio model (red line) fitted with weights inversely proportional to the covariate."}
model_regr_pop <- lm(z~x, data=mypopulation)
model_ratio_pop <- lm(z~x -1,weights=1/x, data=mypopulation)
ggplot(mypopulation) +
  geom_point(mapping=aes(x=x,y=z), alpha=0.25) +
  geom_abline(intercept=coef(model_regr_pop)[1], slope=coef(model_regr_pop)[2], colour="green") +
  geom_abline(intercept=0, slope=coef(model_ratio_pop)[1], colour="red") +
  scale_x_continuous(limits=c(0,40)) +
  scale_y_continuous(limits=c(0,40), name="z")

sdres_regr <- summary(model_regr_pop)$sigma
fit_ratio <- fitted(model_ratio_pop)
e_ratio <- mypopulation$z-fit_ratio
sdres_ratio <- sqrt(sum(e_ratio^2)/nrow(mypopulation))
```

Figure \@ref(fig:scatterplotbivariatepopulation) shows a scatterplot for all population units. The Pearson correlation coefficient equals `r round(cor(mypopulation$x,mypopulation$z),3)`. Two models are fitted to the exhaustive scatter plot, a simple linear regression model and a ratio model. The ratio model assumes that the intercept $\beta_0$ equals 0, and that the residual variance is proportional to the covariate values: $\sigma^2_{\epsilon} \propto x$. The population fit of the coefficients of the simple linear regression model are `r round(coef(model_regr_pop)[1],4)` and `r round(coef(model_regr_pop)[2],4)`, which are very close to the model regression coefficients. The fitted ratio model is clearly very poor. The residual standard deviation of the population fit of the ratio model equals `r round(sdres_ratio,3)`, which is much larger than  `r round(sdres_regr,3)` of the simple linear regression model.

The population mean of the study variable is estimated by selecting 5,000 times a simple random sample of 25 units. Each sample is used to estimate the population mean by two model-assisted estimators, the simple regression estimator and the ratio estimator (Chapter \@ref(Modelassisted)). The first estimator correctly assumes that the population is a realisation of a simple linear regression model, whereas the latter incorrectly assumes that it is a realisation of a ratio model. For each sample the standard error of the two estimators are estimated as well, which is used to compute a 95\% confidence interval of the population mean. Then the empirical coverage rate is computed, i.e. the proportion of samples for which the population mean is inside the 95\% confidence interval. Ideally this empirical coverage rate is equal to the nominal coverage rate of 0.95.

```{r coveragerate1, echo=FALSE}
mx_pop <- mean(mypopulation$x)
mz_pop <- mean(mypopulation$z)
n <- 25
S <- 5000
alpha <- 0.05
se_regr <- se_ratio <- ind_regr <- ind_ratio <- numeric(length=S)
set.seed(314)
for (i in 1:S) {
  units <- sample.int(N,size=n,replace=TRUE)
  mySI <- mypopulation[units,]
  mx_sam <- mean(mySI$x)
  mz_sam <- mean(mySI$z)
  model_regr <- lm(z~x,data=mySI)
  b1 <- coef(model_regr)[2]
  mz_regr <- mz_sam + b1*(mx_pop-mx_sam)
  e_regr <- residuals(model_regr)
  S2e <- var(e_regr)
  se_regr[i] <- sqrt(S2e/n)
  margin <- qt(1-alpha/2,n-2,lower.tail=TRUE)*se_regr[i]
  lower <- mz_regr-margin
  upper <- mz_regr+margin
  ind_regr[i] <- (mz_pop>lower &  mz_pop<upper)
  
  model_ratio <- lm(z~x -1,weights=1/x,data=mySI)
  b <- coef(model_ratio)
  mz_ratio <- b * mx_pop
  e_ratio <- residuals(model_ratio)
  se_ratio[i] <- sqrt(var(e_ratio)/n)
  margin <- qt(1-alpha/2,n-1,lower.tail=TRUE)*se_ratio[i]
  lower <- mz_ratio-margin
  upper <- mz_ratio+margin
  ind_ratio[i] <- (mz_pop>lower &  mz_pop<upper)
}
coverage_regr <- mean(ind_regr)
coverage_ratio <- mean(ind_ratio)
```

The coverage rates of the simple regression estimator and the ratio estimator equal `r round(coverage_regr,3)` and `r round(coverage_ratio,3)`, respectively. Both coverage rates are very close to the nominal coverage rate of 0.95.  So despite that the ratio estimator assumes an improper superpopulation model, the estimated confidence interval is still valid. The price we pay for the invalid model assumption is not an overestimated coverage rate of a confidence interval, but an increased standard error of the estimated population mean. The average over the 5,000 samples of the estimated standard error of the regression estimator equals `r round(mean(se_regr),3)`, whereas that of the ratio estimator equals `r round(mean(se_ratio),3)`. The larger standard error of the ratio estimator leads to wider confidence intervals, which explains that the coverage rate is still correct.

This sampling experiment is now repeated for samples sizes $n=10, 25, 50 , 100$ and for confidence levels $1-\alpha=0.01,0.02, \dots , 0.99$.

```{r, echo=FALSE, eval=FALSE}
n <- c(10,25,50,100)
alphas <- (1:99)/100
nsam <- 5000

mx_pop <- mean(mypopulation$x)
mz_pop <- mean(mypopulation$z)

mz_regr <- mz_ratio <- v_mz_regr <- v_mz_ratio <- av_mz_regr <- av_mz_ratio <- matrix(nrow=length(n), ncol=nsam)
ind_regr <- ind_ratio <- ind_regr_av <- ind_ratio_av <- array(dim=c(length(n), nsam, length(alphas)))

set.seed(314)
for (i in 1:length(n)){
  pi <- n[i]/N
  for (j in 1:nsam){
    units <- sample.int(N, size=n[i], replace=TRUE)
    mySI <- mypopulation[units,]
    mx_sam <- mean(mySI$x)
    mz_sam <- mean(mySI$z)
    model_regr <- lm(z~x, data=mySI)
    model_ratio <- lm(z~x -1, weights=1/x, data=mySI)
    mz_regr[i,j] <- mz_sam + coef(model_regr)[2]*(mx_pop-mx_sam)
    mz_ratio[i,j] <- mz_sam/mx_sam * mx_pop
    e_regr <- residuals(model_regr)
    e_ratio <- residuals(model_ratio)
    av_mz_regr[i,j] <- (var(e_regr)*(n[i]-1)/(n[i]-2))/n[i]
    av_mz_ratio[i,j] <- var(e_ratio)/n[i]
    g_regr <- 1 + (mx_pop-mx_sam)*(mySI$x-mx_sam)/(mean(mySI$x^2)-mx_sam^2)
    g_ratio <- mx_pop/mx_sam
    v_mz_regr[i,j] <- sum(g_regr^2*(e_regr/pi)^2)/N^2
    v_mz_ratio[i,j] <- sum(g_ratio^2*(e_ratio/pi)^2)/N^2
    for (k in 1:length(alphas)) {
      se <- sqrt(v_mz_regr[i,j])
      margin <- qt(1-alphas[k]/2, n[i]-2, lower.tail=TRUE)*se
      lower <- mz_regr[i,j]-margin
      upper <- mz_regr[i,j]+margin
      ind_regr[i,j,k] <- (mz_pop >lower &  mz_pop < upper)
      se <- sqrt(v_mz_ratio[i,j])
      margin <- qt(1-alphas[k]/2, n[i]-1, lower.tail=TRUE)*se
      lower <- mz_ratio[i,j]-margin
      upper <- mz_ratio[i,j]+margin
      ind_ratio[i,j,k] <- (mz_pop >lower &  mz_pop < upper)
      se <- sqrt(av_mz_regr[i,j])
      margin <- qt(1-alphas[k]/2, n[i]-2, lower.tail=TRUE)*se
      lower <- mz_regr[i,j]-margin
      upper <- mz_regr[i,j]+margin
      ind_regr_av[i,j,k] <- (mz_pop >lower &  mz_pop < upper)
      se <- sqrt(av_mz_ratio[i,j])
      margin <- qt(1-alphas[k]/2, n[i]-1, lower.tail=TRUE)*se
      lower <- mz_ratio[i,j]-margin
      upper <- mz_ratio[i,j]+margin
      ind_ratio_av[i,j,k] <- (mz_pop >lower &  mz_pop < upper)
    }
  }
}
save(mz_regr, mz_ratio, v_mz_regr, v_mz_ratio, av_mz_regr, av_mz_ratio, ind_regr, ind_ratio, ind_regr_av, ind_ratio_av, file="results/Coveragerates_modelassistedestimators.RData")
```

```{r coveragerates, echo=FALSE, out.width='100%', fig.cap="Empirical versus nominal coverage rates of confidence intervals for the population mean, estimated by the simple regression estimator, for sample sizes 10, 25, 50 and 100."}
load(file="results/Coveragerates_modelassistedestimators.RData")
n <- c(10,25,50,100)
alphas <- (1:99)/100
nsam <- 5000

Ep_mz_regr <- apply(mz_regr, MARGIN=1, FUN=mean)
Ep_mz_ratio <- apply(mz_ratio, MARGIN=1, FUN=mean)

Vp_mz_regr <- apply(mz_regr, MARGIN=1, FUN=var)
Vp_mz_ratio <- apply(mz_ratio, MARGIN=1, FUN=var)

Ep_av_mz_regr <- apply(av_mz_regr, MARGIN=1, FUN=mean)
Ep_av_mz_ratio <- apply(av_mz_ratio, MARGIN=1, FUN=mean)
Ep_v_mz_regr <- apply(v_mz_regr, MARGIN=1, FUN=mean)
Ep_v_mz_ratio <- apply(v_mz_ratio, MARGIN=1, FUN=mean)

coverage_regr <- coverage_ratio <- coverage_regr_av <- coverage_ratio_av <- matrix(nrow=length(n), ncol=length(alphas))
for (k in 1:length(alphas)){
  coverage_regr[,k] <- apply(ind_regr[,,k], MARGIN=1, FUN=mean)
  coverage_ratio[,k] <- apply(ind_ratio[,,k], MARGIN=1, FUN=mean)
  coverage_regr_av[,k] <- apply(ind_regr_av[,,k], MARGIN=1, FUN=mean)
  coverage_ratio_av[,k] <- apply(ind_ratio_av[,,k], MARGIN=1, FUN=mean)
}

df <- data.frame(confidence=1-alphas,
                 n10=coverage_regr_av[1,],
                 n25=coverage_regr_av[2,],
                 n50=coverage_regr_av[3,],
                 n100=coverage_regr_av[4,])

d <- df %>% pivot_longer(., cols=c("n10","n25","n50","n100"))
d$name <- factor(d$name, levels=c("n10","n25","n50","n100"), ordered=TRUE)

ggplot(d) +
  geom_abline(intercept=0,slope=1, colour="green") +  
  geom_point(mapping=aes(x=confidence, y=value), alpha=0.5) +
  scale_x_continuous(limits=c(0,1), name="Confidence level") +
  scale_y_continuous(limits=c(0,1), name="Coverage rate") +
  facet_wrap(~ name, ncol=2, nrow=2) +
  coord_fixed()
```

```{r plotcoverageratesratioestimator, echo=FALSE, out.width='100%', fig.cap="Empirical versus nominal coverage rates of confidence intervals for the population mean, estimated by the ratio estimator, for sample sizes 10, 25, 50 and 100."}

df <- data.frame(confidence=1-alphas,
                 n10=coverage_ratio_av[1,],
                 n25=coverage_ratio_av[2,],
                 n50=coverage_ratio_av[3,],
                 n100=coverage_ratio_av[4,])

d <- df %>% pivot_longer(., cols=c("n10","n25","n50","n100"))
d$name <- factor(d$name, levels=c("n10","n25","n50","n100"), ordered=TRUE)

ggplot(d) +
  geom_abline(intercept=0,slope=1, colour="green") +  
  geom_point(mapping=aes(x=confidence, y=value), alpha=0.5) +
  scale_x_continuous(limits=c(0,1), name="Confidence level") +
  scale_y_continuous(limits=c(0,1), name="Coverage rate") +
  facet_wrap(~ name, ncol=2, nrow=2) +
  coord_fixed()
```

```{r TableRegressionEstimator, echo=FALSE}
bias_regr <- (mz_pop - Ep_mz_regr)/mz_pop
Sp_regr <- sqrt(Vp_mz_regr)
ase_regr <- sqrt(av_mz_regr)
Ep_ase_regr <- apply(ase_regr, MARGIN=1, FUN=mean)
tabledf <- data.frame(size=n, bias=round(bias_regr,3), sd=round(Sp_regr,3), se=round(Ep_ase_regr,3))
knitr::kable(
  tabledf, caption = 'Estimated relative bias of regression estimator, standard deviation of 5000 regression estimates, and average of 5000 estimated standard errors of regression estimator.',
  col.names = c("Sample size","Bias","Standard deviation","Average standard error"),
  booktabs = TRUE
) %>%
  kable_classic()
```

```{r TableRatioEstimator, echo=FALSE}
bias_ratio <- (mz_pop - Ep_mz_ratio)/mz_pop
Sp_ratio <- sqrt(Vp_mz_ratio)
ase_ratio <- sqrt(av_mz_ratio)
Ep_ase_ratio <- apply(ase_ratio, MARGIN=1, FUN=mean)
tabledf <- data.frame(size=n, bias=round(bias_ratio,3), sd=round(Sp_ratio,3), se=round(Ep_ase_ratio,3))
knitr::kable(
  tabledf, caption = 'Estimated relative bias of ratio estimator, standard deviation of 5000 ratio estimates, and average of 5000 estimated standard errors of ratio estimator.',
  col.names = c("Sample size","Bias","Standard deviation","Average standard error"),
  booktabs = TRUE
) %>%
    kable_classic()
```

Figures \@ref(fig:coveragerates) and \@ref(fig:plotcoverageratesratioestimator) show that the empirical coverage rates are close to the nominal coverage rate, for all four sample sizes, both estimators, and all confidence levels. For the regression estimator and $n=10$ the empirical coverage rate is somewhat too small. This is because the standard error of the regression estimator is slightly underestimated at this sample size. The average of the estimated standard errors (square root of estimated variance of regression estimator) equals `r round(Ep_ase_regr[1],3)`, which is somewhat smaller than the standard deviation of the 5,000 regression estimates of `r round(Sp_regr[1],3)` (Table \@ref(tab:TableRegressionEstimator)). The relative bias, computed as 

\begin{equation}
bias = \frac{\frac{1}{5000}\sum_{s=1}^{5000} (\hat{\bar{z}}_s-\bar{z})}{\bar{z}} \;,
\end{equation}

is about 0 for both estimators and all four sample sizes.

Contrarily, if in the model-based approach a poor superpopulation model is used, then the predictions and the prediction error variances still are model-unbiased, but for the sampled population we may have serious systematic error in the estimated population mean, and the variance of local predictions may be seriously over- or underestimated. For that reason, model-based inference is also referred to as *model-dependent* inference\index{Model-dependent predictor}, stressing that we fully rely on the model, and that the validity\index{Validity} of the estimates and predictions depends on the quality of the model [@han83].


```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:32-StatisticalApproaches.Rmd-->

# (APPENDIX) Appendices {-}


# Answers to exercises {#Answers}

**R** scripts of the answers to the exercises are available at the Exercises folder of the github repository of this book.

## Introduction to probability sampling {-}

1. No this is not a probability sample because with this implementation the probabilities of selection of the  units are unknown.  
2. A simple way would be to generate with a random number generator $n$ integers between 1 and $N$. This can be done in **R** with function `sample.int`. For instance, `sample.int(1000,10)` selects fully randomly with equal probability 10 integers from the discrete interval $\{1,2,\dots,1000\}$.  

## Simple random sampling {-}

1. The most remarkable difference is the much smaller range of values in the sampling distribution of the estimator of the population mean. This can be explained by the smaller variance of the average of $n$ randomly selected values compared to the variance of an individual randomly selected value. A second difference is that the sampling distribution is more symmetric, less skewed to the right. This is an illustration of the central limit theorem.  
2. The variance (and so the standard deviation) becomes smaller.  
3. Then this difference will be very close to 0, showing that the estimator is unbiased.  
4. For simple random sampling without replacement (from a finite population) the sampling variance will be smaller. When units are selected with replacement, a unit can be selected more than once. This is inefficient as there is no extra information in the unit that has been selected before.  
5. The larger the population size $N$, the smaller this effect (given the sample size $n$).   
6. The true sampling variance of the estimator of the mean for simple random sampling from an infinite population can be computed with the population variance divided by the sample size: $V(\hat{\bar{z}})=S^2(z)/n$.  
7. This is because in reality we do not know the values of $z$ for all units in the population, so that we do not know the population variance $S^2(z)$.  
8. See [SI.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/SI.R). The 90\% confidence interval is less wide than the 95\% interval because a larger proportion of samples is allowed not to cover the population mean. The estimated standard error of the estimated total underestimates the true standard error because a constant bulk density is used. In reality this bulk density also varies.

## Stratified random sampling {-}

1. Strata EA and PA can be merged: their means are about equal.  
2. See STSI.R.  
3. The proof is as follows: $\sum_N\pi_i=\sum_H \sum_{N_h}\pi_{hi}=\sum_H \sum_{N_h}n_h/N_h=\sum_H n_h=n$.  
4. See [STSIcumrootf.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/STSIcumrootf.R).  
5. With at least two points per geostratum, the variance of the estimator of the stratum mean can be estimated without bias by the estimated stratum variance divided by the number of points in that stratum.  
6. On average the sampling variance of the estimator of the mean with $40 \times 1$ is smaller than with $20 \times 2$ points because the geographical spreading will be somewhat better (less spatial clustering).  
7. With geostrata of equal size and equal number of sampling points per geostratum, the sampling intensity is equal for all strata, so that the sample mean is an unbiased estimator of the population mean. In formula: $\hat{\bar{z}}= \sum\limits_{h=1}^{H} w_{h}\,\bar{z}_{\mathcal{S}h} = \frac{1}{H} \sum\limits_{h=1}^{H} \bar{z}_{sh} = \bar{z}_{\mathcal{S}}$ with $\bar{z}_{\mathcal{S}h}$ the average of the sample from stratum $h$ and $\bar{z}_{s}$ the average of all sampling points.  
8. See [STSIgeostrata.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/STSIgeostrata.R).  
  + Collapsing the geostrata on the basis of the measurements of the study variable is not a proper way, as it will lead to a biased estimator of the sampling variance of the estimator of the mean. The estimated stratum variances $\widehat{S}^2(z)$ will be small, and so the estimated sampling variance will underestimate the true sampling variance.  
  + I propose to group neighbouring geostrata, i.e. geostrata that are close to each other.  
  + The sampling variance is slightly overestimated because we assume that the two (or three) points within a collapsed stratum are selected by simple random sampling, whereas they are selected by stratified random sampling (a collapsed stratum consists of two or three geostrata), and so there is less spatial clustering compared to simple random sampling.  
9. See STSIgeostrata_composite.R.  
  + No, with bulking within strata the sampling variance cannot be estimated, because then we cannot estimate the sampling variances of the estimated stratum means, which are needed for estimating the sampling variance of the estimator of the population mean.  
  + If all aliquots are analyzed separately the estimated population mean is more precise (variance of the estimator of the mean is smaller) because the contribution of the measurement error to the total variance of the estimator of the mean is smaller.  
  + This does not work because with geostrata of unequal area the mean of a composite sample is a biased estimator of the population mean.  All aliquots bulked into a composite get equal weight, but they should get different weights because they do not represent equal fractions of the population.   

## Systematic random sampling {-}

1. See [SY.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/SY.R).  
2. As can be seen on the plot, the spatial coverage of the study area by the two systematic random samples can be quite poor. So I expect that the variance of the estimator of the mean using the data of two systematic random samples of half the expected size, is larger than the variance of the estimator of the mean based on the data of a single systematic random sample.   

## Cluster random sampling {-}

1. See [Cluster.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/Cluster.R).  
2. I expect that the sampling variance is larger, as the sampling points are more spatially clustered.  
3. With two independently selected clusters per stratum the sampling variance of the estimator of the mean can be estimated without bias, as the variance of cluster means within the strata can be estimated from the two cluster means.  

## Two-stage random sampling {-}

1. See [TwoStage.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/TwoStage.R).  
2. With ten psu draws and four ssu's per psu draw (10 $\times$ 4) the expected standard error of the estimated population is smaller than with 4 $\times$ 10 because spatial clustering of the sampling points is less strong.  
3. See [TwoStage.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/TwoStage.R).   
4. See [TwoStage.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/TwoStage.R).  
5. See [TwoStage.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/TwoStage.R).  
6. For the first variance component:
\begin{eqnarray}
\frac{1}{n} \sum_{j=1}^N p_j\left(\frac{t_j(z)}{p_j}-t(z)\right)^2 = 
\frac{1}{n} \sum_{j=1}^N p_j\left(M\frac{t_j(z)}{M_j}-M\bar{z}\right)^2 = \notag \\
\frac{1}{n} \sum_{j=1}^N p_j\left(M\left(\bar{z}_j-\bar{z}\right)\right)^2 
\frac{M^2}{n} \sum_{j=1}^N p_j\left(\bar{z}_j-\bar{z}\right)^2  \;.
\end{eqnarray}
For the second variance component:
\begin{eqnarray}
\frac{1}{n} \sum_{j=1}^N \frac{M_j^2 S^2_j}{m_j p_j}= 
\frac{1}{nm} \sum_{j=1}^N \frac{M_j^2 S^2_j}{p_j}= 
\frac{1}{nm} \sum_{j=1}^N M M_j S^2_j= \\
\frac{1}{nm} \sum_{j=1}^N M^2 \frac{M_j}{M} S^2_j= 
\frac{M^2}{nm} \sum_{j=1}^N p_j S^2_j  \;.
\end{eqnarray}
Division of both variance components by $M^2$ yields the variance estimator of the estimated population mean, Equation \@ref(eq:TrueVarEstMeanTwostage).

## Sampling with probabilities proportional to size {-}

1. See [pps.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/pps.R).  
2. No this field should not be included in the poppy area of that sampling unit because this field is outside the target area.  
3. Yes, this field must be included in the poppy area of that sampling unit as it is located inside the target area. The target area is the territory of Kandahar, regardless of how an area inside this territory is depicted on the map, as agricultural land or otherwise.    

## Balanced and well-spread sampling {-}

1. Spatial clustering may lead to a less precise estimate of the population mean. This will happen when the residuals of the regression model are spatially correlated (show spatial structure). This will occur when the spatial variation of the study variable is also determined by covariates or factors that are not used in balancing the sample.  If the residuals are not spatially correlated (white noise), spatial clustering does no harm.  
2. One advantage is that unequal inclusion probabilities can be used in the LPM design. If the sampling units have unequal size (as in the poppy survey of Kandahar) or if a covariate is available that is linearly related to the study variable (as in the aboveground biomass survey of Eastern Amazonia), sampling efficiency can be increased by sampling with (inclusion) probabilities proportional to size. The only option for random sampling from geostrata is then to select the unit(s) *within geostrata* by pps sampling.     

## Ratio and regression estimator {-}

1. See [RegressionEstimator.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/RegressionEstimator.R). In reality we do not have a population fit of the regression coefficients, but these coefficients must be estimated from a sample. The estimated coefficients vary among the samples, which explains that the experimental variance, i.e. the variance of the 10,000 regression estimates obtained by estimating the coefficients from the sample (Sample in Figure \@ref(fig:RegressionEstimatorsAmazonia)) is larger than the variance as computed with the population fit of the regression coefficients (Exhaust in Figure \@ref(fig:RegressionEstimatorsAmazonia)).  

The difference between the variance obtained with the population fit and the experimental variance (variance of regression estimator with sample fit of coefficients), as a proportion of the experimental variance, decreases with the sample size. The same holds for the difference between the approximated variance and the experimental variance. Both findings can be explained by the smaller contribution of the variance of the estimated regression coefficients to the variance of the regression estimator with the large sample size. The approximated variance does not account for the uncertainty about the regression coefficients, so that for all three sample sixes this approximated variance is about equal to the variance of the regression estimator as computed with the population fit of the regression coefficients.

```{r RegressionEstimatorsAmazonia, echo=FALSE, fig.asp=0.5, fig.cap="Variance of regression estimator of mean AGB with population fit of regression coefficients (Exhaust), with sample fit of regression coefficients (Sample), and approximated variance of regression estimator (Approx)"}
load(file="results/RegressionEstimator.RData")
names(df) <- c("n", "Exhaust", "Sample", "Approx")

library(tidyverse)
df_lf <- df %>% pivot_longer(.,cols=c("Exhaust", "Sample", "Approx"))

library(ggplot2)
ggplot(df_lf) +
  geom_point(mapping=aes(x=n, y=value, shape=name), size=2) +
  scale_shape_manual(values=c(1,0,2), name="") +
  scale_x_continuous(name="Sample size") +
  scale_y_continuous(name="Variance")
```
2. See [RatioEstimator.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/RatioEstimator.R). The population fit of the slope coefficient of the homoscedastic model differs from the ratio of the population total of poppy area and population total of agricultural area. For the heteroscedastic model these are equal.   

## Two-phase random sampling {-}

1. See [RegressionEstimator_Twophase.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/RegressionEstimator_Twophase.R). The variance of the regression estimator for two-phase sampling is considerably larger than the variance of the usual regression estimator (Figure \@ref(fig:RegressionEstimatorsAmazoniaTwoPhase)). The usual regression estimator exploits our knowledge of the population mean of the covariate SWIR2, whereas in two-phase sampling this population mean must be estimated from the first phase sample, introducing additional uncertainty.


```{r RegressionEstimatorsAmazoniaTwoPhase, echo=FALSE, fig.cap="Sampling distribution of simple regression estimator and simple regression estimator for two-phase sampling."}
load(file="results/RegressionEstimator_Twophase.RData")
load(file="data/Amazonia_1km.RData")

estimates<-data.frame(mz_reg2ph, mz_regr)
names(estimates)<-c("Regression_2phase","Regression")

df_lf <- estimates %>% pivot_longer(.,cols=c("Regression_2phase","Regression"))
ggplot(data=df_lf) +
    geom_boxplot(aes(y=value, x=name)) +
    geom_hline(yintercept=mean(gridAmazonia$AGB), colour="red") +
    scale_x_discrete(name = "Estimator") +
    scale_y_continuous(name = "Estimated mean AGB")
```

The average of the 10,000 approximated variances equals `r round(mean(av_mz_reg2ph),1)`, which is considerably smaller than the variance of the 10,000 regression estimates for two-phase sampling, which is equal to `r round(var(mz_reg2ph), 1)`.    

## Required sample size {-}

1. See [RequiredSampleSize_CIprop.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/RequiredSampleSize_CIprop.R). The plots show that the required sample size decreases sharply with the length of the confidence interval, and increases with the anticipated proportion.

A prior for the proportion is needed because the standard error of the estimated proportion is a function of the estimated proportion $\hat{p}$ itself: $se(\hat{p})=\frac{\sqrt{\hat{p}(1-\hat{p})}}{\sqrt{n}}$, so that the width of the confidence interval, computed with the normal approximation, is also a function of  $\hat{p}$, see Equation \@ref(eq:nreqwidthCIprop).

For a prior proportion $p^*$ of 0.5 the standard deviation $\sqrt{p^*(1-p^*)}$ is maximum. The closer the prior proportion to zero or one, the smaller the standard error of the estimated proportion, the smaller the required sample size. 

2. See [RequiredSampleSize_CIprop.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/RequiredSampleSize_CIprop.R). There is no need to compute the required sample size for prior proportions $> 0.5$, as this required sample size is symmetric. For instance, the required sample size for $p^*=0.7$ is equal to the required sample size for $p^*=0.3$.

## Model-based prediction of sampling variance of estimated mean  {-}

1. See [MBSamplingVarSI_VariogramwithNugget.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBSamplingVarSI_VariogramwithNugget.R). The predicted sampling variance is slightly larger compared to the predicted sampling variance obtained with the semivariogram without nugget (and the same sill and range), because 50\% of the spatial variation is not spatially structured, so that in sampling we can profit less from spatial correlation.   
2. See first part of [MBRequiredSampleSize_SIandSY.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBRequiredSampleSize_SIandSY.R).  
3. See second part of [MBRequiredSampleSize_SIandSY.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBRequiredSampleSize_SIandSY.R).  The model-based prediction of the required sample size for simple random sampling is 34, and for systematic random sampling 13. The design effect at a sample size of 34 equals 0.185. The design effect decreases with the sample size, i.e. the ratio of the variance with systematic random sampling to the variance with simple random sampling becomes smaller. This is because the larger the sample size, the more we profit from the spatial correlation.  

## Regular grid sampling {-}

1. See [SquareGrid.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/SquareGrid.R).

## Spatial coverage sampling {-}  

1. The optimal spatial coverage sample (optimal in terms of MSSD) consists of the four points in the center of the four subsquares of equal size.  
2. If we are also interested in the accuracy of the estimated plot mean, the sampling units should be selected randomly from the subsquares (strata). Preferably at least two points should then be selected from the strata, see Section \@ref(geostrata).   
3. See [SpatialCoverageCircularPlot.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/SpatialCoverageCircularPlot.R). 

```{r SCScircularplot, echo=FALSE, fig.cap="Spatial coverage samples of five and six points in a circular plot used as sampling unit."}
load(file="results/SpatialCoverageCircularPlot_5pnts.RData")
plt1 <- plot(myStrata, mySample)

load(file="results/SpatialCoverageCircularPlot_6pnts.RData")
plt2 <- plot(myStrata, mySample)

grid.arrange(plt1, plt2, nrow=1)
```

4. Bias can be avoided by constructing strata of equal size. Note that in this case we cannot use function `spsample` to select the centers of these geostrata. These centers must be computed by hand.  
5. See [SpatialInfill.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/SpatialInfill.R).  

## Covariate space coverage sampling {-}  

1. See [CovariateSpaceCoverageSample.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/CovariateSpaceCoverage.R).  
2. See second part of [CovariateSpaceCoverageSample.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/CovariateSpaceCoverage.R).

```{r CSCsamplingHunterValley, echo=FALSE, out.width='100%', fig.asp=0.5, fig.cap="Covariate space coverage samples, plotted in a scatter diagram of cti against ndvi. Two samples are selected, one using cti and ndvi as covariates in clustering, and one using cti, ndvi and elevation as clustering variables."}
load(file="results/CSCsampling_HunterValley.RData")

grd <- grdHunterValley %>% pivot_longer(.,cols=c("cluster","cluster2"))
grd$name <- factor(grd$name, levels=c("cluster","cluster2"), ordered=TRUE)
levels(grd$name) <- c("cti, ndvi","cti, ndvi, elevation")

df <- rbind(myCSCsample,myCSCsample2)
df$name <- rep(c("cluster","cluster2"),each=20)
df$name <- factor(df$name, levels=c("cluster","cluster2"), ordered=TRUE)
levels(df$name) <- c("cti, ndvi","cti, ndvi, elevation")

ggplot(grd) +
  geom_point(mapping=aes(x=ndvi,y=cti, colour=as.character(value)), alpha=0.5) +
  scale_colour_viridis_d() +
  geom_point(data=df, mapping=aes(x=ndvi,y=cti), size=2.5, colour="red") +
  scale_x_continuous(name = "ndvi") +
  scale_y_continuous(name = "cti") +
  theme(legend.position="none") +
  facet_wrap(~ name)
```

When using only two covariates (cti and ndvi), in a two-dimensional scatter diagram the sampling points are at the center of clearly visible clusters (Figure \@ref(fig:CSCsamplingHunterValley)). Plotting the clusters in a two-dimensional scatter diagram  yields pure clusters: a cluster does not contain any unit of a different cluster. However when more than two covariates are used in $k$-means clustering, in a two-dimensional scatter diagram the clusters are less clear because the multidimensional clusters are projected on a two-dimensional plane. In the case of the three covariates cti, ndvi, and elevation-m actually there is a third axis perpendicular to plane spanned by the covariates cti and ndvi. This also explains that with more than two covariates a sampling location (cluster center) can be quite close to another sampling location, after projection on a two-dimensional plane.

## Conditioned Latin hypercube sampling {-}  

1. See [cLHS.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/cLHS.R).
  +  Spatial coverage is improved by using the spatial coordinates as covariates, but it is not optimal in terms of mean squared shortest distance (MSSD).   
  +  It may happen that not all marginal strata of $s1$ and $s2$ are sampled. Even when all these marginal strata are sampled, this does not guarantee a perfect spatial coverage.  
  +  There are two unsampled marginal strata, and two marginal strata with two sampling locations. So the sum of the absolute values of the marginal stratum sample sizes minus 1 equals four. The minimised value (4.28) is slightly larger due to the contribution of O3 to the criterion.   

## Model-based optimisation of the grid spacing {-}

1. See [MBGridspacing_QOKV.Rmd](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBGridspacing_QOKV.Rmd). For P95 the tolerable grid spacing is $<$ 6 km, for P80 about 8.5 km and for P95 about 9 km (Figure \@ref(fig:QuantilesOKVarGridspacing)).    

```{r QuantilesOKVarGridspacing, echo=FALSE, fig.asp=0.7, fig.cap="Three quantiles of the ordinary kriging variance of predicted SOM in three woredas in Ethiopia, as a function of the grid spacing."}
load(file="results/MBGridSpacing_Ethiopia_QOKV.RData")

df <- result %>% pivot_longer(.,cols=c("V1","V2","V3"))
ggplot(data=df) +
  geom_point(mapping=aes(x=spacing, y=value, shape=name), size=3) +
  scale_shape_manual(values=c(0,1,2), labels=c("P50","P80","P95"), name="Criterion") +
  scale_x_continuous(name="Spacing (km)") +
  scale_y_continuous(name="Quantile kriging Variance")
```

2. See [MBGridspacing_Sensitivity.Rmd](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBGridspacing_MaxOKV.Rmd). Increasing the nugget by 5% and decreasing the range by 5% yields a tolerable grid spacing that is smaller than with the original semivariogram (Figure \@ref(fig:SensitivityMKV)). The tolerable grid spacings for a mean kriging variance of 0.85 are 10.6, 8.9 and 7.4 km for the original semivariogram, the semivariogram with increased nugget, and the semivariogram with the smaller range, respectively, leading to a required expected sample size of
97, 137 and 200 points.

```{r SensitivityMKV, echo=FALSE, fig.asp=0.7, fig.cap="Mean ordinary kriging variance predicted SOM in three woredas of Ethiopia, as a function of grid spacing for three semivariograms."}
load(file="results/MBGridSpacing_Ethiopia_Sensitivity.RData")

df_lf <- df %>% pivot_longer(.,cols=c("MKV","MKV_morenugget","MKV_smallerrange"))
ggplot(data=df_lf) +
  geom_point(mapping=aes(x=spacing, y=value, shape=as.factor(name)), size=3) +
  scale_x_continuous(name="Spacing (km)") +
  scale_y_continuous(name="Mean kriging variance") +
  scale_shape_manual(values=c(0,1,2), name="Semivariogram", labels=c("Original","More nugget","Smaller range"))
```

3. This variation can be explained by the random sample size (for a given spacing the number of points of a randomly selected grid inside the study area is not fixed but varies), and partly because the covariate values at the grid points vary, so that also the variance of the estimator of the mean differs among grid samples.   
4. See [MBGridspacing_MKEDV.Rmd](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBGridspacing_MKEDV.Rmd). The tolerable grid spacing for a mean kriging variance is 82 m.

## Model-based optimisation of sampling pattern {-}

1. See [MBSampleSquare_OK.Rmd](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBSampleSquare_OK.Rmd).  The optimised sample (Figure \@ref(fig:SixteenPntsInSquare)) is most likely not the global optimum. The spatial pattern is somewhat irregular. I expect the optimal sampling locations to be close to the centers of the subsquares.    

```{r SixteenPntsInSquare, echo=FALSE, out.width='50%', fig.cap="Optimised coordinates of sixteen sampling points for ordinary kriging."}
load(file="results/MBSampleSquare_OK_NoNugget_16pnts.RData")
sample<-res$points
s1 <- s2 <- 1:20 - 0.5
grid <- expand.grid(s1,s2)
names(grid) <- c("s1","s2")
ggplot(data = grid) +
  geom_tile(mapping = aes(x = s1, y = s2), fill="grey") +
  geom_point(data=sample,mapping = aes(x = x, y = y), size=2) +
  geom_vline(xintercept=c(5,10,15)) +
  geom_hline(yintercept=c(5,10,15)) +
  scale_x_continuous(name = "Easting") +
  scale_y_continuous(name = "Northing") +
  coord_fixed()
```

2. See [MBSample_QOKV.Rmd](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBSampleQOKV.Rmd). 

```{r MBsampleP90OKVCRF, echo=FALSE, fig.cap="Optimized sample pattern of 50 points on the Cotton Research Farm, using the P90 of ordinary kriging predictions of lnECE as a minimisation criterion."}
load(file="data/CottonResearchFarm.RData")
load(file="results/MBSample_OK_P90_Uzbekistan.RData")
ggplot(data=EM_CRF) +
  geom_raster(mapping = aes(x = x1/1000, y = x2/1000),fill="grey") +
  geom_point(data = mysample, mapping = aes(x = x/1000, y = y/1000), size= 2) +
  scale_x_continuous(name = "Easting (km)") +
  scale_y_continuous(name = "Northing (km)") +
  coord_fixed() 
```

Figure \@ref(fig:MBsampleP90OKVCRF) shows the optimised sample pattern. Compared with the optimised sample pattern using the *mean* ordinary kriging variance as a minimisation criterion (Figure \@ref(fig:ModelBasedSampleOK)), the sampling locations are pushed more to the border of the study area. This is because with, for instance, a spatial coverage sample, near the border the kriging variances are the largest. By pushing sampling locations towards the border, the kriging variances in this border zone are strongly reduced. 

3. See [MBSampleSquare_KED.Rmd](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBSampleSquare_KED.Rmd). Figure \@ref(fig:EffectNuggetOptimalSamplePattern) shows the optimised sample patterns with the three semivariograms.  
  + With zero nugget and a (partial) sill of 2 the sampling points are well spread throughout the area.       
  + With a nugget of 1.5 and a partial sill of 0.5 the sampling points are pushed toward the left and right side of the square. With this residual semivariogram the contribution of the variance of the predictor of the mean (as a proportion) to the total kriging variance is larger than with the previous semivariogram. By shifting the sampling points towards the left and right side of the square this contribution becomes smaller. At the same time the variance of the interpolation error increases as the spatial coverage becomes worse. The optimised sample is the right balance of these two variance components.  
  + With a pure nugget semivariogram all sampling points are at the left and right side of the square. This is because with a pure nugget semivariogram the variance of the interpolation error is independent of the locations (the variance equals the nugget variance everywhere), while the variance of the predictor of the mean is minimal for this sample.  

```{r EffectNuggetOptimalSamplePattern, echo=FALSE, out.width='100%', fig.cap="Effect of size of nugget on optimised coordinates of sixteen points for kriging with an external drift."}
s1 <- s2 <- 1:20 - 0.5
grid <- expand.grid(s1,s2)
names(grid) <- c("s1","s2")

load(file="results/MBSampleSquare_KED_NoNugget_16pnts.RData")
sample_nonug<-res$points
load(file="results/MBSampleSquare_KED_LargeNugget_16pnts.RData")
sample_largenug<-res$points
load(file="results/MBSampleSquare_KED_PureNugget_16pnts.RData")
sample_purenug<-res$points

mysamples <- rbind(sample_nonug,sample_largenug,sample_purenug)
mysamples$model <- rep(c("no","large","pure"), each=16)

ggplot(data=mysamples) +
  geom_tile(data=grid, mapping = aes(x = s1, y = s2, fill = s1)) +
  geom_point(mapping = aes(x = x, y = y), colour="red", size=1.5) +
  scale_fill_continuous(name="x",type= "viridis") +
  geom_vline(xintercept=c(5,10,15)) +
  geom_hline(yintercept=c(5,10,15)) +
  scale_x_continuous(name = "Easting") +
  scale_y_continuous(name = "Northing") +
  facet_wrap(~ model) +
  coord_fixed()
```

## Sampling for estimating the semivariogram {-}

1. See [NestedSampling_v1.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/NestedSampling_v1.R).  
2. See [SI_PointPairs.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/SI_PointPairs.R). With the seed I used (314) the variance of the estimator of the range parameter is much smaller compared to that obtained with the larger separation distances.  
3. See [MBSample_SSA_logdet.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBSample_SSA_logdet.R). Figure \@ref(fig:MBSampleLogdetHV) shows the optimised sample pattern.

```{r MBSampleLogdetHV, echo=FALSE, fig.cap="Model-based sample for estimating the semivariogram, using logdet as a minimisation criterion. The prior semivariogram used in optimising the sample pattern is an exponential semivariogram with a range of 200 m and a ratio of spatial dependence of 0.5."}
load(file="data/HunterValley.RData")
load(file="results/MBSample_logdet_phi200nug05.RData")
ggplot(data=grdHunterValley) +
  geom_raster(mapping = aes(x = Easting/1000, y = Northing/1000), fill="grey")+
  geom_point(data = mysample, mapping = aes(x = x/1000, y = y/1000), shape = 1, size= 2)+
  scale_x_continuous(name = "Easting (km)")+
  scale_y_continuous(name = "Northing (km)")+
  coord_fixed() 
```

4. See [MBSample_SSA_varkrigvar.R](https://git.wageningenur.nl/brus003/spatialsamplingwithr/tree/master/Exercises/MBSample_SSA_varkrigvar.R). Figure \@ref(fig:MBSampleVarkrigvarHV) shows the optimised sample pattern.

```{r MBSampleVarkrigvarHV, echo=FALSE, fig.cap="Model-based sample for estimating the semivariogram, using the variance of the kriging variance (VKV) as a minimisation criterion. The prior semivariogram used in optimising the sample pattern is an exponential semivariogram with a range of 200 m and a ratio of spatial dependence of 0.5."}
load(file="data/HunterValley.RData")
load(file="results/MBSample_varkrigvar_phi200nug05.RData")
ggplot(data=grdHunterValley) +
  geom_raster(mapping = aes(x = Easting/1000, y = Northing/1000),fill="grey")+
  geom_point(data = mysample, mapping = aes(x = x/1000, y = y/1000), shape = 1, size= 2)+
  scale_x_continuous(name = "Easting (km)")+
  scale_y_continuous(name = "Northing (km)")+
  coord_fixed() 
```

## Sampling for validation {-}

1. I am not certain about that, because the computed  MSE's are estimates of the population MSE's only, and I am uncertain about both population MSE's.  
2. The standard errors of the estimated ME's are large when related to the estimated ME's, so my guess is that we do not have enough evidence against the hypothesis that there is no systematic error.  
3. Both standard errors are large compared to the difference in MSE's, so maybe there is no significant difference. However we must be careful, because the variance of the difference in MSE's cannot be computed as the sum of the variances of estimated MSE's. This is because the two predictions errors at the same location are correlated, so the covariance must be subtracted from the sum of the variances to obtain the variance of the estimator of the difference in MSE's.

```{r, echo=FALSE}
rm(list=ls())
```

<!--chapter:end:98-Answers.Rmd-->

`r if(knitr:::is_html_output()) '# References {-}'`

<!--chapter:end:99-References.Rmd-->

