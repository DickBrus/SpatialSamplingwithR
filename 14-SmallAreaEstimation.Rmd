# Sampling for estimating parameters of (small) domains {#SmallAreaEstimation}

This chapter is about probability sampling and estimation of means or totals of subpopulations (subareas, subregions). In the sampling literature these subpopulations are referred to as domains of interest\index{Domains of interest}, or shortly domains. Ideally at the stage of designing a sample these domains are known, and of every population unit we know to which domain it belongs. In that situation it is most convenient to use these domains as strata in random sampling, so that we can control the sample size in each domain (Chapter \@ref(STSI)). 

If we have multiple maps with domains, think for instance of a soil class map, a map with land cover classes, and a map with countries, we can make an overlay of these maps to construct the cross-tabulation strata. However, this may result in numerous strata, in some cases even more than the sample size. In this situation an attractive solution is multi-way stratification (Section \@ref(Multiwaystratification)). With this design the domains of interest are used as strata, not their cross-classification, and the sample sizes of these marginal strata are controlled.

Even with a multi-way stratified sample, resulting in controlled sample sizes for each domain, the sample size of a domain can be too small for a reliable estimate of the total or mean when using the data of that domain only. In that case we may use model-assisted estimators. In Chapter \@ref(Modelassisted) model-assisted estimation of the population mean or total is explained, using all data collected from the population are used. In this chapter (Section \@ref(SmallDomainsModelAssisted)) also data outside the domain are used, more specifically to estimate the population regression coefficients (@cha94, @Rao2003, @Falorsi2008).

We may also wish to estimate the mean or total of domains that are not used as (marginal) strata. The sample size in these domains is then not controlled, and varies among samples selected with the sampling design. As before with multi-way stratified sampling, the mean can either be estimated with the direct estimator, using the data from the domain only (Section \@ref(LargeDomainsDirectEstimator)), or a model-assisted estimator, also using data from outside the domain for estimating regression coefficients (Section \@ref(SmallDomainsModelAssisted)).

## Direct estimator for large domains {#LargeDomainsDirectEstimator}

If the sample size of a domain $d$ is considered large enough to obtain a reliable estimate of the mean, and besides the size of the domain is known, the mean of that domain can be estimated by the direct estimator\index{Direct estimator}:

\begin{equation}
\hat{\bar{z}}_{d}=\frac{1}{N_{d}}\sum_{k \in \mathcal{S}_d}\frac{z_{dk}}{\pi _{dk}} \;,
(\#eq:piestimatormeandomain)
\end{equation}

where $N_{d}$ is the size of the domain, $z_{dk}$ is the value for unit $k$ of domain $d$, and $\pi _{dk}$ is the inclusion probability of this point.

When the domain is not used as a (marginal) stratum, so that the sample size of the domain is random, the mean of the domain can best be estimated by

\begin{equation}
\hat{\bar{z}}_{\text{ratio},d}= \frac{\hat{t}_d(z)}{\widehat{N}_d}=
\frac{\sum_{k \in \mathcal{S}_d}\frac{z_{dk}}{\pi_{dk}}}{\sum_{k \in \mathcal{S}_d}\frac{1}{\pi_{dk}}} \;.
(\#eq:generalratiodomain)
\end{equation}

with $\widehat{N}_{d}$ the estimated size of the domain:

\begin{equation}
\widehat{N}_{d}=\sum_{k \in \mathcal{S}_d}\frac{1}{\pi _{i}} \;.
(\#eq:piestimatorpopulationsize)
\end{equation}

This ratio estimator\index{Ratio estimator} can also be used when the size of the domain is unknown. An example of this is estimating the mean of soil classes *as observed in the field*, and not *as depicted on a soil map*. A soil map is impure, i.e. the map units contain patches with other soil classes than as indicated on the map. The area of a given true soil class is not known. 

For simple random sampling $\pi_{dk} = n/N$. Inserting this in Equation \@ref(eq:generalratiodomain) gives

\begin{equation}
\hat{\bar{z}}_{\text{ratio},d}=\frac{1}{n_{d}}\sum_{k \in \mathcal{S}_d}z_{dk} \;.
(\#eq:ratiodomainSI)
\end{equation}

The mean of the domain is simply estimated by the mean of the $z$-values observed in the domain, i.e. the sample mean in domain $d$. The variance of this estimator can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\text{ratio},d}\right) =
\frac{1}{\hat{a}_{d}^{2}}\cdot\frac{1}{n\,(n-1)}\sum_{k \in \mathcal{S}_d}(z_{dk}-\bar{z}_{\mathcal{S}_d})^{2} \;,
(\#eq:VarratiodomainSI)
\end{equation}

where $\bar{z}_{\mathcal{S}_d}$ is the sample mean in domain $d$, and $\hat{a}_{d}$ is the estimated relative size of domain $d$:

\begin{equation}
\hat{a}_{d}=\frac{n_{d}}{n} \;.
(\#eq:estimatedrelativesizedomain)
\end{equation}

I refer to Section 8.2.2 in @gru06 for the ratio estimator and its standard error with stratified simple random sampling in case the domains cut across the strata, and other sampling designs.

The ratio estimator and its standard error can be computed with function `svyby` of package **survey** [@Lumley2020]. This is illustrated with Eastern Amazonia. We wish to estimate the mean aboveground biomass (AGB) of the sixteen ecoregions from a simple random sample of 200 units.

```{r, echo=FALSE}
load(file="data/Amazonia_1km.RData")
mz_pop <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=mean)
```

```{r}
library(survey)
n <- 200
set.seed(314)
units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
mysample <- gridAmazonia[units,c("AGB","Ecoregion")]
mysample$N <- nrow(gridAmazonia)
design_si <- svydesign(id=~1, data=mysample, fpc=~N)
res <- svyby(~AGB, by=~Ecoregion, design=design_si, FUN=svymean)
```

The ratio estimates are shown in Table \@ref(tab:TableRatioEstimatesEcoregions).

```{r TableRatioEstimatesEcoregions, echo=FALSE}
rownames(res) <- NULL
res[,c(2,3)] <- round(res[,c(2,3)],1)
knitr::kable(
  res, caption = 'Ratio estimates of mean aboveground biomass (AGB) and their standard errors of ecoregions in Eastern Amazonia. The ecoregions with an estimated standard error of 0.0 have one sampling unit only, and actually are non-availables.',
  booktabs = TRUE
) %>%
  kable_classic()
```

The sampling is repeated 1,000 times, and every sample is used to estimate the mean AGB of the ecoregions both with the $\pi$ estimator and the ratio estimator. As can be seen below the standard error of the ratio estimator is much smaller than the standard deviation of the $\pi$ estimator. The reason is that the number of sampling units in a ecoregion varies among samples, i.e. the sample size of an ecoregion is random. When many units are selected from an ecoregion, the estimated total of that ecoregion is large. The estimated mean as obtained with the $\pi$ estimator then is large too, because the estimated total is divided by the fixed size (total number of population units, $N_d$) of the ecoregion. However, in the ratio estimator the size of an ecoregion is estimated from the same sample, despite that we know its size, see Equation \@ref(eq:generalratiodomain). With many units selected from an ecoregion, the estimated size of that ecoregion, $\widehat{N}_d$ is also large. By dividing the large estimated total by the large estimated size, a more stable estimate of the mean of the domain is obtained. For quite a few ecoregions the standard errors are very large, especially of the $\pi$ estimator. These are the ecoregions with very small average sample sizes. With simple random sampling the expected sample size can simply be computed by $E[n] = n \; N_d/N$. In the following section alternative estimators are described for these ecoregions with small expected sample sizes. To speed up the computations I used a 5 km $\times$ 5 km subgrid in this sampling experiment.

```{r, echo=FALSE, eval=FALSE}
load(file="data/Amazonia_5km.RData")
mz_pop <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=mean)
ecoregions <- sort(unique(gridAmazonia$Ecoregion))
N <- nrow(gridAmazonia)
N_eco <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=length)
number_of_samples <- 1000
mx_eco_pop <- tapply(gridAmazonia$lnSWIR2, INDEX=gridAmazonia$Ecoregion, FUN=mean)
mX_eco_pop <- data.frame(Intercept=rep(1, length(mx_eco_pop)), lnSWIR2=mx_eco_pop)

set.seed(314)
mz_eco_HT <- mz_eco_ratio <- mz_eco_regr <- mz_eco_synt <- mz_eco_extsynt <- matrix(nrow=length(ecoregions), ncol=number_of_samples, dimnames=list(ecoregions,seq(1:number_of_samples)))
for (i in 1:number_of_samples) {
  print(i)
  mypop <- gridAmazonia
  units <- sample.int(nrow(mypop), size=n, replace=FALSE)
  mysample <- mypop[units,c("AGB","Ecoregion")]

# HT estimator
  tz <- (N/n) * tapply(mysample$AGB, INDEX=mysample$Ecoregion, FUN=sum)
  mz_eco_HT[names(tz),i] <- tz/N_eco[names(tz)]

# ratio estimator
  mysample$N <- N
  design_si <- svydesign(id=~1, data=mysample, fpc=~N)
  res <- svyby(~AGB, by=~Ecoregion, design=design_si, FUN=svymean)
  mz_eco_ratio[res$Ecoregion,i] <- res$AGB
  
# regression estimator
  mypop$ind <- rep(0,nrow(mypop))
  mypop$ind[units] <- 1
  mypop$AGB[mypop$ind == 0] <- NA 
  res <- forestinventory::twophase(AGB~lnSWIR2, data=mypop,
                                   phase_id=list(phase.col="ind",terrgrid.id=1),
                                   small_area=list(sa.col="Ecoregion",areas=ecoregions,unbiased=TRUE),
                                   psmall=TRUE, exhaustive=mX_eco_pop)$estimation
  mz_eco_regr[,i] <- res$estimate

# synthetic estimator
  res <- forestinventory::twophase(AGB~lnSWIR2, data=mypop,
                                   phase_id=list(phase.col="ind",terrgrid.id=1),
                                   small_area=list(sa.col="Ecoregion",areas=ecoregions,unbiased=FALSE),
                                   psmall=FALSE, exhaustive=mX_eco_pop)$estimation
  mz_eco_synt[,i] <- res$estimate
  
# extended synthetic estimator
  res <- forestinventory::twophase(AGB~lnSWIR2, data=mypop,
                                   phase_id=list(phase.col="ind",terrgrid.id=1),
                                   small_area=list(sa.col="Ecoregion",areas=ecoregions,unbiased=TRUE),
                                   psmall=FALSE, exhaustive=mX_eco_pop)$estimation
  mz_eco_extsynt[,i] <- res$estimate

}
save(mz_eco_HT, mz_eco_ratio, mz_eco_regr, mz_eco_synt, mz_eco_extsynt, file="results/MeanAGB_ecoregions.RData")
```

No covariates are used in the ratio estimator. If we wish to exploit covariates, the mean of a domain can best be estimated by the ratio of the regression estimate of the domain total (Chapter \@ref(Modelassisted)) and the estimated size of the domain:

\begin{equation}
\hat{\bar{z}}_{\text{ratio},d}= \frac{\hat{t}_{\text{regr},d}(z)}{\widehat{N}_d}\;.
\end{equation}

## Model-assisted estimators for small domains {#SmallDomainsModelAssisted}

When the domains are not well represented in the sample, the direct estimators from the previous section lead to large standard errors. In this situation we may try to increase the precision by also using observations from outside the domain. If we have covariates related to the study variable, we may exploit this ancillary information by fitting a regression model relating the study variable to the covariates, and using the fitted model to predict the study variable for all population units (nodes of discretisation grid), see Chapter \@ref(Modelassisted)\index{Model-assisted approach}. However, for small domains\index{Small domain} we may have too few sampled units in that domain to fit a separate regression model. The alternative then is to use the entire sample to estimate the regression coefficients and to use this global regression model to estimate the means of the domains. This introduces a systematic error, a design-bias, in the estimator. However, this extra error is potentially outweighed by the reduction of the random error due to the use of the globally estimated regression coefficients. If one or more units are selected from a domain, the observations of the study variable on these units can be used to correct for the bias. This leads to the regression estimator for small domains\index{Regression estimator!for small domains}. In the absence of such data, the mean of the domain can still be estimated by the so-called synthetic estimator\index{Synthetic estimator}.

There are quite a few packages for model-assisted estimation of means of small areas, the **maSAE** package [@maSAE], the **JoSAE** package [@JoSAE], the **rsae** package [@rsae], and the **forestinventory** package [@Hill2021]. I use package **forestinventory** for model-assisted estimation, and package **JoSAE** for model-based prediction of the means of small areas.

### Regression estimator {#RegressionestimatorSmallDomain}

In the regression estimator the potential bias due to the globally estimated regression coefficients, can be eliminated by adding the $\pi$ estimator of the mean of the regression residuals to the mean of the predictions in the domain(compare with Equation \@ref(eq:GREG)) (@Mandallaz2007, @Mandallaz2013):

\begin{equation}
\hat{\bar{z}}_{\text{regr},d} = \frac{1}{N_d} \sum_{k=1}^{N_d} \mathbf{x}^{\mathrm{T}}_{dk} \hat{\mathbf{b}} + \frac{1}{N_d} \sum_{k \in \mathcal{S}_d} \frac{\epsilon_{dk}}{\pi_{dk}} = \bar{\mathbf{x}}_d^{\mathrm{T}} \hat{\mathbf{b}} + \frac{1}{N_d} \sum_{k \in \mathcal{S}_d} \frac{\epsilon_{dk}}{\pi_{dk}} \;,
(\#eq:regressionestimatorsmalldomain)
\end{equation}

with $\mathbf{x}_{dk}$ the vector with covariate values for unit $k$ in domain $d$, $\hat{\mathbf{b}}$ the vector with globally estimated regression coefficients, $\epsilon_{dk}$ the residual for unit $k$ in domain $d$, $\pi_{dk}$ the inclusion probability of that unit, and $\bar{\mathbf{x}}_d$ the mean of the covariates in domain $d$. Alternatively the mean of the residuals in a domain is estimated by the ratio estimator:

\begin{equation}
\hat{\bar{z}}_{\text{regr},d} =  \bar{\mathbf{x}}_d^{\mathrm{T}} \hat{\mathbf{b}} + \frac{1}{\widehat{N}_d} \sum_{k \in \mathcal{S}_d} \frac{\epsilon_{dk}}{\pi_{dk}} \;,
(\#eq:regressionestimatorsmalldomainratio)
\end{equation}

with $\widehat{N}_d$ the estimated size of domain $d$, see Equation \@ref(eq:generalratiodomain). The regression coefficients can be estimated by Equation \@ref(eq:EstimatorMultipleRegressionCoefficients). With simple random sampling the second term in this estimator is equal to the sample mean of the residuals, so that the estimator reduces to 

\begin{equation}
\hat{\bar{z}}_{\text{regr},d}=\bar{\mathbf{x}}_d^{\mathrm{T}} \hat{\mathbf{b}} + \bar{\epsilon}_{\mathcal{S}_d}\;,
(\#eq:regressionestimatorsmalldomainSI)
\end{equation}

with $\bar{\epsilon}_{\mathcal{S}_d}$ the sample mean of the residuals in domain $d$.

A regression estimate can only be computed if we have at least one observation of the study variable in the domain $d$. The variance of the regression estimator of the mean for a small domain can be estimated by [@Hill2021]

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\text{regr},d}\right) = \bar{\mathbf{x}}_d^{\mathrm{T}} \widehat{\mathbf{C}}(\hat{\mathbf{b}}) \bar{\mathbf{x}}_d + \widehat{V}\!\left(\hat{\bar{e}}_d \right)\;,
(\#eq:Varregressionestimatorsmalldomain)
\end{equation}

with $\widehat{\mathbf{C}}(\hat{\mathbf{b}})$ the matrix with estimated sampling variances and sampling covariances of the regression coefficients. The first variance component is the contribution due to uncertainty about the regression coefficients, the second component accounts for the uncertainty about the mean of the residuals in the domain. For simple random sampling the sampling variance of the $\pi$ estimator of the mean of the residuals in a domain can be estimated by the sample variance of the residuals in that domain divided by the sample size $n_d$. This variance estimator is presented in @Hill2021. If the domain is not used as a stratum, and the domain mean of the residuals is estimated by the ratio estimator, the second variance component can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{e}}_{\text{ratio},d}\right) = \frac{1}{\hat{a}_{d}^{2}}\cdot\frac{1}{n\,(n-1)}\sum_{k \in \mathcal{S}_d}(\epsilon_{dk}-\bar{\epsilon}_{\mathcal{S}_d})^{2} \;,
(\#eq:Varratioestimatorofmeanresidual)
\end{equation}

where $\hat{a}_{d}$ is the estimated relative size of domain $d$:

\begin{equation}
\hat{a}_{d}=\frac{n_{d}}{n} \;.
\end{equation}

With simple random sampling the sampling variances and covariances of the estimated regression coefficients can be estimated by (see Equation 2 in @Hill2021)

\begin{equation}
\widehat{\mathbf{C}}(\hat{\mathbf{b}}) = \frac{1}{n} \left( \sum_{k \in \mathcal{S}} \mathbf{x}_k \mathbf{x}^{\mathrm{T}}_k \right) ^{-1} \left( \frac{1}{n^2} \sum_{k \in \mathcal{S}} \epsilon_k^2  \mathbf{x}_k \mathbf{x}^{\mathrm{T}}_k \right) \frac{1}{n}\left(\sum_{k \in \mathcal{S}}^n \mathbf{x}_k \mathbf{x}^{\mathrm{T}}_k \right)^{-1} \;.
(\#eq:samplingVarregressioncoefficients)
\end{equation}

Note that these sampling variances and covariances are not equal to the model variances and covariances of the estimated regression coefficients as obtained with multiple linear regression, using functions `lm` and `vcov`, see Chapter \@ref(Approaches).

Function `twophase` of package **forestinventory** [@Hill2021] can be used to compute the regression estimator for small domains and its standard error. The name 'twophase' is somewhat confusing. It suggests that we have a large sample which is subsampled in a second phase, as described in Chapter \@ref(Twophase). This is not the case here. However, @Hill2021 considers infinite populations, and they treat the grid that discretises this infinite population as the first phase sample. The sampling error introduced by this discretisation grid can then be accounted for. I ignore this sampling error, it will be very small anyway, because the number of grid cells is very large. This can be done by assigning the domain means of the covariates to argument `exhaustive` of function `twophase`.  Function `twophase` assumes simple random sampling (unless optional argument `cluster` is used). Note that for the unobserved population units (not selected units) the AGB values are changed into non-availables. In package `survey` also a function `twophase` is defined, for that reason the  name of the package is made explicit by `forestinventory::twophase`. With arguments `psmall=TRUE` and element `unbiased=TRUE` in the list `small_area` the regression estimate is computed.

```{r, echo=FALSE}
load(file="data/Amazonia_1km.RData")
mz_pop <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=mean)
```

```{r}
library(forestinventory)
n <- 200
set.seed(314)
units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
gridAmazonia$ind <- rep(0,nrow(gridAmazonia))
gridAmazonia$ind[units] <- 1
gridAmazonia$AGB[gridAmazonia$ind == 0] <- NA 
mx_eco_pop <- tapply(
  gridAmazonia$lnSWIR2, INDEX=gridAmazonia$Ecoregion, FUN=mean)
mX_eco_pop <- data.frame(
  Intercept=rep(1,length(mx_eco_pop)), lnSWIR2=mx_eco_pop)
ecos_in_sam <- unique(mysample$Ecoregion)
res <- forestinventory::twophase(AGB~lnSWIR2, data=gridAmazonia,
  phase_id=list(phase.col="ind", terrgrid.id=1),
  small_area=list(sa.col="Ecoregion", areas=sort(ecos_in_sam), unbiased=TRUE),
  psmall=TRUE, exhaustive=mX_eco_pop)
regr <- res$estimation
```

```{r TableRegressionEstimatesEcoregions, echo=FALSE}
df <- regr[c("area","estimate","ext_variance","g_variance","n2G")]
df[,c(2,3,4)] <- round(df[,c(2,3,4)],1)

knitr::kable(
  df, caption = 'Regression estimates of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia, using lnSWIR2 as a predictor. For explanation of variances of regression estimator, see text. In the final column the number of sampling units per ecoregion is listed.',
  booktabs = TRUE, col.names=c("Ecoregion","AGB","ext_var","g_var","n2G")
) %>%
  kable_classic()
```

The alternative is to save the selected units (the sample) in a `data.frame`, assigned to argument `data`. The results are identical because the true means of the covariate $x$ assigned to argument `exhaustive` contains all required information at the population level.

For two ecoregions no estimate of the mean AGB is obtained (Table \@ref(tab:TableRegressionEstimatesEcoregions)). No units are selected from these domains. The variance of the estimated domain mean is in the column `g_variance`. The column `ext_variance` ignores the first variance component  of Equation \@ref(eq:Varregressionestimatorsmalldomain). Note that for the ecoregions with a sample size of one unit (the sample sizes per domain are in column `n2G`) no estimate of the variance is available, because the variance of the estimated mean of the residuals cannot be estimated from one unit.

Figure \@ref(fig:RatioversusRegrEcoregions) shows the regression estimates plotted against the ratio estimates. The variation of the regression estimates is smaller than those of the ratio estimates. The intercept of the line, fitted with ordinary least squares (OLS), is larger than 0, and the slope is smaller than 1. Using the regression model predictions in the estimation of the means leads to some smoothing.

```{r RatioversusRegrEcoregions, echo=FALSE, fig.cap="Scatterplot of ratio estimate and regression estimate of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia. In the regression estimate lnSWIR2 is used as a predictor. The line is fitted by ordinary least squares."}
mysample$N <- nrow(gridAmazonia)
design_si <- svydesign(id=~1, data=mysample, fpc=~N)
res <- svyby(~AGB, by=~Ecoregion, design=design_si, FUN=svymean)

names(regr)[1] <- "Ecoregion"

df <- merge(res,regr, by="Ecoregion")
slr <- lm(estimate~AGB, data=df)
ab <- coef(slr)
ggplot(data=df) +
        geom_point(mapping=aes(x=AGB, y=estimate), size=2) +
        geom_abline(intercept=ab[1], slope=ab[2])+
        scale_x_continuous(name="Ratio estimate", limits=c(50,300)) +
        scale_y_continuous(name="Regression estimate", limits=c(50,300))+
        coord_fixed()
```

I quantified the gain in the precision due to the use of the regression model by the variance of the ratio estimator divided by the variance of the regression estimator (Table \@ref(tab:TableGainRegressionestimator)). For ratios larger than 1 there is a gain in precision. Both variances are estimated from the 1,000 repeated ratio and regression estimates. For all but two small ecoregions there is a gain. For quite a few ecoregions the gain is quite large. These are the ecoregions where the globally fitted regression model explains a large part of the spatial variation of AGB.

```{r TableGainRegressionestimator, echo=FALSE}
load(file="results/MeanAGB_ecoregions.RData")
ecoregions <- sort(unique(gridAmazonia$Ecoregion))
v_ratio <- apply(mz_eco_ratio, MARGIN=1, FUN=var, na.rm=TRUE)
v_regr <- apply(mz_eco_regr, MARGIN=1, FUN=var, na.rm=TRUE)
gain <- round(v_ratio/v_regr,2)
df <- data.frame(ecoregions, gain=gain)
rownames(df) <- NULL
knitr::kable(
  df, caption = 'Gain in precision of estimated mean of AGB of ecoregions in Eastern Amazonia, as quantified by the estimated variance of the ratio estimator (no covariate used) divided by the estimated variance of the regression estimator (using lnSWIR2 as a predictor).',
  booktabs = TRUE,col.names=c("Ecoregions","Gain")
) %>%
  kable_classic()
```


### Synthetic estimator

For small domains from which no units are selected, the mean can still be estimated by the synthetic estimator\index{Synthetic estimator}, also referred to as the synthetic regression estimator:

\begin{equation}
\hat{\bar{z}}_{\text{syn},d}=\bar{\mathbf{x}}_d^{\mathrm{T}} \hat{\mathbf{b}}\;.
(\#eq:syntheticestimatorsmalldomain)
\end{equation}

So the second term in Equation \@ref(eq:regressionestimatorsmalldomain) is dropped. The variance can be estimated by

\begin{equation}
\widehat{V}\!\left(\hat{\bar{z}}_{\text{syn},d}\right) = \bar{\mathbf{x}}_d^{\mathrm{T}} \widehat{\mathbf{C}}(\hat{\mathbf{b}}) \bar{\mathbf{x}}_d \;.
(\#eq:Varsyntheticestimatorsmalldomain)
\end{equation}

This is equal to the first variance component of Equation \@ref(eq:Varregressionestimatorsmalldomain). 
The synthetic estimate can be computed with function `twophase`, with arguments `psmall=FALSE` and element `unbiased=FALSE` in the list `small_area` .

```{r}
res <- forestinventory::twophase(AGB~lnSWIR2, data=gridAmazonia,
  phase_id=list(phase.col="ind", terrgrid.id=1),
  small_area=list(sa.col="Ecoregion", areas=ecoregions, unbiased=FALSE),
  psmall=FALSE, exhaustive=mX_eco_pop)
synt <- res$estimation
```

```{r TableSyntheticEstimates, echo=FALSE}
df <- synt[c("area","estimate","g_variance","n2G")]
df[,c(2,3)] <- round(df[,c(2,3)],1)

knitr::kable(
  df, caption = 'Synthetic estimates of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia, using lnSWIR2 as a predictor. In the final column the number of sampling units per ecoregion is listed.',
  booktabs = TRUE, col.names=c("Ecoregion","AGB","g_var","n2G")
) %>%
  kable_classic()
```


```{r, echo=FALSE}
names(synt)[1] <- "Ecoregion"
df <- merge(synt, regr, by="Ecoregion")
d_estimates <- df$estimate.x-df$estimate.y
md <- mean(d_estimates)
d_vars <- df$g_variance.x-df$g_variance.y
```

For all ecoregions, also the unsampled ones, a synthetic estimate of the mean AGB is obtained (Table \@ref(tab:TableSyntheticEstimates)). For the sampled ecoregions the synthetic estimate differs from the regression estimate. This difference can be quite large for ecoregions with a small sample size. Averaged over all sampled ecoregions the difference, computed as synthetic estimate minus regression estimate,  equals `r round(md,1)`. The variance of the regression estimator is always much larger than the variance of the synthetic estimator. The difference is the variance of the estimated domain mean of the residuals. However, recall that the regression estimator is design-unbiased, whereas the synthetic estimator is not. A more fair comparison is on the basis of the root mean squared error (Table \@ref(tab:tableRMSEs)).

```{r, echo=FALSE}
load(file="results/MeanAGB_ecoregions.RData")
v_mz_eco_regr <- apply(mz_eco_regr, MARGIN=1, FUN=var, na.rm=TRUE)
v_mz_eco_synt <- apply(mz_eco_synt, MARGIN=1, FUN=var, na.rm=TRUE)
m_mz_eco_synt <- apply(mz_eco_synt, MARGIN=1, FUN=mean, na.rm=TRUE)
bias_synt <- m_mz_eco_synt-mz_pop
RMSE_synt <- sqrt(v_mz_eco_synt+bias_synt^2)
RMSE_regr <- sqrt(v_mz_eco_regr)
dRMSE <- RMSE_regr-RMSE_synt
```

```{r tableRMSEs, echo=FALSE}
ecoregions_short <- ecoregions
ecoregions_short[c(1,16)] <- c("Amazon-Orinoco Carib. mangroves","Xingu-Toc.-Arag. moist forests")
df <- data.frame(Ecoregion=ecoregions_short, se.reg=round(sqrt(v_mz_eco_regr),1), se.syn=round(sqrt(v_mz_eco_synt),1), bias.syn=round(bias_synt,1), RMSE.syn=round(RMSE_synt,1))
rownames(df) <- NULL
knitr::kable(
  df, caption = 'Standard error (se), bias, and root mean squared error (RMSE) of the regression estimator (reg) and synthetic estimator (syn). The regression estimator is design-unbiased, so the RMSE of the regression estimator is equal to its standard error.',
  booktabs = TRUE
) %>%
  kable_classic()
```


In the synthetic estimator and the regression estimator both quantitative covariates and categorical variables can be used. If one or more categorical variables are included in the estimator, the variable names in the data frame with the true means of the ancillary variables per domain, assigned to argument `exhaustive`,  must correspond with the column names of the design matrix that is generated with function `lm`, see Section \@ref(RegressionEstimatorSTSI).

## Model-based prediction {#SmallAreaModelBased}

The alternative for design-based and model-assisted estimation of the means or totals of small domains is model-based prediction. The model describes the spatial variation of the study variable. An example of such a model is a linear regression model. Such model is used in the model-assisted estimator of the previous sections. A more advanced model is a linear mixed model\index{Linear mixed model}. In a linear mixed model the mean of the study variable is modelled as a linear combination of covariates, similar to a linear regression model. The difference with a linear regression model is that also the variance of the residuals is modelled. 

### Random intercept model

A basic linear mixed model for model-based prediction of means of small domains is the random intercept model\index{Random intercept model}:

\begin{eqnarray}
Z_{dk} &=& \mathbf{x}_{dk}^{\text{T}} \bm{\beta} + v_d + \epsilon_{dk} \notag \\
v_d &\sim& \mathcal{N}(0,\sigma^2_v) \\
\epsilon_{dk} &\sim& \mathcal{N}(0,\sigma^2_{\epsilon}) \notag \;.
(\#eq:RandomInterceptModel)
\end{eqnarray}

Two random variables are now involved, both with a normal distribution with mean zero: $v_d$ a random intercept at the domain level with variance $\sigma^2_v$, and the residuals $\epsilon_{dk}$ at the unit level with variance $\sigma^2_{\epsilon}$. The variance $\sigma^2_v$ can be interpreted as a measure of the heterogeneity among the domains after accounting for the fixed effect [@Breidenbach2012]. With this model the mean of a domain can be predicted by

\begin{equation}
\hat{\bar{z}}_{d,\text{mb}} = \bar{\mathbf{x}}_d^{\mathrm{T}} \hat{\mathbf{b}} + \hat{v}_d \;,
(\#eq:mbpredictordomainmeanrandomintercept)
\end{equation}

with $\hat{\bm{\beta}}$ the best linear unbiased estimates (BLUE) of the regression coefficients, and $\hat{v}_d$ the best linear unbiased prediction (BLUP) of the intercept for domain $d$, $v_d$. The model-based predictor can also be written as

\begin{equation}
\hat{\bar{z}}_{d,\text{mb}} = \bar{\mathbf{x}}_d^{\mathrm{T}} \hat{\mathbf{b}} + \lambda_d \left( \frac{1}{n_d }\sum_{k \in \mathcal{S}_d} \epsilon_{dk} \right) \;,
(\#eq:mbpredictordomainmeanrandomintercept2)
\end{equation}

with $\lambda_d$ a weight for the second term that corrects for the bias of the synthetic estimator. This weight is computed by 

\begin{equation}
\lambda_d = \frac{\hat{\sigma}^2_v}{\hat{\sigma}^2_v + \hat{\sigma}^2_{\epsilon}/n_d}\;.
(\#eq:weightrandomintercept)
\end{equation}

This equation shows that the larger the estimated residual variance $\hat{\sigma}^2_{\epsilon}$, the smaller the weight for the bias correction factor, and the larger the sample size $n_d$, the larger the weight. Comparing Equations \@ref(eq:mbpredictordomainmeanrandomintercept) and \@ref(eq:mbpredictordomainmeanrandomintercept) shows that the random intercept of a domain is predicted by the sample mean of the residuals of that domain, multiplied by a weight factor computed by Equation \@ref(eq:weightrandomintercept).  

The means of the small domains can be computed with function `eblup.mse.f.wrap` of package **JoSAE** [@JoSAE]. It requires as input a linear mixed model generated with function `lme` of package **nlme** [@nlme]. The simple random sample of size 200 is used to fit the linear mixed model, with lnSWIR2 as a fixed effect, i.e. the effect of SWIR2 on the mean of AGB. The random effect is added by assigning another formula to the argument `random`. The formula, `~1|Ecoregions` means that the intercept is treated as a random variable, and that it varies among the Ecoregions. This linear mixed model is referred to as a random intercept model: the intercepts are allowed to differ among the small domains, whereas the effects of the covariates, lnSWIR2 in our case, is equal for all domains.

```{r, echo=FALSE}
load("data/Amazonia_1km.RData")
set.seed(314)
gridAmazonia$x1 <- gridAmazonia$x1/1000
gridAmazonia$x2 <- gridAmazonia$x2/1000
units <- sample.int(nrow(gridAmazonia), size=n, replace=FALSE)
mysample <- gridAmazonia[units,c("x1","x2","AGB","lnSWIR2","Ecoregion")]
```

```{r}
library(nlme)
library(JoSAE)
lmm_AGB <- lme(fixed=AGB~lnSWIR2, data=mysample, random=~1|Ecoregion)
```

The fixed effects\index{Fixed effect} can be extracted with function `fixed.effects`.

```{r}
fixed_lmm <- fixed.effects(lmm_AGB)
```

The fixed effects differ somewhat from the fixed effects in the simple linear regression model:
 
```{r, echo=FALSE}
slm <- lm(AGB~lnSWIR2, data=mysample)
ab.lm <- coef(slm)
(df <- data.frame(fixed.lm=ab.lm, fixed.lmm=fixed_lmm))
```

The random effect\index{Random effect} can be extracted with function `random.effect`. 

```{r}
random.effects(lmm_AGB)
```

The random intercepts are added to the fixed intercept; the coefficient of lnSWIR2 is the same for all ecoregions: 

```{r}
coef(lmm_AGB)
```

The fitted model can now be used to predict the means of the ecoregions as follows. As a first step a data frame must be defined with the sizes of the domains and the population means of the covariate lnSWIR2 per domain. This data frame is assigned to argument `domain.data` of function `eblup.mse.f.wrap`. This function computes the model-based prediction as well as the regression estimator (Equation \@ref(eq:regressionestimatorsmalldomain)) and the synthetic estimator (Equation \@ref(eq:syntheticestimatorsmalldomain)) and their variances. The model-based predictor is the variable `EBLUP` in the output data frame. For the model-based predictor two standard errors are computed, see @Breidenbach2012 for details.

```{r}
N_eco <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Ecoregion, FUN=length)
df_eco <- data.frame(Ecoregion=ecoregions, N=N_eco, lnSWIR2=mx_eco_pop)
res <- eblup.mse.f.wrap(domain.data=df_eco, lme.obj=lmm_AGB)
df <- data.frame(Ecoregion=res$domain.ID, mb=res$EBLUP,
  se.1=res$EBLUP.se.1, se.2=res$EBLUP.se.2)
```

```{r TableRandomInterceptModelEstimates, echo=FALSE}
df[,c(2,3,4)] <- round(df[,c(2,3,4)],1)

knitr::kable(
  df, caption = 'Model-based predictions of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia, obtained with random intercept model and lnSWIR2 as a predictor.',
  booktabs = TRUE,col.names=c("Ecoregion","AGB","se.1","se.2")
) %>%
  kable_classic()
```

Note that with this model no predictions are obtained for the unsampled ecoregions. For the unsampled ecoregions no prediction is obtained of the random intercept $v_d$, see Equation \@ref(eq:mbpredictordomainmeanrandomintercept2).

### Geostatistical model 

In the random intercept model (Equation \@ref(eq:RandomInterceptModel)) it is assumed that the residuals $\epsilon_{ij}$ are independent. In a geostatistical model\index{Geostatistical model} this assumption is relaxed, and the spatial correlation of the residuals is modelled. For details about geostatistical modelling, I refer to Chapter \@ref(Introkriging).

A simple random sample of size 200 is used to compute the sample semivariogram\index{Sample semivariogram} of the residuals of the simple linear regression model, using lnSWIR2 as a single predictor. Figure \@ref(fig:ResidualVariogramAGB) shows that the larger the distance, the larger half the expected squared difference. This shows that the residuals of units with a separation distance smaller than about 300 km are correlated. A spherical model with nugget is fitted to model the spatial correlation of the residuals $e$.

The residual semivariogram\index{Residual semivariogram} is computed with function `variogram` of package **gstat** [@peb04]. A spherical model is fitted with function `fit.variogram`. The coordinates are shifted to a random point within a 5 km $\times$ 5 km grid cell. This is only done to avoid an error message when the geostatistical model is used to predict AGB at the nodes of the grid hereafter. 

```{r ResidualVariogramAGB, echo=FALSE, fig.asp=0.7, fig.cap="Semivariogram of residuals of simple linear regression model for AGB, using lnSWIR2 as a predictor."}
library(gstat)
mysample$x1 <- jitter(mysample$x1, amount=2.5)
mysample$x2 <- jitter(mysample$x2, amount=2.5)
coordinates(mysample) <- ~x1+x2
vg_resi <- variogram(AGB~lnSWIR2, data=mysample)
vgm_resi <- fit.variogram(vg_resi, model=vgm(psill=1000,  model="Sph", range=300, nugget=1500))
plot(vg_resi,vgm_resi, plot.numbers=TRUE)
```

The semivariogram parameters and the regression coefficients can best be estimated by restricted maximum likelihood (REML), see Section \@ref(REML). This estimation procedure is also used in function `lme` to fit the random intercept model. Here I use function `likfit` of package **geoR** [@geoR]. First a geoR object must be generated with function `as.geodata`.

```{r}
library(geoR)
mysample <- as(mysample,"data.frame")
dGeoR <- as.geodata(mysample, header=TRUE,
  coords.col=1:2, data.col=3, covar.col=4)
```

The model parameters can then be estimated with function `likfit`.

```{r}
vgm_REML <- likfit(geodata=dGeoR, trend=~lnSWIR2, cov.model="spherical",
  ini.cov.pars=c(1000,300), nugget=1500, lik.method="REML", messages=FALSE)
```

The estimated semivariogram parameters are `r round(vgm_REML$nugget,0)` for the nugget (intercept of the semivariogram), `r round(vgm_REML$sigmasq,0)` for the partial sill (maximum semivariance minus the nugget), and `r round(vgm_REML$phi,1)` for the range (distance at which the semivariance reaches its maximum). The estimated regression coefficients and parameters of the semivariogram can then be used to predict AGB for all units in the population.

```{r, eval=FALSE}
coordinates(mysample) <- ~x1+x2
vgm_REML_gstat <- vgm(nugget=vgm_REML$nugget, psill=vgm_REML$sigmasq,
  range=vgm_REML$phi, model="Sph")
coordinates(mysample) <- ~x1+x2
coordinates(gridAmazonia) <- ~x1+x2
predictions  <- krige(
  formula=AGB~lnSWIR2,
  locations=mysample, 
  newdata=gridAmazonia, 
  model=vgm_REML_gstat,
  debug.level=0) %>% as(.,"data.frame")
```

```{r, eval=FALSE, echo=FALSE}
save(predictions,file="results/ModelBasedPredictionsAGB_Amazonia.RData")
```

The first six rows of `predictions` are shown below.

```{r, echo=FALSE}
load(file="results/ModelBasedPredictionsAGB_Amazonia.RData")
head(predictions)
```

Besides a prediction (column `var1.pred`), for every population unit the variance of the prediction error is computed (`var1.var`). The unit-wise predictions can be averaged across all units of an ecoregion to obtain a model-based prediction of the mean of that ecoregion.

```{r}
AGBpred_unit <- predictions$var1.pred
gridAmazonia <- as(gridAmazonia,"data.frame")
mz_eco_mb <- tapply(AGBpred_unit, INDEX=gridAmazonia$Ecoregion,
                    FUN=mean) %>% round(.,1)
```

A difficulty is the computation of the standard error of these model-based predictions of the ecoregion mean. We cannot simply sum the unit-wise variances and divide the sum by the squared number of units because the prediction errors of units with a mutual distance smaller than about 450 km (the estimated range of the semivariogram) are correlated. A straightforward approach to obtain the standard error of the predicted mean is geostatistical simulation\index{Geostatistical simulation}. A large number of maps is simulated, conditional on the selected sample. For an infinite number of maps, the "average map", i.e. the map obtained by averaging for each unit all simulated values of that unit, is equal to the map with predicted AGB. For each simulated map, the average of the simulated values across all units of an ecoregion is computed. This results in as many averages as we have simulated maps. The variance of the averages of an ecoregion is an estimate of the variance of the predicted mean of that ecoregion. To reduce computing time the 5 km $\times$ 5 km subgrid is used in geostatistical simulation  

```{r, eval=FALSE}
load(file="data/Amazonia_5km.RData")
nsim <- 1000
coordinates(gridAmazonia) <- ~x1+x2
simulations  <- krige(
  formula=AGB~lnSWIR2,
  locations=mysample,
  newdata=gridAmazonia, 
  model=vgm_REML_gstat,
  nmax=100, nsim=nsim,
  debug.level=0) %>% as(.,"data.frame")
gridAmazonia <- as(gridAmazonia,"data.frame")
AGBsim_eco <- matrix(nrow=length(ecoregions), ncol=nsim)
for (i in 1:nsim) {
  AGBsim_eco[,i] <- tapply(simulations[,i+2],
  INDEX=gridAmazonia$Ecoregion, FUN=mean)
}
```

```{r, eval=FALSE, echo=FALSE}
save(AGBsim_eco,file="results/AGBsimulated_ecoregions.RData")
```

```{r, echo=FALSE}
load(file="results/AGBsimulated_ecoregions.RData")
se_mz_eco_mb <- round(sqrt(apply(AGBsim_eco,MARGIN=1,FUN=var)),1)
```

```{r TableGeostatisticqalModelEstimates, echo=FALSE}
df <- data.frame(Ecoregion=ecoregions, mz_eco_mb, se_mz_eco_mb)
df[,c(2,3)] <- round(df[,c(2,3)],1)
rownames(df) <- NULL
knitr::kable(
  df, caption = 'Model-based predictions of mean aboveground biomass (AGB) of ecoregions in Eastern Amazonia, obtained with geostatistical model and lnSWIR2 as a predictor for the mean. se: standard error of predicted mean.',
  booktabs = TRUE, col.names=c("Ecoregion","AGB","se")
) %>%
  kable_classic()
```

Similar to the synthetic estimator, for all ecoregions an estimate of the mean AGB is obtained, also for the unsampled ecoregions (Table \@ref(tab:TableGeostatisticqalModelEstimates)). The model-based prediction is strongly correlated with the synthetic estimate (Figure \@ref(fig:MBvsSynt)).

```{r MBvsSynt, echo=FALSE, fig.cap="Scatterplot of model-based prediction and synthetic estimate of the mean AGB of ecoregions in Eastern Amazonia. The solid line is the 1:1 line."}
df <- data.frame(ecoregions, mb=mz_eco_mb, se.mb=se_mz_eco_mb, synt=synt$estimate, se.synt=sqrt(synt$g_variance)) 
ggplot(data=df) +
        geom_point(mapping=aes(x=synt, y=mb), size=2) +
        geom_abline(intercept=0, slope=1)+
        scale_x_continuous(name="Synthetic estimate", limits=c(50,300)) +
        scale_y_continuous(name="Model-based prediction", limits=c(50,300))+
        coord_fixed()
```

The most striking difference is the standard error. The standard errors of the synthetic estimator range from 3.2 to 4.3, whereas the standard errors of the geostatistical predictions range from 6.2 to 28.1. However, these two standard errors are fundamentally different, and should not be compared. The standard error of the synthetic estimator is a *sampling* standard error, i.e. it quantifies the variation of the estimated mean of an ecoregion over repeated random sampling with the sampling design, in this case simple random sampling of 200 units. The model-based standard error is not a sampling standard error but a model standard error, which expresses our uncertainty about the means of the domains due to our imperfect knowledge of the spatial variation of AGB. Given the observations of AGB at the selected sample, the map with the covariate lnSWIR2, and the estimated semivariogram model parameters, we are uncertain about the exact value of AGB at unsampled units. No other samples are considered than the one actually selected. For the fundamental difference between the design-based, model-assisted, and model-based estimates of means, I refer to Section \@ref(DBvsMB) and Chapter \@ref(Approaches).

It makes more sense to compare the two model-based predictions, the random intercept model predictions and the geostatistical predictions, and their standard errors. Figure \@ref(fig:MBvsMB) shows that the two model-based predictions are very similar. 

```{r MBvsMB, echo=FALSE, fig.cap="Scatterplot of model-based predictions of the mean AGB of ecoregions in Eastern Amazonia, obtained with the random intercept model and the geostatistical model. The solid lines is the 1:1 line."}
res <- eblup.mse.f.wrap(domain.data=df_eco, lme.obj=lmm_AGB)
TF <- (ecoregions %in% ecos_in_sam)
n_eco <- tapply(mysample$AGB, INDEX=mysample$Ecoregion, FUN=length)
df <- data.frame(n_eco, mb.geo=mz_eco_mb[TF], semb.geo=se_mz_eco_mb[TF], mb.rint=res$EBLUP, semb.rint=res$EBLUP.se.1)
ggplot(data=df) +
        geom_point(mapping=aes(x=mb.rint, y=mb.geo), size=2) +
        geom_abline(intercept=0, slope=1)+
        scale_x_continuous(name="Random intercept model prediction ", limits=c(50,300)) +
        scale_y_continuous(name="Geostatistical prediction", limits=c(50,300))+
        coord_fixed()
```

For four ecoregions the standard errors of the geostatistical model predictions are much smaller than those of the random intercept model predictions (Figure \@ref(fig:MBvsMBse)). These are ecoregions with small sample sizes.

```{r MBvsMBse, echo=FALSE,  fig.cap="Scatterplot of standard error of model-based predictions of the mean AGB of ecoregions in Eastern Amazonia, obtained with the random intercept model and the geostatistical model. The numbers refer to the number of sampling units in an ecoregion. The solid line is the 1:1 line."}
ggplot(data=df) +
        geom_point(mapping=aes(x=semb.rint, y=semb.geo), size=2) +
        geom_text(mapping=aes(x=semb.rint, y=semb.geo, label=n_eco), hjust=1, vjust=1)+
        geom_abline(intercept=0, slope=1)+
        scale_x_continuous(name="Standard error random intercept model prediction ", limits=c(5,40)) +
        scale_y_continuous(name="Standard error geostatistical prediction", limits=c(5,40))+
        coord_fixed()

```

Note that if a different semivariogram model were used, both the predicted means per ecoregion and the standard errors would be different. Especially the variance is sensitive to the semivariogram. For that reason the model-based predictions are also referred to as model-dependent predictions\index{Model-dependent predictor}.

## Supplemental probability sampling of small domains

The sample size in small domains of interest can be so small that no reliable statistical estimate of the mean or total of these domains can be obtained. In that case we may decide to collect a supplemental sample\index{Supplemental sample} from these domains. It is convenient to use these domains as strata in supplemental probability sampling, so that we can control the sample sizes in the strata. If we can safely assume that the study variable at the units of the first sample are not changed, there is no need to revisit these units, otherwise we must revisit them to observe the current values.

There are two approaches for using the two samples to estimate the population mean or total of a small domain [@Grafstrom2019]. In the first approach the two samples are combined, and then the merged sample is used to estimate the population mean or total. In the second approach not the samples are combined, but the two estimates from the separate samples. In this section only the first approach is illustrated with a simple situation in which the two samples are easily combined. I refer to @Grafstrom2019 for a more general approach of how multiple probability samples can be combined.

Suppose that the original sample is a simple random sample from the entire study area. A supplemental sample is selected from small domains, i.e. domains that have few selected units only. For a given small domain, the first sample is supplemented by selecting a simple random sample from the units not yet selected in the first sample. The size of the supplemental sample of a domain depends on the number of units of that domain in the first sample. The first sample is supplemented so that the total sample size of that domain is fixed. In this case the combined sample of a domain is a simple random sample from that domain, so that the usual estimators for simple random sampling can be used to estimate the domain mean or total, and its standard error.

This sampling strategy is illustrated with Eastern Amazonia. A simple random sample without replacement of 400 units is selected.

```{r}
load("data/Amazonia_1km.RData")
gridAmazonia$Biome <- as.factor(gridAmazonia$Biome)
biomes <- c("Mangrove","Forest.dry","Grassland","Forest.moist")
levels(gridAmazonia$Biome) <- biomes
n1 <- 400
set.seed(123)
units_1 <- sample.int(nrow(gridAmazonia), size=n1, replace=FALSE)
mysample_1 <- gridAmazonia[units_1, c("AGB","Biome")]
print(n1_biome <- table(mysample_1$Biome))
```

The selected units are removed from the sampling frame. For each of the three small biomes, Mangrove, Forest.dry and Grassland, the size of the supplemental sample is computed so that the total sample size becomes 40. The supplemental sample is selected by stratified simple random sampling without replacement, using the small biomes as strata.

```{r}
units_notselected <- gridAmazonia[-units_1,]
Biomes_NFM <- units_notselected[units_notselected$Biome!="Forest.moist",]
n_biome <- 40
n2_biome <- rep(n_biome,3) - n1_biome[-4]
ord <- unique(Biomes_NFM$Biome)
units_2 <- sampling::strata(Biomes_NFM, stratanames="Biome",
  size=n2_biome[ord], method="srswor")
mysample_2 <- getdata(Biomes_NFM, units_2)
mysample_2 <- mysample_2[c("AGB","Biome")]
```

The two samples are merged, and the means of the domains are estimated by the sample means.

```{r}
mysample <- rbind(mysample_1, mysample_2)
print(mz_biome <- tapply(mysample$AGB, INDEX=mysample$Biome, FUN=mean))
```

Finally, the standard error is estimated, accounting for sampling without replacement from a finite population (Equation \@ref(eq:EstVarMeanSI)).

```{r}
N_biome <- table(gridAmazonia$Biome)
fpc <- (1-n_biome/N_biome)
S2z_biome <- tapply(mysample$AGB, INDEX=mysample$Biome, FUN=var)
print(se_mz_biome <- sqrt(fpc*(S2z_biome/n_biome)))
```


```{r, echo=FALSE, eval=FALSE}
mz_biome <- v_mz_biome <- matrix(nrow=10000,ncol=4)
set.seed(314)
for (i in 1:10000) {
  units_1 <- sample.int(nrow(gridAmazonia), size=n1, replace=FALSE)
  mysample_1 <- gridAmazonia[units_1,c("AGB","Biome")]
  n1_biome <- table(mysample_1$Biome)

  units_notselected <- gridAmazonia[-units_1,]
  Biomes.NFM <- units_notselected[units_notselected$Biome!="Forest.moist",]
  n_biome <- 40
  n2_biome <- rep(n_biome,3) - n1_biome[-4]
  if (sum(n2_biome<1)>0) {next} else {
  ord <- unique(Biomes.NFM$Biome)
  units_2 <- sampling::strata(Biomes.NFM, stratanames="Biome", size=n2_biome[ord], method="srswor")
  mysample_2 <- getdata(Biomes.NFM, units_2)
  mysample_2 <- mysample_2[c("AGB","Biome")]

  mysample <- rbin_biome(mysample_1,mysample_2)
  mz_biome[i,] <- tapply(mysample$AGB, INDEX=mysample$Biome, FUN=mean)

  N_biome <- table(gridAmazonia$Biome)
  fpc <- (1-n_biome/N_biome)
  S2z_biome <- tapply(mysample$AGB, INDEX=mysample$Biome, FUN=var)
  v_mz_biome[i,] <- fpc*(S2z_biome/n_biome)
  }
}
save(mz_biome,v_mz_biome,file="results/SupplementalSampleEstimates_Amazonia.RData")
```

```{r, echo=FALSE}
load(file="results/SupplementalSampleEstimates_Amazonia.RData")
nas <- apply(mz_biome,MARGIN=2, FUN=mean, na.rm=TRUE)

Ep_mz_biome <- apply(mz_biome,MARGIN=2, FUN=mean,na.rm=TRUE)
Vp_mz_biome <- apply(mz_biome,MARGIN=2, FUN=var, na.rm=TRUE)
se_mz_biome <- sqrt(v_mz_biome)
Ep_se_mz_biome <- apply(se_mz_biome, MARGIN=2, FUN=mean, na.rm=TRUE)
mz_biome_pop <- tapply(gridAmazonia$AGB, INDEX=gridAmazonia$Biome, FUN=mean)

alpha <- 0.05
margin <- qt(1-alpha/2,39,lower.tail=TRUE)*sqrt(v_mz_biome[,1:3])
lower <- mz_biome[,1:3]-margin
upper <- mz_biome[,1:3]+margin
Mz_biome_pop <- matrix(nrow=10000, ncol=3, data=mz_biome_pop[1:3], byrow=TRUE)
ind <- (Mz_biome_pop>lower &  Mz_biome_pop<upper)
coverage <- apply(ind, MARGIN=2, FUN=sum, na.rm=TRUE)
dum <- apply(ind, MARGIN=2, FUN=function(x) {sum(!is.na(x))})
coveragerate_95 <- coverage/dum

alpha <- 0.10
margin <- qt(1-alpha/2,39, lower.tail=TRUE)*sqrt(v_mz_biome[,1:3])
lower <- mz_biome[,1:3]-margin
upper <- mz_biome[,1:3]+margin
ind <- (Mz_biome_pop>lower &  Mz_biome_pop<upper)
coverage <- apply(ind,MARGIN=2,FUN=sum,na.rm=TRUE)
dum <- apply(ind, MARGIN=2,FUN=function(x) {sum(!is.na(x))})
coveragerate_90 <- coverage/dum

alpha <- 0.20
margin <- qt(1-alpha/2,39, lower.tail=TRUE)*sqrt(v_mz_biome[,1:3])
lower <- mz_biome[,1:3]-margin
upper <- mz_biome[,1:3]+margin
ind <- (Mz_biome_pop>lower &  Mz_biome_pop<upper)
coverage <- apply(ind, MARGIN=2, FUN=sum, na.rm=TRUE)
dum <- apply(ind, MARGIN=2,FUN=function(x) {sum(!is.na(x))})
coveragerate_80 <- coverage/dum

row_names <- c("Average of estimated means","True means","Standard deviation of estimated means","Average of estimated standard errors","Coverage rate 95%","Coverage rate 90%","Coverage rate 80%")
dom <- matrix(nrow=7,ncol=3, dimnames=list(row_names,NULL))
for (i in 1:3) {
  dom[,i] <- c(round(Ep_mz_biome[i],3), round(mz_biome_pop[i],3), round(sqrt(Vp_mz_biome[i]),3), round(Ep_se_mz_biome[i],3), round(coveragerate_95[i],3), round(coveragerate_90[i],3), round(coveragerate_80[i],3))
}
```

This sampling approach and estimation is repeated 10,000 times, i.e. 10,000 times a simple random sample of size 400 is selected from Eastern Amazonia, and the samples from the three small domains are supplemented so that the total sample sizes in these domains become 40. In two out of the 10,000 samples the size of the first sample in one of the domains exceeded 40 units. These two samples are discarded. Ideally, these samples are not discarded, but their sizes in the small domains are reduced to 40 units, which are then used to estimate the means of the domains.

```{r SmalldomainEstimates, echo=FALSE}
knitr::kable(
  dom, caption = 'Summary statistics of 10,000 estimated means of small domains (biomes) in Eastern Amazonia, estimated by combining a simple random sample of size 400 from Eastern Amazonia, and a supplemental sample from the domains. The total sample size per small domain is 40.',
  col.names = c("Mangrove","Dry forest","Grassland"),
  row.names = TRUE,
  booktabs = TRUE
) %>%
  kable_classic()
```

For all three small domains the average of the 10,000 estimated means is about equal to the true mean (Table \@ref(tab:SmalldomainEstimates)). Also the mean of the 10,000 estimated standard errors is very close to the standard deviation of the 10,000 estimated means. The coverage rates of 95%, 90% and 80% confidence intervals are about equal to the nominal coverage rates.

This simple approach is feasible because at the domain level the two merged samples are a simple random sample. This  approach is also applicable when at the first sample is a stratified simple random sample from the entire population and the supplemental sample is a stratified simple random sample from a small domain, using as strata the intersections of the strata used in the first phase and that domain.

```{r, echo=FALSE}
rm(list=ls())
```
