<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 6 Cluster random sampling | Spatial sampling with R</title>
  <meta name="description" content="This book is for students, researchers and consultants who would like to know how to collect spatial data, either for estimating parameters for the population or several subpopulations, or for mapping. How many data do we need, and how to select the population units? The book presents a wide overview of spatial sampling designs. Besides there is a chapter on designs for sampling in space and time for monitoring. The emphasis is not on the theory, but on how to implement sampling designs in R and on how the (sub)population parameters can be estimated from the sample." />
  <meta name="generator" content="bookdown 0.24 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 6 Cluster random sampling | Spatial sampling with R" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="/images/cover.pdf" />
  <meta property="og:description" content="This book is for students, researchers and consultants who would like to know how to collect spatial data, either for estimating parameters for the population or several subpopulations, or for mapping. How many data do we need, and how to select the population units? The book presents a wide overview of spatial sampling designs. Besides there is a chapter on designs for sampling in space and time for monitoring. The emphasis is not on the theory, but on how to implement sampling designs in R and on how the (sub)population parameters can be estimated from the sample." />
  <meta name="github-repo" content="DickBrus/SpatialSamplingwithR" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 6 Cluster random sampling | Spatial sampling with R" />
  
  <meta name="twitter:description" content="This book is for students, researchers and consultants who would like to know how to collect spatial data, either for estimating parameters for the population or several subpopulations, or for mapping. How many data do we need, and how to select the population units? The book presents a wide overview of spatial sampling designs. Besides there is a chapter on designs for sampling in space and time for monitoring. The emphasis is not on the theory, but on how to implement sampling designs in R and on how the (sub)population parameters can be estimated from the sample." />
  <meta name="twitter:image" content="/images/cover.pdf" />

<meta name="author" content="Dick J. Brus" />


<meta name="date" content="2021-12-09" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="SY.html"/>
<link rel="next" href="Twostage.html"/>
<script src="libs/header-attrs-2.11/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>
<script src="libs/kePrint-0.0.1/kePrint.js"></script>
<link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Spatial sampling with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#acknowledgements"><i class="fa fa-check"></i>Acknowledgements</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="GeneralIntro.html"><a href="GeneralIntro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a>
<ul>
<li class="chapter" data-level="1.1" data-path="GeneralIntro.html"><a href="GeneralIntro.html#BasicConcepts"><i class="fa fa-check"></i><b>1.1</b> Basic sampling concepts</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="GeneralIntro.html"><a href="GeneralIntro.html#PopulationParameters"><i class="fa fa-check"></i><b>1.1.1</b> Population parameters</a></li>
<li class="chapter" data-level="1.1.2" data-path="GeneralIntro.html"><a href="GeneralIntro.html#descriptive-statistics-versus-inference-about-a-population"><i class="fa fa-check"></i><b>1.1.2</b> Descriptive statistics versus inference about a population</a></li>
<li class="chapter" data-level="1.1.3" data-path="GeneralIntro.html"><a href="GeneralIntro.html#random-sampling-versus-probability-sampling"><i class="fa fa-check"></i><b>1.1.3</b> Random sampling versus probability sampling</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="GeneralIntro.html"><a href="GeneralIntro.html#DBvsMB"><i class="fa fa-check"></i><b>1.2</b> Design-based versus model-based approach</a></li>
<li class="chapter" data-level="1.3" data-path="GeneralIntro.html"><a href="GeneralIntro.html#Datasets"><i class="fa fa-check"></i><b>1.3</b> Populations used in sampling experiments</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="GeneralIntro.html"><a href="GeneralIntro.html#Voorst"><i class="fa fa-check"></i><b>1.3.1</b> Soil organic matter in Voorst (Netherlands)</a></li>
<li class="chapter" data-level="1.3.2" data-path="GeneralIntro.html"><a href="GeneralIntro.html#Poppy"><i class="fa fa-check"></i><b>1.3.2</b> Poppy fields in Kandahar (Afghanistan)</a></li>
<li class="chapter" data-level="1.3.3" data-path="GeneralIntro.html"><a href="GeneralIntro.html#Amazonia"><i class="fa fa-check"></i><b>1.3.3</b> Aboveground biomass in Eastern Amazonia (Brazil)</a></li>
<li class="chapter" data-level="1.3.4" data-path="GeneralIntro.html"><a href="GeneralIntro.html#TASSpainPortugal"><i class="fa fa-check"></i><b>1.3.4</b> Annual mean air temperature in Spain and Portugal</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>I Probability sampling for estimating (sub)population parameters</b></span></li>
<li class="chapter" data-level="2" data-path="IntroProbabilitySampling.html"><a href="IntroProbabilitySampling.html"><i class="fa fa-check"></i><b>2</b> Introduction to probability sampling</a>
<ul>
<li class="chapter" data-level="2.1" data-path="IntroProbabilitySampling.html"><a href="IntroProbabilitySampling.html#HTestimator"><i class="fa fa-check"></i><b>2.1</b> Horvitz-Thompson estimator</a></li>
<li class="chapter" data-level="2.2" data-path="IntroProbabilitySampling.html"><a href="IntroProbabilitySampling.html#hansen-hurwitz-estimator"><i class="fa fa-check"></i><b>2.2</b> Hansen-Hurwitz estimator</a></li>
<li class="chapter" data-level="2.3" data-path="IntroProbabilitySampling.html"><a href="IntroProbabilitySampling.html#using-models-in-design-based-approach"><i class="fa fa-check"></i><b>2.3</b> Using models in design-based approach</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="SI.html"><a href="SI.html"><i class="fa fa-check"></i><b>3</b> Simple random sampling</a>
<ul>
<li class="chapter" data-level="3.1" data-path="SI.html"><a href="SI.html#HTestimatorSI"><i class="fa fa-check"></i><b>3.1</b> Estimation of population parameters</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="SI.html"><a href="SI.html#PopProportion"><i class="fa fa-check"></i><b>3.1.1</b> Population proportion</a></li>
<li class="chapter" data-level="3.1.2" data-path="SI.html"><a href="SI.html#CDF"><i class="fa fa-check"></i><b>3.1.2</b> Cumulative distribution function and quantiles</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="SI.html"><a href="SI.html#VarMeanSI"><i class="fa fa-check"></i><b>3.2</b> Sampling variance of estimator of population parameters</a></li>
<li class="chapter" data-level="3.3" data-path="SI.html"><a href="SI.html#ConfidenceInterval"><i class="fa fa-check"></i><b>3.3</b> Confidence interval estimate</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="SI.html"><a href="SI.html#ConfidenceIntervalProportion"><i class="fa fa-check"></i><b>3.3.1</b> Confidence interval for proportion</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="SI.html"><a href="SI.html#SIcircularplots"><i class="fa fa-check"></i><b>3.4</b> Simple random sampling of circular plots</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="SI.html"><a href="SI.html#sampling-from-a-finite-set-of-fixed-circles"><i class="fa fa-check"></i><b>3.4.1</b> Sampling from a finite set of fixed circles</a></li>
<li class="chapter" data-level="3.4.2" data-path="SI.html"><a href="SI.html#sampling-from-an-infinite-set-of-floating-circles"><i class="fa fa-check"></i><b>3.4.2</b> Sampling from an infinite set of floating circles</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="STSI.html"><a href="STSI.html"><i class="fa fa-check"></i><b>4</b> Stratified simple random sampling</a>
<ul>
<li class="chapter" data-level="4.1" data-path="STSI.html"><a href="STSI.html#EstimatorsSTSI"><i class="fa fa-check"></i><b>4.1</b> Estimation of population parameters</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="STSI.html"><a href="STSI.html#population-proportion-cumulative-distribution-function-and-quantiles"><i class="fa fa-check"></i><b>4.1.1</b> Population proportion, cumulative distribution function, and quantiles</a></li>
<li class="chapter" data-level="4.1.2" data-path="STSI.html"><a href="STSI.html#WhyStratify"><i class="fa fa-check"></i><b>4.1.2</b> Why should we stratify?</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="STSI.html"><a href="STSI.html#CISTSI"><i class="fa fa-check"></i><b>4.2</b> Confidence interval estimate</a></li>
<li class="chapter" data-level="4.3" data-path="STSI.html"><a href="STSI.html#STSIallocation"><i class="fa fa-check"></i><b>4.3</b> Allocation of sample size to strata</a></li>
<li class="chapter" data-level="4.4" data-path="STSI.html"><a href="STSI.html#cumrootf"><i class="fa fa-check"></i><b>4.4</b> <em>Cum-root-f</em> stratification</a></li>
<li class="chapter" data-level="4.5" data-path="STSI.html"><a href="STSI.html#kmeansstratification"><i class="fa fa-check"></i><b>4.5</b> Stratification with multiple covariates</a></li>
<li class="chapter" data-level="4.6" data-path="STSI.html"><a href="STSI.html#geostrata"><i class="fa fa-check"></i><b>4.6</b> Geographical stratification</a></li>
<li class="chapter" data-level="4.7" data-path="STSI.html"><a href="STSI.html#multi-way-stratification"><i class="fa fa-check"></i><b>4.7</b> Multi-way stratification</a></li>
<li class="chapter" data-level="4.8" data-path="STSI.html"><a href="STSI.html#MultivariateStratification"><i class="fa fa-check"></i><b>4.8</b> Multivariate stratification</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="SY.html"><a href="SY.html"><i class="fa fa-check"></i><b>5</b> Systematic random sampling</a>
<ul>
<li class="chapter" data-level="5.1" data-path="SY.html"><a href="SY.html#EstVarSY"><i class="fa fa-check"></i><b>5.1</b> Estimation of population parameters</a></li>
<li class="chapter" data-level="5.2" data-path="SY.html"><a href="SY.html#approximating-the-sampling-variance-of-the-estimator-of-the-mean"><i class="fa fa-check"></i><b>5.2</b> Approximating the sampling variance of the estimator of the mean</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="Cl.html"><a href="Cl.html"><i class="fa fa-check"></i><b>6</b> Cluster random sampling</a>
<ul>
<li class="chapter" data-level="6.1" data-path="Cl.html"><a href="Cl.html#clustersamplingestimators"><i class="fa fa-check"></i><b>6.1</b> Estimation of population parameters</a></li>
<li class="chapter" data-level="6.2" data-path="Cl.html"><a href="Cl.html#clusters-selected-with-probabilities-proportional-to-size-without-replacement"><i class="fa fa-check"></i><b>6.2</b> Clusters selected with probabilities proportional to size, without replacement</a></li>
<li class="chapter" data-level="6.3" data-path="Cl.html"><a href="Cl.html#SIC"><i class="fa fa-check"></i><b>6.3</b> Simple random sampling of clusters</a></li>
<li class="chapter" data-level="6.4" data-path="Cl.html"><a href="Cl.html#StratifiedCl"><i class="fa fa-check"></i><b>6.4</b> Stratified cluster random sampling</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="Twostage.html"><a href="Twostage.html"><i class="fa fa-check"></i><b>7</b> Two-stage cluster random sampling</a>
<ul>
<li class="chapter" data-level="7.1" data-path="Twostage.html"><a href="Twostage.html#twostagesamplingestimators"><i class="fa fa-check"></i><b>7.1</b> Estimation of population parameters</a></li>
<li class="chapter" data-level="7.2" data-path="Twostage.html"><a href="Twostage.html#primary-sampling-units-selected-without-replacement"><i class="fa fa-check"></i><b>7.2</b> Primary sampling units selected without replacement</a></li>
<li class="chapter" data-level="7.3" data-path="Twostage.html"><a href="Twostage.html#TwostageSISI"><i class="fa fa-check"></i><b>7.3</b> Simple random sampling of primary sampling units</a></li>
<li class="chapter" data-level="7.4" data-path="Twostage.html"><a href="Twostage.html#StratifiedTwostage"><i class="fa fa-check"></i><b>7.4</b> Stratified two-stage cluster random sampling</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="pps.html"><a href="pps.html"><i class="fa fa-check"></i><b>8</b> Sampling with probabilities proportional to size</a>
<ul>
<li class="chapter" data-level="8.1" data-path="pps.html"><a href="pps.html#ppswr"><i class="fa fa-check"></i><b>8.1</b> Probability-proportional-to-size sampling with replacement</a></li>
<li class="chapter" data-level="8.2" data-path="pps.html"><a href="pps.html#ppswor"><i class="fa fa-check"></i><b>8.2</b> Probability-proportional-to-size sampling without replacement</a>
<ul>
<li class="chapter" data-level="8.2.1" data-path="pps.html"><a href="pps.html#Systematicpps"><i class="fa fa-check"></i><b>8.2.1</b> Systematic pps sampling without replacement</a></li>
<li class="chapter" data-level="8.2.2" data-path="pps.html"><a href="pps.html#pivotalmethod"><i class="fa fa-check"></i><b>8.2.2</b> The pivotal method</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html"><i class="fa fa-check"></i><b>9</b> Balanced and well-spread sampling</a>
<ul>
<li class="chapter" data-level="9.1" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#Balanced"><i class="fa fa-check"></i><b>9.1</b> Balanced sampling</a>
<ul>
<li class="chapter" data-level="9.1.1" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#balanced-sample-versus-balanced-sampling-design"><i class="fa fa-check"></i><b>9.1.1</b> Balanced sample versus balanced sampling design</a></li>
<li class="chapter" data-level="9.1.2" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#unequal-inclusion-probabilities"><i class="fa fa-check"></i><b>9.1.2</b> Unequal inclusion probabilities</a></li>
<li class="chapter" data-level="9.1.3" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#StratifiedsamplingasBalancedsampling"><i class="fa fa-check"></i><b>9.1.3</b> Stratified random sampling</a></li>
<li class="chapter" data-level="9.1.4" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#Multiwaystratification"><i class="fa fa-check"></i><b>9.1.4</b> Multi-way stratification</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#Spreaded"><i class="fa fa-check"></i><b>9.2</b> Well-spread sampling</a>
<ul>
<li class="chapter" data-level="9.2.1" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#LPM"><i class="fa fa-check"></i><b>9.2.1</b> Local pivotal method</a></li>
<li class="chapter" data-level="9.2.2" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#GRTS"><i class="fa fa-check"></i><b>9.2.2</b> Generalised random-tessellation stratified sampling</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="BalancedSpreaded.html"><a href="BalancedSpreaded.html#BalancedandSpreaded"><i class="fa fa-check"></i><b>9.3</b> Balanced sampling with spreading</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="Modelassisted.html"><a href="Modelassisted.html"><i class="fa fa-check"></i><b>10</b> Model-assisted estimation</a>
<ul>
<li class="chapter" data-level="10.1" data-path="Modelassisted.html"><a href="Modelassisted.html#GREG"><i class="fa fa-check"></i><b>10.1</b> Generalised regression estimator</a>
<ul>
<li class="chapter" data-level="10.1.1" data-path="Modelassisted.html"><a href="Modelassisted.html#RegressionEstimator"><i class="fa fa-check"></i><b>10.1.1</b> Simple and multiple regression estimators</a></li>
<li class="chapter" data-level="10.1.2" data-path="Modelassisted.html"><a href="Modelassisted.html#penalised-least-squares-estimation"><i class="fa fa-check"></i><b>10.1.2</b> Penalised least squares estimation</a></li>
<li class="chapter" data-level="10.1.3" data-path="Modelassisted.html"><a href="Modelassisted.html#RegressionEstimatorSTSI"><i class="fa fa-check"></i><b>10.1.3</b> Regression estimator with stratified simple random sampling</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="Modelassisted.html"><a href="Modelassisted.html#RatioEstimator"><i class="fa fa-check"></i><b>10.2</b> Ratio estimator</a>
<ul>
<li class="chapter" data-level="10.2.1" data-path="Modelassisted.html"><a href="Modelassisted.html#RatioEstimatorSTSI"><i class="fa fa-check"></i><b>10.2.1</b> Ratio estimators with stratified simple random sampling</a></li>
<li class="chapter" data-level="10.2.2" data-path="Modelassisted.html"><a href="Modelassisted.html#PoststratifiedEstimator"><i class="fa fa-check"></i><b>10.2.2</b> Poststratified estimator</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="Modelassisted.html"><a href="Modelassisted.html#RandomForest"><i class="fa fa-check"></i><b>10.3</b> Model-assisted estimation using machine learning techniques</a>
<ul>
<li class="chapter" data-level="10.3.1" data-path="Modelassisted.html"><a href="Modelassisted.html#predicting-with-a-regression-tree"><i class="fa fa-check"></i><b>10.3.1</b> Predicting with a regression tree</a></li>
<li class="chapter" data-level="10.3.2" data-path="Modelassisted.html"><a href="Modelassisted.html#predicting-with-a-random-forest"><i class="fa fa-check"></i><b>10.3.2</b> Predicting with a random forest</a></li>
</ul></li>
<li class="chapter" data-level="10.4" data-path="Modelassisted.html"><a href="Modelassisted.html#big-data-and-volunteer-data"><i class="fa fa-check"></i><b>10.4</b> Big data and volunteer data</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="Twophase.html"><a href="Twophase.html"><i class="fa fa-check"></i><b>11</b> Two-phase random sampling</a>
<ul>
<li class="chapter" data-level="11.1" data-path="Twophase.html"><a href="Twophase.html#TwophaseStratification"><i class="fa fa-check"></i><b>11.1</b> Two-phase random sampling for stratification</a></li>
<li class="chapter" data-level="11.2" data-path="Twophase.html"><a href="Twophase.html#TwophaseRegression"><i class="fa fa-check"></i><b>11.2</b> Two-phase random sampling for regression</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html"><i class="fa fa-check"></i><b>12</b> Computing the required sample size</a>
<ul>
<li class="chapter" data-level="12.1" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#standard-error"><i class="fa fa-check"></i><b>12.1</b> Standard error</a></li>
<li class="chapter" data-level="12.2" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#ReqSampleSizeLengthCI"><i class="fa fa-check"></i><b>12.2</b> Length of confidence interval</a>
<ul>
<li class="chapter" data-level="12.2.1" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#length-of-confidence-interval-for-a-proportion"><i class="fa fa-check"></i><b>12.2.1</b> Length of confidence interval for a proportion</a></li>
</ul></li>
<li class="chapter" data-level="12.3" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#statistical-testing-of-hypothesis"><i class="fa fa-check"></i><b>12.3</b> Statistical testing of hypothesis</a>
<ul>
<li class="chapter" data-level="12.3.1" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#sample-size-for-testing-a-proportion"><i class="fa fa-check"></i><b>12.3.1</b> Sample size for testing a proportion</a></li>
</ul></li>
<li class="chapter" data-level="12.4" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#DesignEffect"><i class="fa fa-check"></i><b>12.4</b> Accounting for design effect</a></li>
<li class="chapter" data-level="12.5" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#BayesianSampleSize"><i class="fa fa-check"></i><b>12.5</b> Bayesian sample size determination</a>
<ul>
<li class="chapter" data-level="12.5.1" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#bayesian-criteria-for-sample-size-computation"><i class="fa fa-check"></i><b>12.5.1</b> Bayesian criteria for sample size computation</a></li>
<li class="chapter" data-level="12.5.2" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#mixed-bayesian-likelihood-approach"><i class="fa fa-check"></i><b>12.5.2</b> Mixed Bayesian-likelihood approach</a></li>
<li class="chapter" data-level="12.5.3" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#estimation-of-population-mean"><i class="fa fa-check"></i><b>12.5.3</b> Estimation of population mean</a></li>
<li class="chapter" data-level="12.5.4" data-path="RequiredSampleSize.html"><a href="RequiredSampleSize.html#estimation-of-a-population-proportion"><i class="fa fa-check"></i><b>12.5.4</b> Estimation of a population proportion</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="13" data-path="MBpredictionofDesignVariance.html"><a href="MBpredictionofDesignVariance.html"><i class="fa fa-check"></i><b>13</b> Model-based optimisation of probability sampling designs</a>
<ul>
<li class="chapter" data-level="13.1" data-path="MBpredictionofDesignVariance.html"><a href="MBpredictionofDesignVariance.html#model-based-optimisation-of-sampling-design-type-and-sample-size"><i class="fa fa-check"></i><b>13.1</b> Model-based optimisation of sampling design type and sample size</a>
<ul>
<li class="chapter" data-level="13.1.1" data-path="MBpredictionofDesignVariance.html"><a href="MBpredictionofDesignVariance.html#AnalyticalApproach"><i class="fa fa-check"></i><b>13.1.1</b> Analytical approach</a></li>
<li class="chapter" data-level="13.1.2" data-path="MBpredictionofDesignVariance.html"><a href="MBpredictionofDesignVariance.html#GeostatisticalSimulationApproach"><i class="fa fa-check"></i><b>13.1.2</b> Geostatistical simulation approach</a></li>
<li class="chapter" data-level="13.1.3" data-path="MBpredictionofDesignVariance.html"><a href="MBpredictionofDesignVariance.html#MBpredSamplingVarBayes"><i class="fa fa-check"></i><b>13.1.3</b> Bayesian approach</a></li>
</ul></li>
<li class="chapter" data-level="13.2" data-path="MBpredictionofDesignVariance.html"><a href="MBpredictionofDesignVariance.html#Ospats"><i class="fa fa-check"></i><b>13.2</b> Model-based optimisation of spatial strata</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html"><i class="fa fa-check"></i><b>14</b> Sampling for estimating parameters of (small) domains</a>
<ul>
<li class="chapter" data-level="14.1" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html#LargeDomainsDirectEstimator"><i class="fa fa-check"></i><b>14.1</b> Direct estimator for large domains</a></li>
<li class="chapter" data-level="14.2" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html#SmallDomainsModelAssisted"><i class="fa fa-check"></i><b>14.2</b> Model-assisted estimators for small domains</a>
<ul>
<li class="chapter" data-level="14.2.1" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html#RegressionestimatorSmallDomain"><i class="fa fa-check"></i><b>14.2.1</b> Regression estimator</a></li>
<li class="chapter" data-level="14.2.2" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html#SyntheticestimatorSmallDomain"><i class="fa fa-check"></i><b>14.2.2</b> Synthetic estimator</a></li>
</ul></li>
<li class="chapter" data-level="14.3" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html#SmallAreaModelBased"><i class="fa fa-check"></i><b>14.3</b> Model-based prediction</a>
<ul>
<li class="chapter" data-level="14.3.1" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html#random-intercept-model"><i class="fa fa-check"></i><b>14.3.1</b> Random intercept model</a></li>
<li class="chapter" data-level="14.3.2" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html#geostatistical-model"><i class="fa fa-check"></i><b>14.3.2</b> Geostatistical model</a></li>
</ul></li>
<li class="chapter" data-level="14.4" data-path="SmallAreaEstimation.html"><a href="SmallAreaEstimation.html#supplemental-probability-sampling-of-small-domains"><i class="fa fa-check"></i><b>14.4</b> Supplemental probability sampling of small domains</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html"><i class="fa fa-check"></i><b>15</b> Repeated sample surveys for monitoring population parameters</a>
<ul>
<li class="chapter" data-level="15.1" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#space-time-designs"><i class="fa fa-check"></i><b>15.1</b> Space-time designs</a></li>
<li class="chapter" data-level="15.2" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#SpaceTimeparameters"><i class="fa fa-check"></i><b>15.2</b> Space-time population parameters</a></li>
<li class="chapter" data-level="15.3" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#design-based-generalised-least-squares-estimation-of-spatial-means"><i class="fa fa-check"></i><b>15.3</b> Design-based generalised least squares estimation of spatial means</a>
<ul>
<li class="chapter" data-level="15.3.1" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#current-mean"><i class="fa fa-check"></i><b>15.3.1</b> Current mean</a></li>
<li class="chapter" data-level="15.3.2" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#change-of-the-spatial-mean"><i class="fa fa-check"></i><b>15.3.2</b> Change of the spatial mean</a></li>
<li class="chapter" data-level="15.3.3" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#temporal-trend-of-the-spatial-mean"><i class="fa fa-check"></i><b>15.3.3</b> Temporal trend of the spatial mean</a></li>
<li class="chapter" data-level="15.3.4" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#space-time-mean"><i class="fa fa-check"></i><b>15.3.4</b> Space-time mean</a></li>
</ul></li>
<li class="chapter" data-level="15.4" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#case-study-annual-mean-daily-temperature-in-spain"><i class="fa fa-check"></i><b>15.4</b> Case study: annual mean daily temperature in Spain</a>
<ul>
<li class="chapter" data-level="15.4.1" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#static-synchronous-design"><i class="fa fa-check"></i><b>15.4.1</b> Static-synchronous design</a></li>
<li class="chapter" data-level="15.4.2" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#independent-synchronous-design"><i class="fa fa-check"></i><b>15.4.2</b> Independent synchronous design</a></li>
<li class="chapter" data-level="15.4.3" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#serially-alternating-design"><i class="fa fa-check"></i><b>15.4.3</b> Serially alternating design</a></li>
<li class="chapter" data-level="15.4.4" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#supplemented-panel-design"><i class="fa fa-check"></i><b>15.4.4</b> Supplemented panel design</a></li>
<li class="chapter" data-level="15.4.5" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#rotating-panel-design"><i class="fa fa-check"></i><b>15.4.5</b> Rotating panel design</a></li>
<li class="chapter" data-level="15.4.6" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#sampling-experiment"><i class="fa fa-check"></i><b>15.4.6</b> Sampling experiment</a></li>
</ul></li>
<li class="chapter" data-level="15.5" data-path="RepeatedSurveys.html"><a href="RepeatedSurveys.html#space-time-sampling-with-stratified-random-sampling-in-space"><i class="fa fa-check"></i><b>15.5</b> Space-time sampling with stratified random sampling in space</a></li>
</ul></li>
<li class="part"><span><b>II Sampling for mapping</b></span></li>
<li class="chapter" data-level="16" data-path="IntroSamplingforMapping.html"><a href="IntroSamplingforMapping.html"><i class="fa fa-check"></i><b>16</b> Introduction to sampling for mapping</a>
<ul>
<li class="chapter" data-level="16.1" data-path="IntroSamplingforMapping.html"><a href="IntroSamplingforMapping.html#when-is-probability-sampling-not-required"><i class="fa fa-check"></i><b>16.1</b> When is probability sampling not required?</a></li>
<li class="chapter" data-level="16.2" data-path="IntroSamplingforMapping.html"><a href="IntroSamplingforMapping.html#sampling-for-simultaneously-mapping-and-estimating-means"><i class="fa fa-check"></i><b>16.2</b> Sampling for simultaneously mapping and estimating means</a></li>
<li class="chapter" data-level="16.3" data-path="IntroSamplingforMapping.html"><a href="IntroSamplingforMapping.html#broad-overview-of-sampling-designs-for-mapping"><i class="fa fa-check"></i><b>16.3</b> Broad overview of sampling designs for mapping</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="RegularGridSpatialCoverage.html"><a href="RegularGridSpatialCoverage.html"><i class="fa fa-check"></i><b>17</b> Regular grid and spatial coverage sampling</a>
<ul>
<li class="chapter" data-level="17.1" data-path="RegularGridSpatialCoverage.html"><a href="RegularGridSpatialCoverage.html#Regulargrid"><i class="fa fa-check"></i><b>17.1</b> Regular grid sampling</a></li>
<li class="chapter" data-level="17.2" data-path="RegularGridSpatialCoverage.html"><a href="RegularGridSpatialCoverage.html#SpatialCoverage"><i class="fa fa-check"></i><b>17.2</b> Spatial coverage sampling</a></li>
<li class="chapter" data-level="17.3" data-path="RegularGridSpatialCoverage.html"><a href="RegularGridSpatialCoverage.html#SpatialInfill"><i class="fa fa-check"></i><b>17.3</b> Spatial infill sampling</a></li>
</ul></li>
<li class="chapter" data-level="18" data-path="kmeans.html"><a href="kmeans.html"><i class="fa fa-check"></i><b>18</b> Covariate space coverage sampling</a>
<ul>
<li class="chapter" data-level="18.1" data-path="kmeans.html"><a href="kmeans.html#covariate-space-infill-sampling"><i class="fa fa-check"></i><b>18.1</b> Covariate space infill sampling</a></li>
<li class="chapter" data-level="18.2" data-path="kmeans.html"><a href="kmeans.html#PerformanceCSC"><i class="fa fa-check"></i><b>18.2</b> Performance of covariate space coverage sampling in random forest prediction</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="cLHS.html"><a href="cLHS.html"><i class="fa fa-check"></i><b>19</b> Conditioned Latin hypercube sampling</a>
<ul>
<li class="chapter" data-level="19.1" data-path="cLHS.html"><a href="cLHS.html#cLHIS"><i class="fa fa-check"></i><b>19.1</b> Conditioned Latin hypercube infill sampling</a></li>
<li class="chapter" data-level="19.2" data-path="cLHS.html"><a href="cLHS.html#performance-of-conditioned-latin-hypercube-sampling-in-random-forest-prediction"><i class="fa fa-check"></i><b>19.2</b> Performance of conditioned Latin hypercube sampling in random forest prediction</a></li>
</ul></li>
<li class="chapter" data-level="20" data-path="SpatialResponseSurface.html"><a href="SpatialResponseSurface.html"><i class="fa fa-check"></i><b>20</b> Spatial response surface sampling</a>
<ul>
<li class="chapter" data-level="20.1" data-path="SpatialResponseSurface.html"><a href="SpatialResponseSurface.html#IncreaseSampleSize"><i class="fa fa-check"></i><b>20.1</b> Increasing the sample size</a></li>
<li class="chapter" data-level="20.2" data-path="SpatialResponseSurface.html"><a href="SpatialResponseSurface.html#stratified-spatial-response-surface-sampling"><i class="fa fa-check"></i><b>20.2</b> Stratified spatial response surface sampling</a></li>
</ul></li>
<li class="chapter" data-level="21" data-path="Introkriging.html"><a href="Introkriging.html"><i class="fa fa-check"></i><b>21</b> Introduction to kriging</a>
<ul>
<li class="chapter" data-level="21.1" data-path="Introkriging.html"><a href="Introkriging.html#OrdinaryKriging"><i class="fa fa-check"></i><b>21.1</b> Ordinary kriging</a></li>
<li class="chapter" data-level="21.2" data-path="Introkriging.html"><a href="Introkriging.html#BlockKriging"><i class="fa fa-check"></i><b>21.2</b> Block-kriging</a></li>
<li class="chapter" data-level="21.3" data-path="Introkriging.html"><a href="Introkriging.html#IntroKED"><i class="fa fa-check"></i><b>21.3</b> Kriging with an external drift</a></li>
<li class="chapter" data-level="21.4" data-path="Introkriging.html"><a href="Introkriging.html#VariogramEstimation"><i class="fa fa-check"></i><b>21.4</b> Estimating the semivariogram</a>
<ul>
<li class="chapter" data-level="21.4.1" data-path="Introkriging.html"><a href="Introkriging.html#MoM"><i class="fa fa-check"></i><b>21.4.1</b> Method-of-moments</a></li>
<li class="chapter" data-level="21.4.2" data-path="Introkriging.html"><a href="Introkriging.html#MLestimationVariogram"><i class="fa fa-check"></i><b>21.4.2</b> Maximum likelihood</a></li>
</ul></li>
<li class="chapter" data-level="21.5" data-path="Introkriging.html"><a href="Introkriging.html#ResidualVariogram"><i class="fa fa-check"></i><b>21.5</b> Estimating the residual semivariogram</a>
<ul>
<li class="chapter" data-level="21.5.1" data-path="Introkriging.html"><a href="Introkriging.html#IterativeMoM"><i class="fa fa-check"></i><b>21.5.1</b> Iterative method-of-moments</a></li>
<li class="chapter" data-level="21.5.2" data-path="Introkriging.html"><a href="Introkriging.html#REML"><i class="fa fa-check"></i><b>21.5.2</b> Restricted maximum likelihood</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="22" data-path="MBgridspacing.html"><a href="MBgridspacing.html"><i class="fa fa-check"></i><b>22</b> Model-based optimisation of the grid spacing</a>
<ul>
<li class="chapter" data-level="22.1" data-path="MBgridspacing.html"><a href="MBgridspacing.html#GridspacingOK"><i class="fa fa-check"></i><b>22.1</b> Optimal grid spacing for ordinary kriging</a></li>
<li class="chapter" data-level="22.2" data-path="MBgridspacing.html"><a href="MBgridspacing.html#controlling-the-mean-or-a-quantile-of-the-ordinary-kriging-variance"><i class="fa fa-check"></i><b>22.2</b> Controlling the mean or a quantile of the ordinary kriging variance</a></li>
<li class="chapter" data-level="22.3" data-path="MBgridspacing.html"><a href="MBgridspacing.html#optimal-grid-spacing-for-block-kriging"><i class="fa fa-check"></i><b>22.3</b> Optimal grid spacing for block-kriging</a></li>
<li class="chapter" data-level="22.4" data-path="MBgridspacing.html"><a href="MBgridspacing.html#MBgridspacingKED"><i class="fa fa-check"></i><b>22.4</b> Optimal grid spacing for kriging with an external drift</a></li>
<li class="chapter" data-level="22.5" data-path="MBgridspacing.html"><a href="MBgridspacing.html#BayesianGridSpacing"><i class="fa fa-check"></i><b>22.5</b> Bayesian approach</a></li>
</ul></li>
<li class="chapter" data-level="23" data-path="MBSamplePattern.html"><a href="MBSamplePattern.html"><i class="fa fa-check"></i><b>23</b> Model-based optimisation of the sampling pattern</a>
<ul>
<li class="chapter" data-level="23.1" data-path="MBSamplePattern.html"><a href="MBSamplePattern.html#SSA"><i class="fa fa-check"></i><b>23.1</b> Spatial simulated annealing</a></li>
<li class="chapter" data-level="23.2" data-path="MBSamplePattern.html"><a href="MBSamplePattern.html#SamplePatternOK"><i class="fa fa-check"></i><b>23.2</b> Optimising the sampling pattern for ordinary kriging</a></li>
<li class="chapter" data-level="23.3" data-path="MBSamplePattern.html"><a href="MBSamplePattern.html#SamplePatternKED"><i class="fa fa-check"></i><b>23.3</b> Optimising the sampling pattern for kriging with an external drift</a></li>
<li class="chapter" data-level="23.4" data-path="MBSamplePattern.html"><a href="MBSamplePattern.html#model-based-infill-sampling-for-ordinary-kriging"><i class="fa fa-check"></i><b>23.4</b> Model-based infill sampling for ordinary kriging</a></li>
<li class="chapter" data-level="23.5" data-path="MBSamplePattern.html"><a href="MBSamplePattern.html#model-based-infill-sampling-for-kriging-with-an-external-drift"><i class="fa fa-check"></i><b>23.5</b> Model-based infill sampling for kriging with an external drift</a></li>
</ul></li>
<li class="chapter" data-level="24" data-path="SamplingVariogram.html"><a href="SamplingVariogram.html"><i class="fa fa-check"></i><b>24</b> Sampling for estimating the semivariogram</a>
<ul>
<li class="chapter" data-level="24.1" data-path="SamplingVariogram.html"><a href="SamplingVariogram.html#NestedSampling"><i class="fa fa-check"></i><b>24.1</b> Nested sampling</a></li>
<li class="chapter" data-level="24.2" data-path="SamplingVariogram.html"><a href="SamplingVariogram.html#IndependentSamplingPairs"><i class="fa fa-check"></i><b>24.2</b> Independent sampling of pairs of points</a></li>
<li class="chapter" data-level="24.3" data-path="SamplingVariogram.html"><a href="SamplingVariogram.html#samplingforvariogram"><i class="fa fa-check"></i><b>24.3</b> Optimisation of sampling pattern for semivariogram estimation</a>
<ul>
<li class="chapter" data-level="24.3.1" data-path="SamplingVariogram.html"><a href="SamplingVariogram.html#UncertainSemivariogramParameters"><i class="fa fa-check"></i><b>24.3.1</b> Uncertainty about semivariogram parameters</a></li>
<li class="chapter" data-level="24.3.2" data-path="SamplingVariogram.html"><a href="SamplingVariogram.html#UncertainKrigingVariance"><i class="fa fa-check"></i><b>24.3.2</b> Uncertainty about the kriging variance</a></li>
</ul></li>
<li class="chapter" data-level="24.4" data-path="SamplingVariogram.html"><a href="SamplingVariogram.html#SamplingEstimationandPrediction"><i class="fa fa-check"></i><b>24.4</b> Optimisation of sampling pattern for semivariogram estimation and mapping</a></li>
<li class="chapter" data-level="24.5" data-path="SamplingVariogram.html"><a href="SamplingVariogram.html#a-practical-solution"><i class="fa fa-check"></i><b>24.5</b> A practical solution</a></li>
</ul></li>
<li class="chapter" data-level="25" data-path="Validation.html"><a href="Validation.html"><i class="fa fa-check"></i><b>25</b> Sampling for validation of maps</a>
<ul>
<li class="chapter" data-level="25.1" data-path="Validation.html"><a href="Validation.html#map-quality-indices"><i class="fa fa-check"></i><b>25.1</b> Map quality indices</a>
<ul>
<li class="chapter" data-level="25.1.1" data-path="Validation.html"><a href="Validation.html#estimation-of-map-quality-indices"><i class="fa fa-check"></i><b>25.1.1</b> Estimation of map quality indices</a></li>
</ul></li>
<li class="chapter" data-level="25.2" data-path="Validation.html"><a href="Validation.html#real-world-case-study"><i class="fa fa-check"></i><b>25.2</b> Real-world case study</a>
<ul>
<li class="chapter" data-level="25.2.1" data-path="Validation.html"><a href="Validation.html#estimation-of-the-population-mean-error-and-mean-squared-error"><i class="fa fa-check"></i><b>25.2.1</b> Estimation of the population mean error and mean squared error</a></li>
<li class="chapter" data-level="25.2.2" data-path="Validation.html"><a href="Validation.html#estimation-of-the-standard-error-of-the-estimator-of-the-population-mean-error-and-mean-squared-error"><i class="fa fa-check"></i><b>25.2.2</b> Estimation of the standard error of the estimator of the population mean error and mean squared error</a></li>
<li class="chapter" data-level="25.2.3" data-path="Validation.html"><a href="Validation.html#estimation-of-model-efficiency-coefficient"><i class="fa fa-check"></i><b>25.2.3</b> Estimation of model efficiency coefficient</a></li>
<li class="chapter" data-level="25.2.4" data-path="Validation.html"><a href="Validation.html#statistical-testing-of-hypothesis-about-population-me-and-mse"><i class="fa fa-check"></i><b>25.2.4</b> Statistical testing of hypothesis about population ME and MSE</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="26" data-path="Approaches.html"><a href="Approaches.html"><i class="fa fa-check"></i><b>26</b> Design-based, model-based, and model-assisted approach for sampling and inference</a>
<ul>
<li class="chapter" data-level="26.1" data-path="Approaches.html"><a href="Approaches.html#two-sources-of-randomness"><i class="fa fa-check"></i><b>26.1</b> Two sources of randomness</a></li>
<li class="chapter" data-level="26.2" data-path="Approaches.html"><a href="Approaches.html#iid"><i class="fa fa-check"></i><b>26.2</b> “Identically and independently distributed” (i.i.d.)</a></li>
<li class="chapter" data-level="26.3" data-path="Approaches.html"><a href="Approaches.html#BiasandVariance"><i class="fa fa-check"></i><b>26.3</b> Bias and variance</a></li>
<li class="chapter" data-level="26.4" data-path="Approaches.html"><a href="Approaches.html#effectivesamplesize"><i class="fa fa-check"></i><b>26.4</b> Effective sample size</a></li>
<li class="chapter" data-level="26.5" data-path="Approaches.html"><a href="Approaches.html#ExploitSpatialStructure"><i class="fa fa-check"></i><b>26.5</b> Exploiting spatial structure in design-based approach</a></li>
<li class="chapter" data-level="26.6" data-path="Approaches.html"><a href="Approaches.html#ModelassistedvsModeldependent"><i class="fa fa-check"></i><b>26.6</b> Model-assisted versus model-dependent</a></li>
</ul></li>
<li class="appendix"><span><b>Appendices</b></span></li>
<li class="chapter" data-level="A" data-path="Answers.html"><a href="Answers.html"><i class="fa fa-check"></i><b>A</b> Answers to exercises</a>
<ul>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#introduction-to-probability-sampling"><i class="fa fa-check"></i>Introduction to probability sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#simple-random-sampling-1"><i class="fa fa-check"></i>Simple random sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#stratified-simple-random-sampling-1"><i class="fa fa-check"></i>Stratified simple random sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#systematic-random-sampling-2"><i class="fa fa-check"></i>Systematic random sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#cluster-random-sampling"><i class="fa fa-check"></i>Cluster random sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#two-stage-cluster-random-sampling-1"><i class="fa fa-check"></i>Two-stage cluster random sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#sampling-with-probabilities-proportional-to-size"><i class="fa fa-check"></i>Sampling with probabilities proportional to size</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#balanced-and-well-spread-sampling"><i class="fa fa-check"></i>Balanced and well-spread sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#model-assisted-estimation"><i class="fa fa-check"></i>Model-assisted estimation</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#two-phase-random-sampling"><i class="fa fa-check"></i>Two-phase random sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#computing-the-required-sample-size"><i class="fa fa-check"></i>Computing the required sample size</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#model-based-optimisation-of-probability-sampling-designs"><i class="fa fa-check"></i>Model-based optimisation of probability sampling designs</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#repeated-sample-surveys-for-monitoring-population-parameters"><i class="fa fa-check"></i>Repeated sample surveys for monitoring population parameters</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#regular-grid-and-spatial-coverage-sampling"><i class="fa fa-check"></i>Regular grid and spatial coverage sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#covariate-space-coverage-sampling"><i class="fa fa-check"></i>Covariate space coverage sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#conditioned-latin-hypercube-sampling"><i class="fa fa-check"></i>Conditioned Latin hypercube sampling</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#model-based-optimisation-of-the-grid-spacing"><i class="fa fa-check"></i>Model-based optimisation of the grid spacing</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#model-based-optimisation-of-the-sampling-pattern"><i class="fa fa-check"></i>Model-based optimisation of the sampling pattern</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#sampling-for-estimating-the-semivariogram"><i class="fa fa-check"></i>Sampling for estimating the semivariogram</a></li>
<li class="chapter" data-level="" data-path="Answers.html"><a href="Answers.html#sampling-for-validation-of-maps"><i class="fa fa-check"></i>Sampling for validation of maps</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/DickBrus/">Dick Brus</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Spatial sampling with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="Cl" class="section level1" number="6">
<h1><span class="header-section-number">Chapter 6</span> Cluster random sampling</h1>
<p>With stratified random sampling using geographical strata and systematic random sampling the sampling units are well spread throughout the study area. In general this leads to an increase of the precision of the estimated mean (total). This is because many spatial populations show spatial structure, so that the values of the study variable at two close units are more similar than those at two distant units. With large study areas the price to be paid for this is long travel times, so that fewer sampling units can be observed in a given survey time. In this situation it can be more efficient to select <em>spatial clusters</em> of population units. In cluster random sampling, once a cluster is selected, <em>all</em> units in this cluster are observed. Therefore this design is also referred to as <em>single-stage</em> cluster random sampling. The clusters are not subsampled as in two-stage cluster random sampling (see Chapter <a href="Twostage.html#Twostage">7</a>).</p>
<p>In spatial sampling a popular cluster shape is a transect. This is because the individual sampling units of a transect can easily be located in the field, which was in particular an advantage in the pre-GPS era.</p>
<p>The implementation of cluster random sampling is not straightforward. Frequently this sampling design is improperly implemented. A proper selection technique is as follows <span class="citation">(<a href="#ref-gru06" role="doc-biblioref">de Gruijter et al. 2006</a>)</span>. In the first step a starting unit is selected, for instance by simple random sampling. Then the remaining units of the cluster to which the starting unit belongs are identified by making use of the definition of the cluster. For instance, with clusters defined as E-W oriented transects with a spacing of 100 m between the units of a cluster, all units E and W of the starting unit at a distance of 100 m, 200 m, etc. that fall inside the study area are selected. These two steps are repeated until the required number of <em>clusters</em> (not the number of units) is selected.</p>
<p>A requirement of a valid selection method is that the same cluster is selected, regardless of which of its units is used as a starting unit. In the example above this is the case: regardless of which of the units of the transect is selected first, the final set of units selected is the same because, as stated above, all units E and W of the starting unit are selected.</p>

<div class="rmdnote">
An example of an improper implementation of cluster random sampling is the following selection procedure. A cluster is defined as an E-W oriented transect of four units with a mutual spacing of 100 m. A cluster is selected by randomly selecting a starting unit. The remaining three units of the cluster are selected E of this starting unit. Units outside the study area are ignored. With this selection method the set of selected units is <em>not</em> independent of the starting unit, and therefore this selection method is invalid.
</div>
<p>Note that the size, i.e. the number of units, of a cluster need not be constant. With the proper selection method described above the selection probability of a cluster is proportional to its size. With irregularly shaped study areas the size of the clusters can vary strongly. The size of the clusters can be controlled by subdividing the study area into blocks, for instance stripes perpendicular to the direction of the transects, or square blocks in case the clusters are grids. In this case, the remaining units are identified by extending the transect or grid until the boundary of the block. With irregularly shaped areas blocking will not entirely eliminate the variation in cluster sizes.</p>
<p>Cluster random sampling is illustrated with the selection of E-W oriented transects in Voorst. In order to delimit the length of the transects the study area is split into six 1 km <span class="math inline">\(\times\)</span> 1 km zones. In this case the zones have an equal size, but this is not needed. Note that these zones do not serve as strata. When used as strata, from each zone one or more clusters would be selected, see Section <a href="Cl.html#StratifiedCl">6.4</a>.</p>
<p>In the code chunk below the zones are constructed by first computing a vector with the s1-coordinates of the boundaries of the zones. Half the size of the cells of the discretisation grid (12.5 m) is added to <code>s1bnd</code> so that the boundaries are halfway discretisation points (centres of discretisation grid cells). Function <code>findInterval</code> of the <strong>base</strong> package is then used to determine for all discretisation points in which zone they fall.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="Cl.html#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sp)</span>
<span id="cb93-2"><a href="Cl.html#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gridded</span>(grdVoorst) <span class="ot">&lt;-</span> <span class="er">~</span> s1 <span class="sc">+</span> s2</span>
<span id="cb93-3"><a href="Cl.html#cb93-3" aria-hidden="true" tabindex="-1"></a>gridtop <span class="ot">&lt;-</span> <span class="fu">as</span>(<span class="fu">getGridTopology</span>(grdVoorst), <span class="st">&quot;data.frame&quot;</span>)</span>
<span id="cb93-4"><a href="Cl.html#cb93-4" aria-hidden="true" tabindex="-1"></a>cellsize <span class="ot">&lt;-</span> gridtop<span class="sc">$</span>cellsize[<span class="dv">1</span>]</span>
<span id="cb93-5"><a href="Cl.html#cb93-5" aria-hidden="true" tabindex="-1"></a>grdVoorst <span class="ot">&lt;-</span> <span class="fu">as</span>(grdVoorst, <span class="st">&quot;data.frame&quot;</span>)</span>
<span id="cb93-6"><a href="Cl.html#cb93-6" aria-hidden="true" tabindex="-1"></a>w <span class="ot">&lt;-</span> <span class="dv">1000</span> <span class="co">#width of zones</span></span>
<span id="cb93-7"><a href="Cl.html#cb93-7" aria-hidden="true" tabindex="-1"></a>s1bnd <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from =</span> <span class="fu">min</span>(grdVoorst<span class="sc">$</span>s1) <span class="sc">+</span> w, <span class="at">to =</span> <span class="fu">min</span>(grdVoorst<span class="sc">$</span>s1) <span class="sc">+</span> <span class="dv">5</span> <span class="sc">*</span> w,</span>
<span id="cb93-8"><a href="Cl.html#cb93-8" aria-hidden="true" tabindex="-1"></a>             <span class="at">by =</span> w) <span class="sc">+</span> cellsize <span class="sc">/</span> <span class="dv">2</span></span>
<span id="cb93-9"><a href="Cl.html#cb93-9" aria-hidden="true" tabindex="-1"></a>grdVoorst<span class="sc">$</span>zone <span class="ot">&lt;-</span> <span class="fu">findInterval</span>(grdVoorst<span class="sc">$</span>s1, s1bnd)</span></code></pre></div>
<p>As a first step in the <strong>R</strong> code below all clusters in the finite representation of the population are constructed. This is done by computing the interaction of three factors:</p>
<ol style="list-style-type: decimal">
<li>the modulus of the s1-coordinates and the spacing of units within a transect (cluster) (computed with operator <code>%%</code>);</li>
<li>the s2-coordinates of the cells of the discretisation grid; and</li>
<li>the zones of the grid cells.</li>
</ol>
<p>Factor 1 has four levels, as the modulus of the s1-coordinates and a spacing of 100 has four possible values: 0, 25, 50, and 75. The cluster-id is added to the sampling frame. Each unit belongs exactly to one cluster.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="Cl.html#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="co">#compute local coordinates</span></span>
<span id="cb94-2"><a href="Cl.html#cb94-2" aria-hidden="true" tabindex="-1"></a>s1local <span class="ot">&lt;-</span> grdVoorst<span class="sc">$</span>s1 <span class="sc">-</span> <span class="fu">min</span>(grdVoorst<span class="sc">$</span>s1)</span>
<span id="cb94-3"><a href="Cl.html#cb94-3" aria-hidden="true" tabindex="-1"></a>s2local <span class="ot">&lt;-</span> grdVoorst<span class="sc">$</span>s2 <span class="sc">-</span> <span class="fu">min</span>(grdVoorst<span class="sc">$</span>s2)</span>
<span id="cb94-4"><a href="Cl.html#cb94-4" aria-hidden="true" tabindex="-1"></a>spacing <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb94-5"><a href="Cl.html#cb94-5" aria-hidden="true" tabindex="-1"></a>mods1 <span class="ot">&lt;-</span> s1local <span class="sc">%%</span> spacing</span>
<span id="cb94-6"><a href="Cl.html#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="co">#construct clusters (E-W oriented transects within zones)</span></span>
<span id="cb94-7"><a href="Cl.html#cb94-7" aria-hidden="true" tabindex="-1"></a>grdVoorst<span class="sc">$</span>cluster <span class="ot">&lt;-</span> <span class="fu">interaction</span>(</span>
<span id="cb94-8"><a href="Cl.html#cb94-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.factor</span>(mods1),</span>
<span id="cb94-9"><a href="Cl.html#cb94-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.factor</span>(s2local),</span>
<span id="cb94-10"><a href="Cl.html#cb94-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.factor</span>(grdVoorst<span class="sc">$</span>zone)) <span class="sc">%&gt;%</span>  <span class="fu">as.character</span>(.)</span>
<span id="cb94-11"><a href="Cl.html#cb94-11" aria-hidden="true" tabindex="-1"></a>M_cl <span class="ot">&lt;-</span> <span class="fu">tapply</span>(grdVoorst<span class="sc">$</span>z, <span class="at">INDEX =</span> grdVoorst<span class="sc">$</span>cluster, <span class="at">FUN =</span> length)</span>
<span id="cb94-12"><a href="Cl.html#cb94-12" aria-hidden="true" tabindex="-1"></a>grdVoorst<span class="sc">$</span>unit <span class="ot">&lt;-</span> <span class="fu">seq_len</span>(<span class="fu">nrow</span>(grdVoorst))</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:clustersize"></span>
<img src="SpatialSampling_files/figure-html/clustersize-1.png" alt="Frequency distribution of the size of clusters in Voorst. Clusters are E-W oriented transects within zones, with a spacing of 100 m between units." width="80%" />
<p class="caption">
Figure 6.1: Frequency distribution of the size of clusters in Voorst. Clusters are E-W oriented transects within zones, with a spacing of 100 m between units.
</p>
</div>
<p>In total there are 960 clusters in the population. Figure <a href="Cl.html#fig:clustersize">6.1</a> shows the frequency distribution of the size of the clusters.</p>
<p>Clusters are selected with probabilities proportional to their size and with replacement (ppswr). So, the sizes of all clusters must be known, which explains that all clusters must be enumerated. Selection of clusters by ppswr can be done by simple random sampling with replacement of elementary units (centres of grid cells) and identifying the clusters to which these units belong. Finally, all units of the selected clusters are included in the sample. In the code chunk below a function is defined for selecting clusters by ppswr. Note variable <code>cldraw</code>, that has value 1 for all units selected in the first draw, value 2 for all units selected in the second draw, etc. This variable is needed in estimating the population mean, as explained in Section <a href="Cl.html#clustersamplingestimators">6.1</a>.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="Cl.html#cb95-1" aria-hidden="true" tabindex="-1"></a>cl_ppswr <span class="ot">&lt;-</span> <span class="cf">function</span>(sframe, n) {</span>
<span id="cb95-2"><a href="Cl.html#cb95-2" aria-hidden="true" tabindex="-1"></a>  units <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(sframe), <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb95-3"><a href="Cl.html#cb95-3" aria-hidden="true" tabindex="-1"></a>  units_cl <span class="ot">&lt;-</span> sframe<span class="sc">$</span>cluster[units]</span>
<span id="cb95-4"><a href="Cl.html#cb95-4" aria-hidden="true" tabindex="-1"></a>  mysamples <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb95-5"><a href="Cl.html#cb95-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_len</span>(<span class="fu">length</span>(units_cl))) {</span>
<span id="cb95-6"><a href="Cl.html#cb95-6" aria-hidden="true" tabindex="-1"></a>    mysample <span class="ot">&lt;-</span> sframe[sframe<span class="sc">$</span>cluster <span class="sc">%in%</span> units_cl[i], ]</span>
<span id="cb95-7"><a href="Cl.html#cb95-7" aria-hidden="true" tabindex="-1"></a>    mysample<span class="sc">$</span>start <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb95-8"><a href="Cl.html#cb95-8" aria-hidden="true" tabindex="-1"></a>    mysample<span class="sc">$</span>start[mysample<span class="sc">$</span>unit <span class="sc">%in%</span> units[i]] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb95-9"><a href="Cl.html#cb95-9" aria-hidden="true" tabindex="-1"></a>    mysample<span class="sc">$</span>cldraw <span class="ot">&lt;-</span> <span class="fu">rep</span>(i, <span class="fu">nrow</span>(mysample))</span>
<span id="cb95-10"><a href="Cl.html#cb95-10" aria-hidden="true" tabindex="-1"></a>    mysamples <span class="ot">&lt;-</span> <span class="fu">rbind</span>(mysamples, mysample)</span>
<span id="cb95-11"><a href="Cl.html#cb95-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb95-12"><a href="Cl.html#cb95-12" aria-hidden="true" tabindex="-1"></a>  mysamples</span>
<span id="cb95-13"><a href="Cl.html#cb95-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Function <code>cl_ppswr</code> is now used to select six times a cluster by ppswr.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="Cl.html#cb96-1" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">6</span></span>
<span id="cb96-2"><a href="Cl.html#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">314</span>)</span>
<span id="cb96-3"><a href="Cl.html#cb96-3" aria-hidden="true" tabindex="-1"></a>mysample <span class="ot">&lt;-</span> <span class="fu">cl_ppswr</span>(<span class="at">sframe =</span> grdVoorst, <span class="at">n =</span> n)</span></code></pre></div>
<p>As our population actually is infinite, the centres of the selected grid cells are jittered to a random point within the selected grid cells. Note that the same noise is added to all units of a given cluster.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="Cl.html#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n) {</span>
<span id="cb97-2"><a href="Cl.html#cb97-2" aria-hidden="true" tabindex="-1"></a>  units <span class="ot">&lt;-</span> <span class="fu">which</span>(mysample<span class="sc">$</span>cldraw <span class="sc">==</span> i)</span>
<span id="cb97-3"><a href="Cl.html#cb97-3" aria-hidden="true" tabindex="-1"></a>  mysample<span class="sc">$</span>s1[units] <span class="ot">&lt;-</span> mysample<span class="sc">$</span>s1[units] <span class="sc">+</span> <span class="fu">runif</span>(<span class="dv">1</span>, <span class="at">min =</span> <span class="sc">-</span><span class="fl">12.5</span>, <span class="at">max =</span> <span class="fl">12.5</span>)</span>
<span id="cb97-4"><a href="Cl.html#cb97-4" aria-hidden="true" tabindex="-1"></a>  mysample<span class="sc">$</span>s2[units] <span class="ot">&lt;-</span> mysample<span class="sc">$</span>s2[units] <span class="sc">+</span> <span class="fu">runif</span>(<span class="dv">1</span>, <span class="at">min =</span> <span class="sc">-</span><span class="fl">12.5</span>, <span class="at">max =</span> <span class="fl">12.5</span>)</span>
<span id="cb97-5"><a href="Cl.html#cb97-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Figure <a href="Cl.html#fig:ClVoorst">6.2</a> shows the selected sample. Note that in this case the second west-most zone has two transects (clusters) whereas one zone has none, showing that the zones are not used as strata. The total number of selected points equals 50. Similar to systematic random sampling, with cluster random sampling the total sample size is random, so that we do not have perfect control of the total sample size. This is because in this case the size (number of points) of the clusters is not constant but varies.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:ClVoorst"></span>
<img src="SpatialSampling_files/figure-html/ClVoorst-1.png" alt="Cluster random sample from Voorst selected by ppswr." width="100%" />
<p class="caption">
Figure 6.2: Cluster random sample from Voorst selected by ppswr.
</p>
</div>
<p>The output data frame of function <code>cl</code> has a column named <code>start</code>. This is an indicator with value 1 if this point of the cluster is selected first, and 0 otherwise. When in the field it appears that the first selected point of a cluster does not belong to the target population, all other points of that cluster are also discarded. This is to keep the selection probabilities of the clusters exactly proportional to their size. Column <code>cldraw</code> is needed in estimation because clusters are selected with replacement. In case a cluster is selected more than once, multiple means of that cluster are used in estimation, see next section.</p>
<div id="clustersamplingestimators" class="section level2" number="6.1">
<h2><span class="header-section-number">6.1</span> Estimation of population parameters</h2>
<p>With ppswr sampling of clusters, the population total can be estimated by the pwr estimator:</p>
<p><span class="math display" id="eq:EstTotalCl1">\[\begin{equation}
\hat{t}(z) = \frac{1}{n}\sum_{j \in \mathcal{S}} \frac{t_{j}(z)}{p_{j}} \;,
\tag{6.1}
\end{equation}\]</span></p>
<p>with <span class="math inline">\(n\)</span> the number of cluster draws, <span class="math inline">\(p_j\)</span> the draw-by-draw selection probability of cluster <span class="math inline">\(j\)</span>, and <span class="math inline">\(t_j(z)\)</span> the total of cluster <span class="math inline">\(j\)</span>:</p>
<p><span class="math display" id="eq:clustertotal">\[\begin{equation}
t_j(z) = \sum_{k=1}^{M_j} z_{kj} \;,
\tag{6.2}
\end{equation}\]</span></p>
<p>with <span class="math inline">\(M_j\)</span> the size (number of units) of cluster <span class="math inline">\(j\)</span> and <span class="math inline">\(z_{kj}\)</span> the study variable value of unit <span class="math inline">\(k\)</span> in cluster <span class="math inline">\(j\)</span>.</p>
<p>The draw-by-draw selection probability of a cluster equals</p>
<p><span class="math display" id="eq:drawbydraw">\[\begin{equation}
p_{j} = \frac{M_j}{M} \;,
\tag{6.3}
\end{equation}\]</span></p>
<p>with <span class="math inline">\(M\)</span> the total number of population units (for Voorst <span class="math inline">\(M\)</span> equals 7,528). Inserting this in Equation <a href="Cl.html#eq:EstTotalCl1">(6.1)</a> yields</p>
<p><span class="math display" id="eq:EstTotalCl">\[\begin{equation}
\hat{t}(z) = \frac{M}{n} \sum_{j \in \mathcal{S}} \frac{t_{j}(z)}{M_{j}} = \frac{M}{n} \sum_{j \in \mathcal{S}} \bar{z}_{j} \;,
\tag{6.4}
\end{equation}\]</span></p>
<p>with <span class="math inline">\(\bar{z}_{j}\)</span> the mean of cluster <span class="math inline">\(j\)</span>. Note that if a cluster is selected more than once, multiple means of that cluster are used in the estimator.</p>
<p>Dividing this estimator by the total number of population units <span class="math inline">\(M\)</span>, yields the estimator of the population mean:</p>
<p><span class="math display" id="eq:EstMeanCl">\[\begin{equation}
\hat{\bar{\bar{z}}}=\frac{1}{n}\sum\limits_{j \in \mathcal{S}} \bar{z}_{j} \;.
\tag{6.5}
\end{equation}\]</span></p>
<p>Note the two bars in <span class="math inline">\(\hat{\bar{\bar{z}}}\)</span>, indicating that the observations are averaged twice.</p>
<p>For an infinite population of points discretised by the centres of a finite number of grid cells, <span class="math inline">\(z_{kj}\)</span> in Equation <a href="Cl.html#eq:clustertotal">(6.2)</a> is the study variable value at a randomly selected point within the grid cell multiplied by the area of the grid cell. The estimated population total thus obtained is equal to the estimated population mean (Equation <a href="Cl.html#eq:EstMeanCl">(6.5)</a>) multiplied by the area of the study area.</p>
<p>The sampling variance of the estimator of the mean with ppswr sampling of clusters is equal to (<span class="citation"><a href="#ref-coc77" role="doc-biblioref">Cochran</a> (<a href="#ref-coc77" role="doc-biblioref">1977</a>)</span>, Equation (9A.6))</p>
<p><span class="math display" id="eq:TrueVarEstMeanCl">\[\begin{equation}
V(\hat{\bar{\bar{z}}})= \frac{1}{n}\sum_{j=1}^N \frac{M_j}{M} (\bar{z}_j-\bar{z})^2  \;,
\tag{6.6}
\end{equation}\]</span></p>
<p>with <span class="math inline">\(N\)</span> the total number of clusters (for Voorst, <span class="math inline">\(N=960\)</span>), <span class="math inline">\(\bar{z}_j\)</span> the mean of cluster <span class="math inline">\(j\)</span>, and <span class="math inline">\(\bar{z}\)</span> the population mean. Note that <span class="math inline">\(M_j/M\)</span> is the selection probability of cluster <span class="math inline">\(j\)</span>.</p>
<p>This sampling variance can be estimated by (<span class="citation"><a href="#ref-coc77" role="doc-biblioref">Cochran</a> (<a href="#ref-coc77" role="doc-biblioref">1977</a>)</span>, Equation (9A.22))</p>
<p><span class="math display" id="eq:VarEstMeanCl">\[\begin{equation}
\widehat{V}\!\left(\hat{\bar{\bar{z}}}\right)=\frac{\widehat{S^2}(\bar{z})}{n} \;,
\tag{6.7}
\end{equation}\]</span></p>
<p>where <span class="math inline">\(\widehat{S^2}(\bar{z})\)</span> is the estimated variance of cluster means (the between-cluster variance):</p>
<p><span class="math display" id="eq:S2EstMeanCl">\[\begin{equation}
\widehat{S^2}(\bar{z}) = \frac{1}{n-1}\sum_{j \in \mathcal{S}}(\bar{z}_{j}-\hat{\bar{\bar{z}}})^2 \;.
\tag{6.8}
\end{equation}\]</span></p>
<p>In <strong>R</strong> the population mean and the sampling variance of the estimator of the population means can be estimated as follows.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="Cl.html#cb98-1" aria-hidden="true" tabindex="-1"></a>mz_cl <span class="ot">&lt;-</span> <span class="fu">tapply</span>(</span>
<span id="cb98-2"><a href="Cl.html#cb98-2" aria-hidden="true" tabindex="-1"></a>  mysample<span class="sc">$</span>z, <span class="at">INDEX =</span> mysample<span class="sc">$</span>cldraw, <span class="at">FUN =</span> mean)</span>
<span id="cb98-3"><a href="Cl.html#cb98-3" aria-hidden="true" tabindex="-1"></a>mz <span class="ot">&lt;-</span> <span class="fu">mean</span>(mz_cl)</span>
<span id="cb98-4"><a href="Cl.html#cb98-4" aria-hidden="true" tabindex="-1"></a>se_mz <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">var</span>(mz_cl) <span class="sc">/</span> n)</span></code></pre></div>
<p>The estimated mean equals 87.1 g kg<sup>-1</sup>, and the estimated standard error equals 17.4 g kg<sup>-1</sup>. Note that the size of the clusters (number of units) does not appear in these formulas. This simplicity is due to the fact that the clusters are selected with probabilities proportional to size. The effect of the cluster size on the variance is implicitly accounted for. To understand this, consider that larger clusters result in smaller variance among their means.</p>
<p>The same estimates are obtained with functions <code>svydesign</code> and <code>svymean</code> of package <strong>survey</strong> <span class="citation">(<a href="#ref-Lumley2020" role="doc-biblioref">Lumley 2021</a>)</span>. Argument <code>weights</code> specifies the weights of the sampled clusters equal to <span class="math inline">\(M/(M_j\; n)\)</span> (Equation <a href="Cl.html#eq:EstTotalCl">(6.4)</a>).</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb99-1"><a href="Cl.html#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(survey)</span>
<span id="cb99-2"><a href="Cl.html#cb99-2" aria-hidden="true" tabindex="-1"></a>M <span class="ot">&lt;-</span> <span class="fu">nrow</span>(grdVoorst)</span>
<span id="cb99-3"><a href="Cl.html#cb99-3" aria-hidden="true" tabindex="-1"></a>mysample<span class="sc">$</span>weights <span class="ot">&lt;-</span> M <span class="sc">/</span> (M_cl[mysample<span class="sc">$</span>cluster] <span class="sc">*</span> n)</span>
<span id="cb99-4"><a href="Cl.html#cb99-4" aria-hidden="true" tabindex="-1"></a>design_cluster <span class="ot">&lt;-</span> <span class="fu">svydesign</span>(<span class="at">id =</span> <span class="sc">~</span> cldraw, <span class="at">weights =</span> <span class="sc">~</span> weights, <span class="at">data =</span> mysample)</span>
<span id="cb99-5"><a href="Cl.html#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="fu">svymean</span>(<span class="sc">~</span> z, design_cluster, <span class="at">deff =</span> <span class="st">&quot;replace&quot;</span>)</span></code></pre></div>
<pre><code>    mean     SE   DEff
z 87.077 17.428 4.0767</code></pre>
<p>The design effect <code>DEff</code> as estimated from the selected cluster sample is considerably larger than 1. About 4 times more sampling points are needed with cluster random sampling compared to simple random sampling to estimate the population mean with the same precision.</p>
<p>A confidence interval estimate of the population mean can be computed with method <code>confint</code>. The number of degrees of freedom equals the number of cluster draws minus 1.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb101-1"><a href="Cl.html#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="fu">confint</span>(<span class="fu">svymean</span>(<span class="sc">~</span> z, design_cluster, <span class="at">df =</span> <span class="fu">degf</span>(design_cluster), <span class="at">level =</span> <span class="fl">0.95</span>))</span></code></pre></div>
<pre><code>     2.5 %   97.5 %
z 52.91908 121.2347</code></pre>
<p>Figure <a href="Cl.html#fig:SamplingDistributionCl">6.3</a> shows the approximated sampling distribution of the pwr estimator of the mean soil organic matter (SOM) concentration with cluster random sampling and of the <span class="math inline">\(\pi\)</span> estimator with simple random sampling, obtained by repeating the random sampling with each design and estimation 10,000 times. The size of the simple random samples is equal to the expected sample size of the cluster random sampling design (rounded to nearest integer).</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:SamplingDistributionCl"></span>
<img src="SpatialSampling_files/figure-html/SamplingDistributionCl-1.png" alt="Approximated sampling distribution of the pwr estimator of the mean SOM concentration (g kg-1) in Voorst with cluster random sampling (Cl) and of the \(\pi\) estimator with simple random sampling (SI). In Cl six clusters are selected by ppswr. The (expected) sample size is 49 units." width="80%" />
<p class="caption">
Figure 6.3: Approximated sampling distribution of the pwr estimator of the mean SOM concentration (g kg<sup>-1</sup>) in Voorst with cluster random sampling (Cl) and of the <span class="math inline">\(\pi\)</span> estimator with simple random sampling (SI). In Cl six clusters are selected by ppswr. The (expected) sample size is 49 units.
</p>
</div>
<p>The variance of the 10,000 estimated population means with cluster random sampling equals 126.2 (g kg<sup>-1</sup>)<sup>2</sup>. This is considerably larger than with simple random sampling: 44.8 (g kg<sup>-1</sup>)<sup>2</sup>. The large variance is caused by the strong spatial clustering of points. This may save travel time in large study areas, but in Voorst the saved travel time will be very limited, and therefore cluster random sampling in Voorst is not a good idea. The average of the estimated variances with cluster random sampling equals 125.9 (g kg<sup>-1</sup>)<sup>2</sup>. The difference with the variance of the 10,000 estimated means is small because the estimator of the variance, Equation <a href="Cl.html#eq:VarEstMeanCl">(6.7)</a>, is unbiased. Figure <a href="Cl.html#fig:histsamplesizeCl">6.4</a> shows the approximated sampling distribution of the sample size. The expected sample size can be computed as follows:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="Cl.html#cb103-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> M_cl <span class="sc">/</span> <span class="fu">sum</span>(M_cl)</span>
<span id="cb103-2"><a href="Cl.html#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(m_n <span class="ot">&lt;-</span> n <span class="sc">*</span> <span class="fu">sum</span>(p <span class="sc">*</span> M_cl))</span></code></pre></div>
<pre><code>[1] 49.16844</code></pre>
<p>So, the unequal draw-by-draw selection probabilities of the clusters are accounted for in computing the expected sample size.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:histsamplesizeCl"></span>
<img src="SpatialSampling_files/figure-html/histsamplesizeCl-1.png" alt="Approximated sampling distribution of the sample size with cluster random sampling from Voorst, for six clusters selected by ppswr." width="80%" />
<p class="caption">
Figure 6.4: Approximated sampling distribution of the sample size with cluster random sampling from Voorst, for six clusters selected by ppswr.
</p>
</div>
<div id="exercises-9" class="section level4 unnumbered">
<h4>Exercises</h4>
<ol style="list-style-type: decimal">
<li>Write an <strong>R</strong> script to compute the true sampling variance of the estimator of the mean SOM concentration in Voorst for cluster random sampling and clusters selected with ppswr, <span class="math inline">\(n = 6\)</span>, see Equation <a href="Cl.html#eq:TrueVarEstMeanCl">(6.6)</a>. Compare the sampling variance for cluster random sampling with the sampling variance for simple random sampling with a sample size equal to the expected sample size of cluster random sampling.<br />
</li>
<li>As an alternative we may select three times a transect, using three 2 km <span class="math inline">\(\times\)</span> 1 km zones obtained by joining two neighbouring 1 km <span class="math inline">\(\times\)</span> 1 km zones of Figure <a href="Cl.html#fig:ClVoorst">6.2</a>. Do you expect that the sampling variance of the estimator of the population mean is equal to, larger or smaller than that of the sampling design with six transects of half the length?</li>
</ol>
</div>
</div>
<div id="clusters-selected-with-probabilities-proportional-to-size-without-replacement" class="section level2" number="6.2">
<h2><span class="header-section-number">6.2</span> Clusters selected with probabilities proportional to size, without replacement</h2>
<p>In the previous section the clusters were selected with replacement (ppswr). The advantage of with replacement sampling is that this keeps the statistical inference simple, more specifically the estimation of the standard error of the estimator of the population mean. However, in sampling from finite populations, cluster sampling with replacement is less efficient than cluster sampling without replacement, especially with large sampling fractions of clusters, i.e. if <span class="math inline">\(1-n/N\)</span> is small, with <span class="math inline">\(N\)</span> being the total number of clusters and <span class="math inline">\(n\)</span> the sample size, i.e. the number of cluster draws. If a cluster is selected more than once, there is less information about the population mean in this sample than in a sample with all clusters different. Selection of clusters with probabilities proportional to size without replacement (ppswor) is not straightforward.</p>

<div class="rmdnote">
The problem is the computation of the inclusion probabilities of the clusters. After we have selected a first cluster, we must adapt the sum of the sizes of the <span class="math inline">\(N-1\)</span> remaining clusters and recompute the selection probabilities of the remaining clusters in the second draw, etc. Section 6.4 of <span class="citation"><a href="#ref-loh99" role="doc-biblioref">Lohr</a> (<a href="#ref-loh99" role="doc-biblioref">1999</a>)</span> nicely describes how the inclusion probabilities of the <span class="math inline">\(N\)</span> clusters in a cluster random sample of size two, selected by ppswor, can be computed.
</div>
<p>Many algorithms have been developed for ppswor sampling, see <span class="citation"><a href="#ref-Tille2006" role="doc-biblioref">Tillé</a> (<a href="#ref-Tille2006" role="doc-biblioref">2006</a>)</span> for an overview, and quite a few of them are implemented in package <strong>sampling</strong> <span class="citation">(<a href="#ref-Tille2016" role="doc-biblioref">Tillé and Matei 2021</a>)</span>. In the next code chunk function <code>UPpivotal</code> is used to select a cluster random sample with ppswor. For an explanation of this algorithm, see Subsection <a href="pps.html#pivotalmethod">8.2.2</a>.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="Cl.html#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sampling)</span>
<span id="cb105-2"><a href="Cl.html#cb105-2" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">6</span></span>
<span id="cb105-3"><a href="Cl.html#cb105-3" aria-hidden="true" tabindex="-1"></a>pi <span class="ot">&lt;-</span> n <span class="sc">*</span> M_cl <span class="sc">/</span> M</span>
<span id="cb105-4"><a href="Cl.html#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">314</span>)</span>
<span id="cb105-5"><a href="Cl.html#cb105-5" aria-hidden="true" tabindex="-1"></a>eps <span class="ot">&lt;-</span> <span class="fl">1e-6</span></span>
<span id="cb105-6"><a href="Cl.html#cb105-6" aria-hidden="true" tabindex="-1"></a>sampleind <span class="ot">&lt;-</span> <span class="fu">UPpivotal</span>(<span class="at">pik =</span> pi, <span class="at">eps =</span> eps)</span>
<span id="cb105-7"><a href="Cl.html#cb105-7" aria-hidden="true" tabindex="-1"></a>clusters <span class="ot">&lt;-</span> <span class="fu">sort</span>(<span class="fu">unique</span>(grdVoorst<span class="sc">$</span>cluster))</span>
<span id="cb105-8"><a href="Cl.html#cb105-8" aria-hidden="true" tabindex="-1"></a>sampledclusters <span class="ot">&lt;-</span> clusters[sampleind <span class="sc">==</span> <span class="dv">1</span>]</span>
<span id="cb105-9"><a href="Cl.html#cb105-9" aria-hidden="true" tabindex="-1"></a>mysample <span class="ot">&lt;-</span> grdVoorst[grdVoorst<span class="sc">$</span>cluster <span class="sc">%in%</span> sampledclusters, ]</span></code></pre></div>
<p>The population mean can be estimated by the <span class="math inline">\(\pi\)</span> estimator by writing a few lines of <strong>R</strong> code yourself or by using function <code>svymean</code> of package <strong>survey</strong> as shown hereafter. Estimation of the sampling variance in pps sampling of clusters without replacement is difficult<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. A simple solution is to treat the cluster sample as a ppswr sample and to estimate the variance with Equation <a href="Cl.html#eq:VarEstMeanCl">(6.7)</a>. With small sampling fractions this variance approximation is fine: the overestimation of the variance is negligible. For larger sampling fractions various alternative variance approximations are developed, see <span class="citation"><a href="#ref-Berger2004" role="doc-biblioref">Berger</a> (<a href="#ref-Berger2004" role="doc-biblioref">2004</a>)</span> for details. One of the methods is Brewer’s method, which is implemented in function <code>svydesign</code>.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb106-1"><a href="Cl.html#cb106-1" aria-hidden="true" tabindex="-1"></a>mysample<span class="sc">$</span>pi <span class="ot">&lt;-</span> n <span class="sc">*</span> M_cl[mysample<span class="sc">$</span>cluster] <span class="sc">/</span> M</span>
<span id="cb106-2"><a href="Cl.html#cb106-2" aria-hidden="true" tabindex="-1"></a>design_clppswor <span class="ot">&lt;-</span> <span class="fu">svydesign</span>(</span>
<span id="cb106-3"><a href="Cl.html#cb106-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> <span class="sc">~</span> cluster, <span class="at">data =</span> mysample, <span class="at">pps =</span> <span class="st">&quot;brewer&quot;</span>, <span class="at">fpc =</span> <span class="sc">~</span> pi)</span>
<span id="cb106-4"><a href="Cl.html#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="fu">svymean</span>(<span class="sc">~</span> z, design_clppswor)</span></code></pre></div>
<pre><code>   mean     SE
z 96.83 13.454</code></pre>
<p>Another variance estimator implemented in function <code>svydesign</code> is the Hartley-Rao estimator. The two estimated standard errors are nearly equal.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb108-1"><a href="Cl.html#cb108-1" aria-hidden="true" tabindex="-1"></a>p2sum <span class="ot">&lt;-</span> <span class="fu">sum</span>((n <span class="sc">*</span> M_cl[mysample<span class="sc">$</span>cluster] <span class="sc">/</span> M)<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> n</span>
<span id="cb108-2"><a href="Cl.html#cb108-2" aria-hidden="true" tabindex="-1"></a>design_hr <span class="ot">&lt;-</span> <span class="fu">svydesign</span>(</span>
<span id="cb108-3"><a href="Cl.html#cb108-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> <span class="sc">~</span> cluster,  <span class="at">data =</span> mysample, <span class="at">pps =</span> <span class="fu">HR</span>(p2sum), <span class="at">fpc =</span> <span class="sc">~</span> pi)</span>
<span id="cb108-4"><a href="Cl.html#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="fu">svymean</span>(<span class="sc">~</span> z, design_hr)</span></code></pre></div>
<pre><code>   mean     SE
z 96.83 13.436</code></pre>
</div>
<div id="SIC" class="section level2" number="6.3">
<h2><span class="header-section-number">6.3</span> Simple random sampling of clusters</h2>
<p>Suppose the clusters have unequal size, but we do not know the size of the clusters, so that we cannot select the clusters with probabilities proportional to their size. In this case we may select the clusters by simple random sampling without replacement. The inclusion probability of a cluster equals <span class="math inline">\(n/N\)</span> with <span class="math inline">\(n\)</span> the number of selected clusters and <span class="math inline">\(N\)</span> the total number of clusters in the population. This yields the following <span class="math inline">\(\pi\)</span> estimator of the population total:</p>
<p><span class="math display" id="eq:EstTotalClEqual">\[\begin{equation}
\hat{t}(z) = \frac{N}{n} \sum_{j \in \mathcal{S}} t_{j}(z)\;.
\tag{6.9}
\end{equation}\]</span></p>
<p>The population mean can be estimated by dividing this estimator of the population total by the total number of units in the population <span class="math inline">\(M\)</span>:</p>
<p><span class="math display" id="eq:EstMeanHTClEqual">\[\begin{equation}
\hat{\bar{\bar{z}}}_{\pi}(z) = \frac{\hat{t}(z)}{M}\;.
\tag{6.10}
\end{equation}\]</span></p>
<p>Alternatively, we may estimate the population mean by dividing the estimate of the population total by the <em>estimated</em> population size:</p>
<p><span class="math display" id="eq:EstPopulatonSizeClEqual">\[\begin{equation}
\widehat{M} = \sum_{j \in \mathcal{S}} \frac{M_{j}}{\pi_{j}} = \frac{N}{n} \sum_{j \in \mathcal{S}} M_{j} \;.
\tag{6.11}
\end{equation}\]</span></p>
<p>This leads to the ratio estimator of the population mean:</p>
<p><span class="math display" id="eq:EstMeanRatioClEqual">\[\begin{equation}
\hat{\bar{\bar{z}}}_{\text{ratio}}(z) = \frac{\hat{t}(z)}{\widehat{M}} \;.
\tag{6.12}
\end{equation}\]</span></p>
<p>The <span class="math inline">\(\pi\)</span> estimator and the ratio estimator are equal when the clusters are selected with probabilities proportional to size. This is because the estimated population size is equal to the true population size.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb110-1"><a href="Cl.html#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(M_HT <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="dv">1</span> <span class="sc">/</span> mysample<span class="sc">$</span>pi))</span></code></pre></div>
<pre><code>[1] 7528</code></pre>
<p>However, when clusters of different size are selected with equal probabilities, the two estimators are different. This is shown below. Six clusters are selected by simple random sampling without replacement.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="Cl.html#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">314</span>)</span>
<span id="cb112-2"><a href="Cl.html#cb112-2" aria-hidden="true" tabindex="-1"></a>clusters <span class="ot">&lt;-</span> <span class="fu">sort</span>(<span class="fu">unique</span>(grdVoorst<span class="sc">$</span>cluster))</span>
<span id="cb112-3"><a href="Cl.html#cb112-3" aria-hidden="true" tabindex="-1"></a>units_cl <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">length</span>(clusters), <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb112-4"><a href="Cl.html#cb112-4" aria-hidden="true" tabindex="-1"></a>sampledclusters <span class="ot">&lt;-</span> clusters[units_cl]</span>
<span id="cb112-5"><a href="Cl.html#cb112-5" aria-hidden="true" tabindex="-1"></a>mysample <span class="ot">&lt;-</span> grdVoorst[grdVoorst<span class="sc">$</span>cluster <span class="sc">%in%</span> sampledclusters, ]</span></code></pre></div>
<p>The <span class="math inline">\(\pi\)</span> estimate and the ratio estimate of the population mean are computed for the selected sample.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb113-1"><a href="Cl.html#cb113-1" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="fu">length</span>(clusters)</span>
<span id="cb113-2"><a href="Cl.html#cb113-2" aria-hidden="true" tabindex="-1"></a>mysample<span class="sc">$</span>pi <span class="ot">&lt;-</span> n <span class="sc">/</span> N</span>
<span id="cb113-3"><a href="Cl.html#cb113-3" aria-hidden="true" tabindex="-1"></a>tz_HT <span class="ot">&lt;-</span> <span class="fu">sum</span>(mysample<span class="sc">$</span>z <span class="sc">/</span> mysample<span class="sc">$</span>pi)</span>
<span id="cb113-4"><a href="Cl.html#cb113-4" aria-hidden="true" tabindex="-1"></a>mz_HT <span class="ot">&lt;-</span> tz_HT <span class="sc">/</span> M</span>
<span id="cb113-5"><a href="Cl.html#cb113-5" aria-hidden="true" tabindex="-1"></a>M_HT <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="dv">1</span> <span class="sc">/</span> mysample<span class="sc">$</span>pi)</span>
<span id="cb113-6"><a href="Cl.html#cb113-6" aria-hidden="true" tabindex="-1"></a>mz_ratio <span class="ot">&lt;-</span> tz_HT <span class="sc">/</span> M_HT</span></code></pre></div>
<p>The <span class="math inline">\(\pi\)</span> estimate equals 68.750 g kg<sup>-1</sup>, and the ratio estimate equals 70.319 g kg<sup>-1</sup>. The <span class="math inline">\(\pi\)</span> estimate of the population mean can also be computed by first computing totals of clusters, see Equations <a href="Cl.html#eq:EstTotalClEqual">(6.9)</a> and <a href="Cl.html#eq:EstMeanHTClEqual">(6.10)</a>.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="Cl.html#cb114-1" aria-hidden="true" tabindex="-1"></a>tz_cluster <span class="ot">&lt;-</span> <span class="fu">tapply</span>(mysample<span class="sc">$</span>z, <span class="at">INDEX =</span> mysample<span class="sc">$</span>cluster, <span class="at">FUN =</span> sum)</span>
<span id="cb114-2"><a href="Cl.html#cb114-2" aria-hidden="true" tabindex="-1"></a>pi_cluster <span class="ot">&lt;-</span> n <span class="sc">/</span> N</span>
<span id="cb114-3"><a href="Cl.html#cb114-3" aria-hidden="true" tabindex="-1"></a>tz_HT <span class="ot">&lt;-</span> <span class="fu">sum</span>(tz_cluster <span class="sc">/</span> pi_cluster)</span>
<span id="cb114-4"><a href="Cl.html#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(mz_HT <span class="ot">&lt;-</span> tz_HT <span class="sc">/</span> M)</span></code></pre></div>
<pre><code>[1] 68.74994</code></pre>
<p>The variance of the <span class="math inline">\(\pi\)</span> estimator of the population mean can be estimated by first estimating the variance of the estimator of the total:</p>
<p><span class="math display" id="eq:EstVarTotalHTClequal">\[\begin{equation}
\widehat{V}(\hat{t}(z)) = N^2\left(1-\frac{n}{N}\right)\frac{\widehat{S^2}(t(z))}{n}
\tag{6.13}
\;,
\end{equation}\]</span></p>
<p>and dividing this variance by the squared number of population units:</p>
<p><span class="math display" id="eq:EstVarMeanHTClequal">\[\begin{equation}
\widehat{V}(\hat{\bar{\bar{z}}}) = \frac{1}{M^2} \widehat{V}(\hat{t}(z)) \;.
\tag{6.14}
\end{equation}\]</span></p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="Cl.html#cb116-1" aria-hidden="true" tabindex="-1"></a>fpc <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> n <span class="sc">/</span> N</span>
<span id="cb116-2"><a href="Cl.html#cb116-2" aria-hidden="true" tabindex="-1"></a>v_tz <span class="ot">&lt;-</span> N<span class="sc">^</span><span class="dv">2</span> <span class="sc">*</span> fpc <span class="sc">*</span> <span class="fu">var</span>(tz_cluster) <span class="sc">/</span> n</span>
<span id="cb116-3"><a href="Cl.html#cb116-3" aria-hidden="true" tabindex="-1"></a>se_mz_HT <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(v_tz <span class="sc">/</span> M<span class="sc">^</span><span class="dv">2</span>)</span></code></pre></div>
<p>The estimated standard error equals 11.5 g kg<sup>-1</sup>.</p>
<p>To compute the variance of the ratio estimator of the population mean we first compute residuals of cluster totals:</p>
<p><span class="math display" id="eq:residualsclustertotals">\[\begin{equation}
e_j = t_j(z)-\hat{b}M_j \;,
\tag{6.15}
\end{equation}\]</span></p>
<p>with <span class="math inline">\(\hat{b}\)</span> the ratio of the estimated population mean of the cluster totals to the estimated population mean of the cluster sizes:</p>
<p><span class="math display" id="eq:ratioclustertotalclustersize">\[\begin{equation}
\hat{b}=\frac{\frac{1}{n}\sum_{j \in \mathcal{S}} t_{j}}{\frac{1}{n}\sum_{j \in \mathcal{S}} M_{j}} \;.
\tag{6.16}
\end{equation}\]</span></p>
<p>The variance of the ratio estimator of the population mean can be estimated by</p>
<p><span class="math display" id="eq:varratioestimatormeanCl">\[\begin{equation}
\hat{V}(\hat{\bar{\bar{z}}}_{\text{ratio}})=\left(1-\frac{n}{N}\right)\frac{1}{(\frac{1}{n}\sum_{j \in \mathcal{S}} M_{j})^2}\frac{\widehat{S^2}_e}{n} \;,
\tag{6.17}
\end{equation}\]</span></p>
<p>with <span class="math inline">\(\widehat{S^2}_e\)</span> the estimated variance of the residuals.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb117-1"><a href="Cl.html#cb117-1" aria-hidden="true" tabindex="-1"></a>m_M_cl <span class="ot">&lt;-</span> <span class="fu">mean</span>(M_cl[<span class="fu">unique</span>(mysample<span class="sc">$</span>cluster)])</span>
<span id="cb117-2"><a href="Cl.html#cb117-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">mean</span>(tz_cluster) <span class="sc">/</span> m_M_cl</span>
<span id="cb117-3"><a href="Cl.html#cb117-3" aria-hidden="true" tabindex="-1"></a>e_cl <span class="ot">&lt;-</span> tz_cluster <span class="sc">-</span> b <span class="sc">*</span> M_cl[<span class="fu">sort</span>(<span class="fu">unique</span>(mysample<span class="sc">$</span>cluster))]</span>
<span id="cb117-4"><a href="Cl.html#cb117-4" aria-hidden="true" tabindex="-1"></a>S2e <span class="ot">&lt;-</span> <span class="fu">var</span>(e_cl)</span>
<span id="cb117-5"><a href="Cl.html#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(se_mz_ratio <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(fpc <span class="sc">*</span> <span class="dv">1</span> <span class="sc">/</span> m_M_cl<span class="sc">^</span><span class="dv">2</span> <span class="sc">*</span> S2e <span class="sc">/</span> n))</span></code></pre></div>
<pre><code>[1] 12.39371</code></pre>
<p>The ratio estimate can also be computed with function <code>svymean</code> of package <strong>survey</strong>, which also provides an estimate of the standard error of the estimated mean.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb119-1"><a href="Cl.html#cb119-1" aria-hidden="true" tabindex="-1"></a>design_SIC <span class="ot">&lt;-</span> <span class="fu">svydesign</span>(</span>
<span id="cb119-2"><a href="Cl.html#cb119-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> <span class="sc">~</span> cluster, <span class="at">probs =</span> <span class="sc">~</span> pi, <span class="at">fpc =</span> <span class="sc">~</span> pi, <span class="at">data =</span> mysample)</span>
<span id="cb119-3"><a href="Cl.html#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="fu">svymean</span>(<span class="sc">~</span> z, design_SIC)</span></code></pre></div>
<pre><code>    mean     SE
z 70.319 12.394</code></pre>
</div>
<div id="StratifiedCl" class="section level2" number="6.4">
<h2><span class="header-section-number">6.4</span> Stratified cluster random sampling</h2>
<p>The basic sampling designs stratified random sampling (Chapter <a href="STSI.html#STSI">4</a>) and cluster random sampling can be combined into stratified cluster random sampling. So, instead of selecting simple random samples from the strata, within each stratum clusters are randomly selected. Figure <a href="Cl.html#fig:STCl">6.5</a> shows a stratified cluster random sample from Voorst. The strata consist of three 2 km <span class="math inline">\(\times\)</span> 1 km zones, obtained by joining two neighbouring 1 km <span class="math inline">\(\times\)</span> 1 km zones (Figure <a href="Cl.html#fig:ClVoorst">6.2</a>). The clusters are the same as before, i.e. E-W oriented transects within 1 km <span class="math inline">\(\times\)</span> 1 km zones, with an inter-unit spacing of 100 m. Within each stratum two times a cluster is selected by ppswr. The stratification avoids the clustering of the selected transects in one part of the study area. Compared to (unstratified) cluster random sampling, the geographical spreading of the clusters is improved, which may lead to an increase of the precision of the estimated population mean. In Figure <a href="Cl.html#fig:STCl">6.5</a> in the most western stratum the two selected transects are in the same 1 km <span class="math inline">\(\times\)</span> 1 km zone. The alternative would be to use the six zones as strata, leading to an improved spreading of the clusters, but there is also a downside with this design, see Exercise 3. Note that the selection probabilities are now equal to</p>
<p><span class="math display" id="eq:drawbySTSICl">\[\begin{equation}
p_{jh}= M_j/M_h \;,
\tag{6.18}
\end{equation}\]</span>
with <span class="math inline">\(M_h\)</span> the total number of population units of stratum <span class="math inline">\(h\)</span>.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb121-1"><a href="Cl.html#cb121-1" aria-hidden="true" tabindex="-1"></a>grdVoorst<span class="sc">$</span>zonestratum <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(grdVoorst<span class="sc">$</span>zone)</span>
<span id="cb121-2"><a href="Cl.html#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="fu">levels</span>(grdVoorst<span class="sc">$</span>zonestratum) <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="at">each =</span> <span class="dv">2</span>)</span>
<span id="cb121-3"><a href="Cl.html#cb121-3" aria-hidden="true" tabindex="-1"></a>n_h <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb121-4"><a href="Cl.html#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">324</span>)</span>
<span id="cb121-5"><a href="Cl.html#cb121-5" aria-hidden="true" tabindex="-1"></a>stratumlabels <span class="ot">&lt;-</span> <span class="fu">unique</span>(grdVoorst<span class="sc">$</span>zonestratum)</span>
<span id="cb121-6"><a href="Cl.html#cb121-6" aria-hidden="true" tabindex="-1"></a>mysample <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb121-7"><a href="Cl.html#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) {</span>
<span id="cb121-8"><a href="Cl.html#cb121-8" aria-hidden="true" tabindex="-1"></a>  grd_h <span class="ot">&lt;-</span> grdVoorst[grdVoorst<span class="sc">$</span>zonestratum <span class="sc">==</span> stratumlabels[i], ]</span>
<span id="cb121-9"><a href="Cl.html#cb121-9" aria-hidden="true" tabindex="-1"></a>  mysample_h <span class="ot">&lt;-</span> <span class="fu">cl_ppswr</span>(<span class="at">sframe =</span> grd_h, <span class="at">n =</span> n_h[i])</span>
<span id="cb121-10"><a href="Cl.html#cb121-10" aria-hidden="true" tabindex="-1"></a>  mysample <span class="ot">&lt;-</span> <span class="fu">rbind</span>(mysample, mysample_h)</span>
<span id="cb121-11"><a href="Cl.html#cb121-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:STCl"></span>
<img src="SpatialSampling_files/figure-html/STCl-1.png" alt="Stratified cluster random sample from Voorst, with three strata. From each stratum two times a cluster is selected by ppswr." width="100%" />
<p class="caption">
Figure 6.5: Stratified cluster random sample from Voorst, with three strata. From each stratum two times a cluster is selected by ppswr.
</p>
</div>
<p>The population mean is estimated by first estimating the stratum means using Equation <a href="Cl.html#eq:EstMeanCl">(6.5)</a> at the level of the strata, followed by computing the weighted average of the estimated stratum means using Equation <a href="STSI.html#eq:HTMeanSTSI2">(4.3)</a>. The variance of the estimator of the population mean is estimated in the same way, by first estimating the variance of the estimator of the stratum means using Equations <a href="Cl.html#eq:VarEstMeanCl">(6.7)</a> and <a href="Cl.html#eq:S2EstMeanCl">(6.8)</a> at the level of the strata, followed by computing the weighted average of the estimated variances of the estimated stratum means (Equation <a href="STSI.html#eq:EstVarMeanSTSI">(4.4)</a>).</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb122-1"><a href="Cl.html#cb122-1" aria-hidden="true" tabindex="-1"></a>mz_h <span class="ot">&lt;-</span> v_mz_h <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="at">length =</span> <span class="dv">3</span>)</span>
<span id="cb122-2"><a href="Cl.html#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) {</span>
<span id="cb122-3"><a href="Cl.html#cb122-3" aria-hidden="true" tabindex="-1"></a>  units <span class="ot">&lt;-</span> <span class="fu">which</span>(mysample<span class="sc">$</span>zonestratum <span class="sc">==</span> letters[i])</span>
<span id="cb122-4"><a href="Cl.html#cb122-4" aria-hidden="true" tabindex="-1"></a>  mysample_h <span class="ot">&lt;-</span> mysample[units, ]</span>
<span id="cb122-5"><a href="Cl.html#cb122-5" aria-hidden="true" tabindex="-1"></a>  mz_cl <span class="ot">&lt;-</span> <span class="fu">tapply</span>(mysample_h<span class="sc">$</span>z, <span class="at">INDEX =</span> mysample_h<span class="sc">$</span>cldraw, <span class="at">FUN =</span> mean)</span>
<span id="cb122-6"><a href="Cl.html#cb122-6" aria-hidden="true" tabindex="-1"></a>  mz_h[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(mz_cl)</span>
<span id="cb122-7"><a href="Cl.html#cb122-7" aria-hidden="true" tabindex="-1"></a>  v_mz_h[i] <span class="ot">&lt;-</span> <span class="fu">var</span>(mz_cl) <span class="sc">/</span> n_h[i]</span>
<span id="cb122-8"><a href="Cl.html#cb122-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb122-9"><a href="Cl.html#cb122-9" aria-hidden="true" tabindex="-1"></a>M_h <span class="ot">&lt;-</span> <span class="fu">tapply</span>(grdVoorst<span class="sc">$</span>z, <span class="at">INDEX =</span> grdVoorst<span class="sc">$</span>zonestratum, <span class="at">FUN =</span> length)</span>
<span id="cb122-10"><a href="Cl.html#cb122-10" aria-hidden="true" tabindex="-1"></a>w_h <span class="ot">&lt;-</span> M_h <span class="sc">/</span> M</span>
<span id="cb122-11"><a href="Cl.html#cb122-11" aria-hidden="true" tabindex="-1"></a>mz <span class="ot">&lt;-</span> <span class="fu">sum</span>(w_h <span class="sc">*</span> mz_h)</span>
<span id="cb122-12"><a href="Cl.html#cb122-12" aria-hidden="true" tabindex="-1"></a>se_mz <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">sum</span>(w_h<span class="sc">^</span><span class="dv">2</span> <span class="sc">*</span> v_mz_h))</span></code></pre></div>
<p>The estimated mean equals 82.8 g kg<sup>-1</sup>, and the estimated standard error equals 4.7 g kg<sup>-1</sup>. The same estimates are obtained with function <code>svymean</code>. Weights for the clusters are computed as before, but now at the level of the strata. Note argument <code>nest = TRUE</code>, which means that the clusters are nested within the strata.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="Cl.html#cb123-1" aria-hidden="true" tabindex="-1"></a>mysample<span class="sc">$</span>weights <span class="ot">&lt;-</span> M_h[mysample<span class="sc">$</span>zonestratum] <span class="sc">/</span></span>
<span id="cb123-2"><a href="Cl.html#cb123-2" aria-hidden="true" tabindex="-1"></a>  (M_cl[mysample<span class="sc">$</span>cluster] <span class="sc">*</span> n_h[mysample<span class="sc">$</span>zonestratum])</span>
<span id="cb123-3"><a href="Cl.html#cb123-3" aria-hidden="true" tabindex="-1"></a>design_strcluster <span class="ot">&lt;-</span> <span class="fu">svydesign</span>(<span class="at">id =</span> <span class="sc">~</span> cldraw, <span class="at">strata =</span> <span class="sc">~</span> zonestratum,</span>
<span id="cb123-4"><a href="Cl.html#cb123-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">weights =</span> <span class="sc">~</span> weights, <span class="at">data =</span> mysample, <span class="at">nest =</span> <span class="cn">TRUE</span>)</span>
<span id="cb123-5"><a href="Cl.html#cb123-5" aria-hidden="true" tabindex="-1"></a><span class="fu">svymean</span>(<span class="sc">~</span> z, design_strcluster)</span></code></pre></div>
<pre><code>    mean     SE
z 82.796 4.6737</code></pre>
<div id="exercises-10" class="section level4 unnumbered">
<h4>Exercises</h4>
<ol start="3" style="list-style-type: decimal">
<li>Why is it attractive in stratified random cluster sampling to select at least two clusters per stratum?</li>
</ol>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Berger2004" class="csl-entry">
Berger, Y. G. 2004. <span>“A Simple Variance Estimator for Unequal Probability Sampling Without Replacement.”</span> <em>Canadian Journal of Applied Statistics</em> 31 (3): 305–15. <a href="https://doi.org/10.1080/0266476042000184046">https://doi.org/10.1080/0266476042000184046</a>.
</div>
<div id="ref-coc77" class="csl-entry">
Cochran, W. G. 1977. <em>Sampling Techniques</em>. New York: Wiley.
</div>
<div id="ref-gru06" class="csl-entry">
de Gruijter, J. J., D. J. Brus, M. F. P. Bierkens, and M. Knotters. 2006. <em>Sampling for Natural Resource Monitoring</em>. Berlin: Springer.
</div>
<div id="ref-loh99" class="csl-entry">
Lohr, S. L. 1999. <em>Sampling: Design and Analysis</em>. Pacific Grove: Duxbury Press.
</div>
<div id="ref-Lumley2020" class="csl-entry">
———. 2021. <em><span class="nocase">survey: Analysis of Complex Survey Samples</span></em>.
</div>
<div id="ref-Tille2006" class="csl-entry">
Tillé, Y. 2006. <em>Sampling Algorithms</em>. New York: Springer.
</div>
<div id="ref-Tille2016" class="csl-entry">
Tillé, Y., and A. Matei. 2021. <em><span class="nocase">sampling: Survey Sampling</span></em>. <a href="https://CRAN.R-project.org/package=sampling">https://CRAN.R-project.org/package=sampling</a>.
</div>
</div>
<div class="footnotes">
<hr />
<ol start="2">
<li id="fn2"><p>The problem is the computation of the joint inclusion probabilities of pairs of points.<a href="Cl.html#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="SY.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="Twostage.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/DickBrus/SpatialSamplingwithR/edit/master/06-Cluster.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["SpatialSampling.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
